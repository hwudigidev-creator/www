var It=Object.defineProperty;var Pt=(tt,x,t)=>x in tt?It(tt,x,{enumerable:!0,configurable:!0,writable:!0,value:t}):tt[x]=t;var k=(tt,x,t)=>Pt(tt,typeof x!="symbol"?x+"":x,t);import{P as z}from"./phaser-0RJB29YE.js";(function(){const x=document.createElement("link").relList;if(x&&x.supports&&x.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))e(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&e(i)}).observe(document,{childList:!0,subtree:!0});function t(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function e(s){if(s.ep)return;s.ep=!0;const o=t(s);fetch(s.href,o)}})();class At extends z.Scene{constructor(){super("BootScene")}preload(){this.load.image("effect_circle","effects/circle.png"),this.load.image("effect_line","effects/line.png");const x=[30,40,50,60,70,80,90,100,110,120,130,140,150,160];for(const t of x)this.load.image(`effect_sector_${t}`,`effects/sector_${t}.png`)}create(){this.scene.start("MainScene")}}const ft=[{id:"active_soul_render",name:"靈魂渲染",subtitle:"動畫大師",description:"朝最近敵人發射 3 單位扇形攻擊，每級擴大 10°",type:"active",color:6724095,flashColor:6737151,cooldown:1e3,maxLevel:5,iconPrefix:"A",levelUpMessages:["60° 扇形、2 傷害","70° 扇形、3 傷害","80° 扇形、4 傷害","90° 扇形、5 傷害","100° 扇形、6 傷害","110° 扇形、7 傷害，已達最大等級！"],levelUpQuotes:["你練習了繪畫技法，動畫美術的能力提升了","你習得了分鏡設計，並獲得了動態腳本製作技術","你增進了手繪動畫和停格動畫的製作技術","你苦練了3D角色模型和3D場景的設計","你完全理解了動畫法則，提升了角色動畫的製作精度","你成為了動畫大師，即將解鎖驚人的能力"],maxExtraAbility:{name:"穿透",description:"攻擊後 {value} 機率發射扇形波（每 0.3 秒傷害一次）",baseValue:0,perLevel:.007,unit:"%",isPercentage:!0}},{id:"active_coder",name:"咒言幻象",subtitle:"遊戲先知",description:"對周圍 2 單位敵人造成傷害，每級增加 0.5 單位範圍",type:"active",color:11167487,flashColor:13404415,cooldown:1500,maxLevel:5,iconPrefix:"C",levelUpMessages:["2 單位範圍、1 傷害","2.5 單位範圍、2 傷害","3 單位範圍、3 傷害","3.5 單位範圍、4 傷害","4 單位範圍、5 傷害","4.5 單位範圍、6 傷害，已達最大等級！"],levelUpQuotes:["你參透了互動設計的原理，同時了解遊戲企劃架構","你習得動作捕捉的技術，將應用到虛擬實境製作","你增進了程式設計能力和遊戲引擎的創作能力","你整合了虛擬網紅製作技術，讓自媒體營銷具爆發力","你導入了人工智慧協作能力，產能提升了數倍","你成為了遊戲先知，即將解鎖驚人的能力"],maxExtraAbility:{name:"爆發",description:"擊殺時 {value} 機率再發動（可連鎖）",baseValue:0,perLevel:.01,unit:"%",isPercentage:!0}},{id:"active_vfx",name:"疾光狙擊",subtitle:"超級導演",description:"朝隨機敵人發射 10 單位貫穿光束，每級增加 1 道",type:"active",color:6750054,flashColor:8978312,cooldown:2500,maxLevel:5,iconPrefix:"B",levelUpMessages:["1 道光束、1 傷害","2 道光束、2 傷害","3 道光束、3 傷害","4 道光束、4 傷害","5 道光束、5 傷害","6 道光束、6 傷害，已達最大等級！"],levelUpQuotes:["你研究了影像美學，劇本編導的能力提升了","你習得了動靜態攝影的能力，獲得了畫面控制的技術","你增進了影片剪輯和動態影像的設計能力","你苦練了數位成音技術影像獲得更多回饋","你學會應用特效合成後製提升了影像各種可能性","你成為了超級導演，即將解鎖驚人的能力"],maxExtraAbility:{name:"連鎖",description:"擊中時 {value} 機率產生 X 型射線",baseValue:0,perLevel:5e-4,unit:"%",isPercentage:!0}},{id:"active_architect",name:"靈魂統領",subtitle:"架構師",description:"產生 30% HP 護盾（霸體）並反傷攻擊者，護盾消失時回復等值 HP",type:"active",color:16763904,flashColor:16768324,cooldown:1e4,maxLevel:5,levelUpMessages:["30% HP 護盾、1 反傷","30% HP 護盾、2.5 反傷","30% HP 護盾、4 反傷","30% HP 護盾、5.5 反傷","30% HP 護盾、7 反傷","30% HP 護盾、8.5 反傷，已達最大等級！"],maxExtraAbility:{name:"堅守",description:"護盾覆蓋時 {value} 機率炸開",baseValue:0,perLevel:.01,unit:"%",isPercentage:!0}},{id:"passive_titanium_liver",name:"鈦金屬賽博肝臟",description:"提升 10% HP 總量並每 15 秒回復 1% 最大 HP，每級再 +10% HP、回復間隔 -1 秒",type:"passive",color:11189196,maxLevel:5,iconPrefix:"P01",levelUpMessages:["+10% HP、每 15 秒回血","+20% HP、每 14 秒回血","+30% HP、每 13 秒回血","+40% HP、每 12 秒回血","+50% HP、每 11 秒回血","+60% HP、每 10 秒回血，已達最大等級！"],levelUpQuotes:["","","","","","千錘百鍊的鈦金肝再也不怕熬夜"],maxExtraAbility:{name:"不死",description:"抵銷一次死亡，觸發暗影爆炸",triggerQuote:"不知何處湧上的力量將你推回現實...",baseValue:1,perLevel:0,unit:"次",isPercentage:!1}},{id:"passive_sync_rate",name:"精神同步率強化",description:"提升 10% 移速、減少 8% 冷卻，每級再疊加",type:"passive",color:14518340,maxLevel:5,iconPrefix:"P02",levelUpMessages:["+10% 移速、-8% 冷卻","+20% 移速、-16% 冷卻","+30% 移速、-24% 冷卻","+40% 移速、-32% 冷卻","+50% 移速、-40% 冷卻","+60% 移速、-48% 冷卻，已達最大等級！"],levelUpQuotes:["","","","","","你已進入無限心流狀態，感覺身手異常敏捷迅速"],maxExtraAbility:{name:"迅捷",description:"閃避機率 +{value}",baseValue:0,perLevel:.002,unit:"%",isPercentage:!0}},{id:"passive_retina_module",name:"視網膜增強模組",description:"提升 30% 經驗取得，每級再 +30%",type:"passive",color:10035763,maxLevel:5,iconPrefix:"P03",levelUpMessages:["+30% 經驗","+60% 經驗","+90% 經驗","+120% 經驗","+150% 經驗","+180% 經驗，已達最大等級！"],levelUpQuotes:["","","","","","千錘百鍊的敏銳觀察，再沒什麼看不穿、看不清"],maxExtraAbility:{name:"洞察",description:"暴擊率 +{value}",baseValue:0,perLevel:.005,unit:"%",isPercentage:!0}},{id:"passive_ai_enhancement",name:"AI賦能強化",description:"提升 25% 攻擊、15% 防禦，每級再疊加",type:"passive",color:6719658,maxLevel:5,iconPrefix:"P04",levelUpMessages:["+25% 攻擊、+15% 防禦","+50% 攻擊、+30% 防禦","+75% 攻擊、+45% 防禦","+100% 攻擊、+60% 防禦","+125% 攻擊、+75% 防禦","+150% 攻擊、+90% 防禦，已達最大等級！"],levelUpQuotes:["","","","","","熟練的AI操作，讓你無論做任何事情效率提高數十倍"],maxExtraAbility:{name:"超載",description:"暴擊傷害 +{value}",baseValue:0,perLevel:.005,unit:"%",isPercentage:!0}}],nt=class nt{constructor(){k(this,"playerSkills",new Map)}getActiveSkillDefinitions(){return ft.filter(x=>x.type==="active")}getPassiveSkillDefinitions(){return ft.filter(x=>x.type==="passive")}getPlayerSkill(x){return this.playerSkills.get(x)}getPlayerActiveSkills(){const x=[];this.playerSkills.forEach(e=>{e.definition.type==="active"&&x.push(e)});const t=[];for(let e=0;e<4;e++)t.push(x[e]||null);return t}getPlayerPassiveSkills(){const x=[];this.playerSkills.forEach(e=>{e.definition.type==="passive"&&x.push(e)});const t=[];for(let e=0;e<nt.MAX_PASSIVE_SLOTS;e++)t.push(x[e]||null);return t}getOwnedPassiveCount(){let x=0;return this.playerSkills.forEach(t=>{t.definition.type==="passive"&&x++}),x}isPassiveSlotsFull(){return this.getOwnedPassiveCount()>=nt.MAX_PASSIVE_SLOTS}getSkillLevel(x){const t=this.playerSkills.get(x);return t?t.level:-1}isSkillMaxLevel(x){const t=this.playerSkills.get(x);return t?t.level>=t.definition.maxLevel:!1}learnOrUpgradeSkill(x){const t=ft.find(s=>s.id===x);if(!t)return!1;const e=this.playerSkills.get(x);if(e){if(e.level>=t.maxLevel)return!1;e.level++}else this.playerSkills.set(x,{definition:t,level:0});return!0}getUpgradeableActiveSkills(){return this.getActiveSkillDefinitions().filter(x=>{const t=this.playerSkills.get(x.id);return!t||t.level<x.maxLevel})}getUpgradeablePassiveSkills(){const x=this.isPassiveSlotsFull();return this.getPassiveSkillDefinitions().filter(t=>{const e=this.playerSkills.get(t.id);return x?e&&e.level<t.maxLevel:!e||e.level<t.maxLevel})}hasAnyActiveSkill(){return this.getActiveSkillDefinitions().some(t=>this.playerSkills.has(t.id))}getRandomSkillOptions(){const x=this.getUpgradeableActiveSkills(),t=this.getUpgradeablePassiveSkills(),e=[];if(!this.hasAnyActiveSkill()){for(let i=0;i<Math.min(3,x.length);i++)e.push(x[i]);return e}const s=this.shuffleArray([...x]);for(let i=0;i<Math.min(2,s.length);i++)e.push(s[i]);const o=this.shuffleArray([...t]);return o.length>0&&e.push(o[0]),e}hasUpgradeableSkills(){return this.getUpgradeableActiveSkills().length>0||this.getUpgradeablePassiveSkills().length>0}shuffleArray(x){for(let t=x.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[x[t],x[e]]=[x[e],x[t]]}return x}static formatLevel(x,t=5){return x<=0?"Lv.0":x>=t?"MAX":`Lv.${x}`}getTitaniumLiverHpBonus(){const x=this.playerSkills.get("passive_titanium_liver");return x?(x.level+1)*.1:0}getTitaniumLiverRegenInterval(){const x=this.playerSkills.get("passive_titanium_liver");return x?(15-x.level)*1e3:0}hasTitaniumLiver(){return this.playerSkills.has("passive_titanium_liver")}getSyncRateSpeedBonus(){const x=this.playerSkills.get("passive_sync_rate");return x?(x.level+1)*.1:0}getSyncRateCooldownReduction(){const x=this.playerSkills.get("passive_sync_rate");return x?(x.level+1)*.08:0}getRetinaModuleExpBonus(){const x=this.playerSkills.get("passive_retina_module");return x?(x.level+1)*.3:0}getAiEnhancementDamageBonus(){const x=this.playerSkills.get("passive_ai_enhancement");return x?(x.level+1)*.25:0}getAiEnhancementDefenseBonus(){const x=this.playerSkills.get("passive_ai_enhancement");return x?(x.level+1)*.15:0}calculateFinalMaxHp(x){const t=this.getTitaniumLiverHpBonus();return Math.floor(x*(1+t))}calculateFinalMoveSpeed(x){const t=this.getSyncRateSpeedBonus();return x*(1+t)}calculateFinalCooldown(x){const t=this.getSyncRateCooldownReduction();return x*(1-t)}calculateFinalExp(x){const t=this.getRetinaModuleExpBonus();return Math.floor(x*(1+t))}calculateFinalDamage(x){const t=this.getAiEnhancementDamageBonus();return Math.floor(x*(1+t))}calculateFinalDamageWithCrit(x,t){const e=this.getAiEnhancementDamageBonus();let s=Math.floor(x*(1+e));const o=this.getRetinaModuleCritChance(t);let i=!1;if(o>0&&Math.random()<o){i=!0;const r=1.5,l=this.getAiEnhancementCritDamage(t),a=r+l;s=Math.floor(s*a)}return{damage:s,isCrit:i}}calculateFinalDamageTaken(x){const t=this.getAiEnhancementDefenseBonus();return Math.floor(x*(1-t))}getMaxExtraAbilityValue(x,t){const e=this.playerSkills.get(x);if(!e||e.level<e.definition.maxLevel)return 0;const s=e.definition.maxExtraAbility;return s?s.baseValue+s.perLevel*t:0}getMaxExtraAbilityText(x,t){const e=this.playerSkills.get(x);if(!e||e.level<e.definition.maxLevel)return null;const s=e.definition.maxExtraAbility;if(!s)return null;const o=this.getMaxExtraAbilityValue(x,t),i=s.isPercentage?(o*100).toFixed(1):o.toFixed(1);return`【${s.name}】${s.description.replace("{value}",i+s.unit)}`}getAllMaxExtraAbilities(x){const t=[];return this.playerSkills.forEach((e,s)=>{const o=this.getMaxExtraAbilityText(s,x);o&&t.push({skillId:s,text:o})}),t}getSoulRenderWaveChance(x){return this.getMaxExtraAbilityValue("active_soul_render",x)}getCoderBurstChance(x){return this.getMaxExtraAbilityValue("active_coder",x)}getVfxChainChance(x){return this.getMaxExtraAbilityValue("active_vfx",x)}getArchitectExplosionChance(x){return this.getMaxExtraAbilityValue("active_architect",x)}hasTitaniumLiverRevive(){const x=this.playerSkills.get("passive_titanium_liver");return x?x.level>=x.definition.maxLevel:!1}getSyncRateDodgeChance(x){return this.getMaxExtraAbilityValue("passive_sync_rate",x)}getRetinaModuleCritChance(x){return this.getMaxExtraAbilityValue("passive_retina_module",x)}getAiEnhancementCritDamage(x){return this.getMaxExtraAbilityValue("passive_ai_enhancement",x)}};k(nt,"MAX_PASSIVE_SLOTS",3);let lt=nt;const dt=[{id:"slime",name:"史萊姆",color:6750054,speed:1,damage:1,size:.05,hp:30,exp:20},{id:"boss_slime",name:"BOSS 史萊姆",color:4856427,speed:.6,damage:3,size:.15,hp:30,exp:200},{id:"bat",name:"蝙蝠",color:8930474,speed:8,damage:.5,size:.025,hp:10,exp:5}],st=class st{constructor(x,t,e,s){k(this,"scene");k(this,"monsters",[]);k(this,"nextMonsterId",0);k(this,"clipMask",null);k(this,"spawnInterval",2e3);k(this,"lastSpawnTime",0);k(this,"isSpawning",!1);k(this,"batSwarmInterval",3e4);k(this,"lastBatSwarmTime",0);k(this,"batSwarmCount",8);k(this,"bossSpawnedAtLevels",new Set);k(this,"gameBounds");k(this,"mapWidth");k(this,"mapHeight");k(this,"playerLevel",0);k(this,"gridCellSize",4);k(this,"gridScaleMultiplier",3);k(this,"monsterGridContainer");k(this,"monsterGridCells",[]);k(this,"screenGridCols",0);k(this,"screenGridRows",0);this.scene=x,this.gameBounds=t,this.mapWidth=e,this.mapHeight=s,this.updateGridCellSize(),this.createMonsterGrid()}setPlayerLevel(x){return this.playerLevel=x,x>=10&&x%10===0&&!this.bossSpawnedAtLevels.has(x)?(this.bossSpawnedAtLevels.add(x),!0):!1}spawnBoss(x,t){const e=this.playerLevel,s=dt.find(p=>p.id==="boss_slime");if(!s)return;const o=["top","left","right"],i=o[Math.floor(Math.random()*o.length)];let r,l;const a=150,c=x,h=x+this.gameBounds.width,n=t;switch(i){case"top":r=c+Math.random()*this.gameBounds.width,l=n-a;break;case"left":r=c-a,l=n+Math.random()*this.gameBounds.height;break;case"right":r=h+a,l=n+Math.random()*this.gameBounds.height;break}const S=this.calculateMonsterHp(s.hp)*e,y={id:this.nextMonsterId++,definition:s,x:r,y:l,hp:S,lastDamageTime:0,bouncePhase:Math.random()*Math.PI*2,bounceSpeed:1.5+Math.random()*.5,squashStretch:1,flashStartTime:0,isBoss:!0,bossHpMultiplier:e};this.monsters.push(y),console.log(`BOSS Slime spawned at level ${e}! HP: ${S}`)}setGridScaleMultiplier(x){this.gridScaleMultiplier=x,this.updateGridCellSize(),this.recreateMonsterGrid()}updateGridCellSize(){const x=this.scene.cameras.main.width,t=1920,e=20/this.gridScaleMultiplier,s=6/this.gridScaleMultiplier,o=Math.min(1,x/t);this.gridCellSize=Math.max(s,Math.floor(e*o))}setClipMask(x){this.clipMask=x,this.monsterGridContainer&&this.monsterGridContainer.setMask(x)}createMonsterGrid(){this.monsterGridContainer=this.scene.add.container(this.gameBounds.x,this.gameBounds.y),this.monsterGridContainer.setDepth(5),this.clipMask&&this.monsterGridContainer.setMask(this.clipMask),this.screenGridCols=Math.ceil(this.gameBounds.width/this.gridCellSize)+1,this.screenGridRows=Math.ceil(this.gameBounds.height/this.gridCellSize)+1;for(let x=0;x<this.screenGridRows;x++)for(let t=0;t<this.screenGridCols;t++){const e=t*this.gridCellSize,s=x*this.gridCellSize,o=this.scene.add.rectangle(e,s,this.gridCellSize,this.gridCellSize,0,0);o.setOrigin(0,0),o.setVisible(!1),this.monsterGridContainer.add(o),this.monsterGridCells.push({rect:o,screenCol:t,screenRow:x})}}recreateMonsterGrid(){this.monsterGridCells.forEach(x=>x.rect.destroy()),this.monsterGridCells=[],this.monsterGridContainer&&this.monsterGridContainer.destroy(),this.createMonsterGrid()}calculateMonsterHp(x){return Math.floor(x*Math.pow(st.HP_GROWTH_RATE,this.playerLevel))}calculateMonsterDamage(x){const t=Math.max(1,this.playerLevel);return st.DAMAGE_UNIT*t*x.definition.damage}calculateMonsterExp(x){const t=Math.floor(this.playerLevel/5);return x*Math.pow(2,t)}startSpawning(){this.isSpawning=!0,this.lastSpawnTime=this.scene.time.now,this.lastBatSwarmTime=this.scene.time.now}stopSpawning(){this.isSpawning=!1}update(x,t,e,s,o){const i=this.scene.time.now;let r=0;const l=[];if(this.isSpawning&&i-this.lastSpawnTime>=this.spawnInterval){const h=1+Math.floor(this.playerLevel/5);for(let n=0;n<h;n++)this.spawnMonster(t,e,s,o);this.lastSpawnTime=i}this.isSpawning&&i-this.lastBatSwarmTime>=this.batSwarmInterval&&(this.spawnBatSwarm(s,o),this.lastBatSwarmTime=i);const a=this.gameBounds.height*.1,c=[];return this.monsters.forEach(h=>{if(h.isBat&&h.directionX!==void 0&&h.directionY!==void 0){const S=h.definition.speed*this.gameBounds.height*.1*x/1e3;h.x+=h.directionX*S,h.y+=h.directionY*S;const y=this.gameBounds.height*.3,p=s-y,M=s+this.gameBounds.width+y,C=o-y,u=o+this.gameBounds.height+y;(h.x<p||h.x>M||h.y<C||h.y>u)&&c.push(h.id);const d=t-h.x,b=e-h.y;Math.sqrt(d*d+b*b)<=a&&i-h.lastDamageTime>=3e3&&(r+=this.calculateMonsterDamage(h),h.lastDamageTime=i,l.push(h))}else{const f=t-h.x,S=e-h.y,y=Math.sqrt(f*f+S*S);if(y>a){const C=h.definition.speed*this.gameBounds.height*.1*x/1e3/y;h.x+=f*C,h.y+=S*C}else i-h.lastDamageTime>=3e3&&(r+=this.calculateMonsterDamage(h),h.lastDamageTime=i,l.push(h))}h.bouncePhase+=h.bounceSpeed*x/1e3,h.bouncePhase>Math.PI*2&&(h.bouncePhase-=Math.PI*2);const n=.08;h.squashStretch=1+Math.sin(h.bouncePhase)*n}),c.forEach(h=>{this.monsters=this.monsters.filter(n=>n.id!==h)}),this.renderMonstersToGrid(s,o),{damage:r,hitMonsters:l}}spawnMonster(x,t,e,s){const o=["top","left","right"],i=o[Math.floor(Math.random()*o.length)];let r,l;const a=100,c=e,h=e+this.gameBounds.width,n=s;switch(i){case"top":r=c+Math.random()*this.gameBounds.width,l=n-a;break;case"left":r=c-a,l=n+Math.random()*this.gameBounds.height;break;case"right":r=h+a,l=n+Math.random()*this.gameBounds.height;break}r=Phaser.Math.Clamp(r,0,this.mapWidth),l=Phaser.Math.Clamp(l,0,this.mapHeight);const f=dt[0],S=this.calculateMonsterHp(f.hp),y={id:this.nextMonsterId++,definition:f,x:r,y:l,hp:S,lastDamageTime:0,bouncePhase:Math.random()*Math.PI*2,bounceSpeed:3+Math.random()*2,squashStretch:1,flashStartTime:0};this.monsters.push(y)}spawnBatSwarm(x,t){const e=["topLeft","topRight","bottomLeft","bottomRight"],s=e[Math.floor(Math.random()*e.length)],o=x,i=x+this.gameBounds.width,r=t,l=t+this.gameBounds.height,a=this.gameBounds.height*.15;let c,h,n,f;switch(s){case"topLeft":c=o-a,h=r-a,n=i+a*2,f=l+a*2;break;case"topRight":c=i+a,h=r-a,n=o-a*2,f=l+a*2;break;case"bottomLeft":c=o-a,h=l+a,n=i+a*2,f=r-a*2;break;case"bottomRight":default:c=i+a,h=l+a,n=o-a*2,f=r-a*2;break}const S=dt.find(M=>M.id==="bat")||dt[0],y=[],p=this.gameBounds.height*.04;for(let M=0;M<this.batSwarmCount;M++){let C,u,d=0;const b=50;do{const E=Math.random()*Math.PI*2,P=Math.random()*a;if(C=c+Math.cos(E)*P,u=h+Math.sin(E)*P,d++,!y.some(G=>{const R=G.x-C,H=G.y-u;return Math.sqrt(R*R+H*H)<p})||d>=b)break}while(!0);y.push({x:C,y:u});const m=n-C,g=f-u,w=Math.sqrt(m*m+g*g),I=m/w,v=g/w,T={id:this.nextMonsterId++,definition:S,x:C,y:u,hp:st.BAT_FIXED_HP,lastDamageTime:0,bouncePhase:Math.random()*Math.PI*2,bounceSpeed:5+Math.random()*3,squashStretch:1,flashStartTime:0,isBat:!0,directionX:I,directionY:v};this.monsters.push(T)}console.log(`Bat swarm spawned from ${s}! Count: ${this.batSwarmCount}`)}renderMonstersToGrid(x,t){const e=this.gridCellSize,s=this.scene.time.now,o=new Map;this.monsters.forEach(i=>{const r=this.gameBounds.height*i.definition.size,l=i.squashStretch,a=1/i.squashStretch,c=i.x-x,h=i.y-t,n=Math.floor(c/e),f=Math.floor(h/e),S=Math.ceil(r/e/2),y=Math.ceil(S*a),p=Math.ceil(S*l),M=i.definition.color;let C=M>>16&255,u=M>>8&255,d=M&255,b=!1;const m=300;if(i.flashStartTime>0){const E=s-i.flashStartTime;if(E<m){b=!0;const P=Math.floor(E/60)%2,B=E<m/2?1:1-(E-m/2)/(m/2);P===0?(C=Math.min(255,Math.floor(C+(255-C)*B)),u=Math.min(255,Math.floor(u+(255-u)*B)),d=Math.min(255,Math.floor(d+(255-d)*B))):(C=Math.min(255,Math.floor(C+(255-C)*B)),u=Math.floor(u*(1-B*.8)),d=Math.floor(d*(1-B*.8)))}else i.flashStartTime=0}if(i.isBat){const P=(Math.sin(i.bouncePhase*3)*.5+.5)*.8-.2,B=Math.max(2,Math.ceil(y*.6)),G=Math.max(2,Math.ceil(p*.8)),R=Math.max(3,Math.ceil(y*3)),H=Math.max(2,Math.ceil(p*1.5)),F=(D,$,O,W)=>{if(D>=0&&D<this.screenGridCols&&$>=0&&$<this.screenGridRows){const U=`${D},${$}`,Z=o.get(U);(!Z||W>Z.alpha)&&o.set(U,{color:O,alpha:W})}},_=C<<16|u<<8|d,L=Math.floor(C*.7)<<16|Math.floor(u*.7)<<8|Math.floor(d*.7),Y=Math.floor(C*.5)<<16|Math.floor(u*.5)<<8|Math.floor(d*.5);for(let D=-G;D<=G;D++)for(let $=-B;$<=B;$++){const O=$/B,W=D/G;O*O+W*W<=1&&F(n+$,f+D,_,.95)}const X=Math.max(1,Math.floor(B*.6)),V=Math.max(1,Math.floor(G*.6));for(let D=0;D<=V;D++){const $=Math.max(1,V-D);for(let O=0;O<$;O++)F(n-X+O,f-G-D-1,_,.9)}for(let D=0;D<=V;D++){const $=Math.max(1,V-D);for(let O=0;O<$;O++)F(n+X-O,f-G-D-1,_,.9)}for(let D=1;D<=R;D++){const $=D/R,O=Math.floor(H*$*(1-$*.3)),W=Math.floor(P*$*H),U=-O+W,Z=Math.floor(O*.3)+W;for(let q=U;q<=Z;q++){const j=Math.floor(Math.sin($*Math.PI*2+i.bouncePhase)*.5),Q=.85-$*.3,et=q<(U+Z)/2?L:Y;F(n-B-D,f+q+j,et,Q)}if(D%2===0&&D<R-1){const q=Math.floor((U+Z)/2+W);F(n-B-D,f+q,_,.9)}}for(let D=1;D<=R;D++){const $=D/R,O=Math.floor(H*$*(1-$*.3)),W=Math.floor(P*$*H),U=-O+W,Z=Math.floor(O*.3)+W;for(let q=U;q<=Z;q++){const j=Math.floor(Math.sin($*Math.PI*2+i.bouncePhase)*.5),Q=.85-$*.3,et=q<(U+Z)/2?L:Y;F(n+B+D,f+q+j,et,Q)}if(D%2===0&&D<R-1){const q=Math.floor((U+Z)/2+W);F(n+B+D,f+q,_,.9)}}const K=f-Math.floor(G*.3),N=Math.max(1,Math.floor(B*.4));F(n-N,K,16711680,1),F(n+N,K,16711680,1);return}else{for(let E=-p;E<=0;E++)for(let P=-y;P<=y;P++){const B=P/y,G=E/p,R=B*B+G*G;if(R<=1.1){const F=(.5+(1-Math.pow(Math.min(1,R),.5))*.5)*(R<=1?1:(1.1-R)/.1),_=b?1:1+(1-G)*.4,L=Math.min(255,Math.floor(C*_)),Y=Math.min(255,Math.floor(u*_)),X=Math.min(255,Math.floor(d*_)),V=L<<16|Y<<8|X,K=n+P,N=f+E;if(K>=0&&K<this.screenGridCols&&N>=0&&N<this.screenGridRows){const D=`${K},${N}`,$=o.get(D);(!$||F>$.alpha)&&o.set(D,{color:V,alpha:F})}}}for(let E=-y;E<=y;E++){const P=E/y;if(Math.abs(P)<=1){const B=b?1:.7,G=Math.floor(C*B),R=Math.floor(u*B),H=Math.floor(d*B),F=G<<16|R<<8|H,_=n+E,L=f;if(_>=0&&_<this.screenGridCols&&L>=0&&L<this.screenGridRows){const Y=`${_},${L}`;o.set(Y,{color:F,alpha:.9})}}}}const g=Math.max(1,Math.floor(y*.35)),w=Math.floor(p*.5),I=n-g,v=n+g,T=f-w;if(I>=0&&I<this.screenGridCols&&T>=0&&T<this.screenGridRows&&o.set(`${I},${T}`,{color:0,alpha:1}),v>=0&&v<this.screenGridCols&&T>=0&&T<this.screenGridRows&&o.set(`${v},${T}`,{color:0,alpha:1}),!b){const E=Math.floor(y*.4),P=Math.floor(p*.7),B=n-E,G=f-P;B>=0&&B<this.screenGridCols&&G>=0&&G<this.screenGridRows&&o.set(`${B},${G}`,{color:16777215,alpha:.8})}});for(const i of this.monsterGridCells){const r=`${i.screenCol},${i.screenRow}`,l=o.get(r);l?(i.rect.setFillStyle(l.color,l.alpha),i.rect.setVisible(!0)):i.rect.setVisible(!1)}}removeMonster(x){const t=this.monsters.findIndex(e=>e.id===x);t!==-1&&this.monsters.splice(t,1)}getMonsters(){return this.monsters}clearAllMonsters(){this.monsters=[]}setSpawnInterval(x){this.spawnInterval=x}damageMonster(x,t){const e=this.monsters.find(s=>s.id===x);if(!e)return{killed:!1,exp:0};if(e.hp-=t,this.flashMonster(e),e.hp<=0){const s=e.isBat?st.BAT_FIXED_EXP:this.calculateMonsterExp(e.definition.exp);return this.playDeathSmoke(e.x,e.y),this.removeMonster(x),{killed:!0,exp:s}}return{killed:!1,exp:0}}flashMonster(x){x.flashStartTime=this.scene.time.now}playDeathSmoke(x,t){const e=this.scene;e.flashDeathEffect&&e.flashDeathEffect(x,t)}damageMonsters(x,t){let e=0,s=0;const o=[];for(const i of x){const r=this.monsters.find(c=>c.id===i),l=r?{x:r.x,y:r.y}:null,a=this.damageMonster(i,t);a.killed&&l&&(e+=a.exp,s++,o.push(l))}return{totalExp:e,killCount:s,killedPositions:o}}};k(st,"BAT_FIXED_HP",10),k(st,"BAT_FIXED_EXP",5),k(st,"HP_GROWTH_RATE",1.1),k(st,"DAMAGE_UNIT",10);let kt=st;const A=class A extends z.Scene{constructor(){super("MainScene");k(this,"character");k(this,"characterState","idle");k(this,"facingRight",!0);k(this,"skillIcons",[]);k(this,"skillIconGridGraphics",[]);k(this,"skillIconGridData",[]);k(this,"gameBounds");k(this,"boundsBorder");k(this,"background");k(this,"gameAreaContainer");k(this,"revealMask");k(this,"mapWidth");k(this,"mapHeight");k(this,"characterX");k(this,"characterY");k(this,"characterSize");k(this,"isPointerDown",!1);k(this,"moveDirX",0);k(this,"moveDirY",0);k(this,"baseMoveSpeed",0);k(this,"moveSpeed",0);k(this,"floorGrid");k(this,"worldContainer");k(this,"characterContainer");k(this,"uiContainer");k(this,"cameraOffsetX",0);k(this,"cameraOffsetY",0);k(this,"cursors");k(this,"isKeyboardMoving",!1);k(this,"skillPanelContainer");k(this,"isPaused",!1);k(this,"skillOptions",[]);k(this,"skillCardBgs",[]);k(this,"gameTimer",0);k(this,"timerText");k(this,"selectedSkillIndex",0);k(this,"currentSkillChoices",[]);k(this,"skillCutInContainer");k(this,"skillManager",new lt);k(this,"skillIconContainers",[]);k(this,"skillLevelTexts",[]);k(this,"skillIconSprites",[]);k(this,"skillInfoPanel");k(this,"skillInfoBg");k(this,"skillInfoText");k(this,"skillInfoHideTimer");k(this,"currentExp",0);k(this,"maxExp",100);k(this,"currentLevel",0);k(this,"expBarContainer");k(this,"expBarFlowOffset",0);k(this,"levelText");k(this,"currentHp",200);k(this,"maxHp",200);k(this,"hpBarContainer");k(this,"hpBarFlowOffset",0);k(this,"hpText");k(this,"currentShield",0);k(this,"maxShield",0);k(this,"shieldBarFlowOffset",0);k(this,"shieldReflectDamage",0);k(this,"shieldText");k(this,"shieldAuraGraphics");k(this,"shieldSparkleTimer",0);k(this,"hpRegenTimer",0);k(this,"reviveUsed",!1);k(this,"displayedHp",200);k(this,"hpDamageDelay",0);k(this,"isMobile",!1);k(this,"keyPlus");k(this,"keyMinus");k(this,"keyShift");k(this,"keyCtrl");k(this,"keyZero");k(this,"keyBackspace");k(this,"keyF5");k(this,"keyF6");k(this,"keyF7");k(this,"keyF8");k(this,"keyF9");k(this,"keyF10");k(this,"keyF11");k(this,"keyF12");k(this,"showGridSkillEffects",!1);k(this,"monsterManager");k(this,"isHurt",!1);k(this,"hurtEndTime",0);k(this,"lowHpBreathTimer",0);k(this,"isLowHp",!1);k(this,"vignetteEdgeCells",new Set);k(this,"skillCooldowns",new Map);k(this,"isAttacking",!1);k(this,"attackEndTime",0);k(this,"gameBgm");k(this,"currentBgmKey","");k(this,"skillGridContainer");k(this,"skillGridCells",[]);k(this,"skillGridCols",0);k(this,"skillGridRows",0);k(this,"skillGridCellSize",10);k(this,"gridScaleMultiplier",3);k(this,"activeSkillGridCells",new Set);k(this,"skillEffectPool",[]);k(this,"activeSkillEffects",[])}create(){this.cameras.main.setBackgroundColor("#111111"),this.isMobile=this.sys.game.device.input.touch&&window.innerWidth<1024,this.gridScaleMultiplier=this.isMobile?2:3;const t=this.cameras.main.width,e=this.cameras.main.height;if(this.gameBounds=this.registry.get("gameBounds"),!this.gameBounds){const l=t*.9,a=e*(1-.05*2),c=16/9,h=l/a;let n,f;h>c?(f=a,n=a*c):(n=l,f=l/c),this.gameBounds={x:(t-n)/2,y:(e-f)/2,width:n,height:f}}this.mapWidth=this.gameBounds.width*A.MAP_SCALE,this.mapHeight=this.gameBounds.height*A.MAP_SCALE,this.characterSize=this.gameBounds.height*.15,this.baseMoveSpeed=this.gameBounds.height*.3,this.moveSpeed=this.baseMoveSpeed,this.characterX=this.mapWidth/2,this.characterY=this.mapHeight/2,this.createFullscreenBackground(t,e),this.gameAreaContainer=this.add.container(0,0),this.gameAreaContainer.setDepth(0),this.drawGameBorder(),this.worldContainer=this.add.container(this.gameBounds.x,this.gameBounds.y),this.floorGrid=this.add.graphics(),this.drawFloorGrid(),this.worldContainer.add(this.floorGrid),this.createCharacterAnimations(),this.characterContainer=this.add.container(this.gameBounds.x,this.gameBounds.y),this.shieldAuraGraphics=this.add.graphics(),this.characterContainer.add(this.shieldAuraGraphics),this.character=this.add.sprite(this.characterX,this.characterY,"char_idle_1"),this.character.setScale(this.characterSize/this.character.height),this.character.setOrigin(.5,1),this.character.play("char_idle"),this.characterContainer.add(this.character),this.gameAreaContainer.add([this.boundsBorder,this.worldContainer]);const s=this.make.graphics({x:0,y:0});s.fillStyle(16777215),s.fillRect(this.gameBounds.x,this.gameBounds.y,this.gameBounds.width,this.gameBounds.height);const o=s.createGeometryMask();this.worldContainer.setMask(o),this.uiContainer=this.add.container(0,0),this.uiContainer.setDepth(100),this.monsterManager=new kt(this,this.gameBounds,this.mapWidth,this.mapHeight),this.monsterManager.setGridScaleMultiplier(this.gridScaleMultiplier),this.monsterManager.setClipMask(o),this.createSkillGrid(),this.initSkillEffectPool(),window.addEventListener("gridscalechange",r=>{this.gridScaleMultiplier=r.detail.scale,this.recreateSkillGrid(),this.monsterManager.setGridScaleMultiplier(r.detail.scale)}),this.characterContainer.setDepth(60),this.characterContainer.setMask(o),this.uiContainer.add(this.characterContainer),this.createSkillBar(),this.revealMask=this.make.graphics({x:0,y:0});const i=this.revealMask.createGeometryMask();this.gameAreaContainer.setMask(i),this.uiContainer.setMask(i),this.registry.events.on("reveal-update",this.updateRevealMask,this),this.registry.events.on("reveal-complete",this.onRevealComplete,this),this.input.on("pointerdown",this.onPointerDown,this),this.input.on("pointermove",this.onPointerMove,this),this.input.on("pointerup",this.onPointerUp,this),this.input.keyboard&&(this.cursors={W:this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.W),A:this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.A),S:this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.S),D:this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.D)},this.keyPlus=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.PLUS),this.keyMinus=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.MINUS),this.keyShift=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.SHIFT),this.keyCtrl=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.CTRL),this.keyZero=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.ZERO),this.keyBackspace=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.BACKSPACE),this.keyF5=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.F5),this.keyF6=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.F6),this.keyF7=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.F7),this.keyF8=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.F8),this.keyF9=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.F9),this.keyF10=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.F10),this.keyF11=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.F11),this.keyF12=this.input.keyboard.addKey(z.Input.Keyboard.KeyCodes.F12)),this.updateCamera(!0),this.createHpBar(),this.createShieldBar(),this.createExpBar(),this.createSkillPanel(),this.createSkillCutIn(),this.createLowHpVignette()}update(t,e){if(this.updateHpBarFlow(e),this.updateShieldBarFlow(e),this.updateExpBarFlow(e),this.updateShieldAura(e),this.updateHpRegen(e),this.updateLowHpVignetteBreathing(e),this.updateSkillCooldownDisplay(),this.isPaused){this.handleSkillPanelInput();return}this.gameTimer+=e,this.updateTimerDisplay(),this.handleExpTestInput();const s=this.time.now;this.isHurt&&s>=this.hurtEndTime&&(this.isHurt=!1,this.setCharacterState("idle"),this.updateCharacterSprite()),this.isAttacking&&s>=this.attackEndTime&&(this.isAttacking=!1,this.character.clearTint(),this.isPointerDown||this.isKeyboardMoving?this.setCharacterState("run",!0):this.setCharacterState("idle",!0)),this.isHurt||(this.handleKeyboardInput(e),this.isPointerDown&&!this.isKeyboardMoving&&this.moveCharacter(e));const o=this.monsterManager.update(e,this.characterX,this.characterY,this.cameraOffsetX,this.cameraOffsetY);o.damage>0&&this.takeDamage(o.damage,o.hitMonsters),this.tryActivateSkills(s)}tryActivateSkills(t){if(this.isHurt)return;const e=this.skillManager.getPlayerActiveSkills();for(const s of e){if(!s)continue;const o=s.definition;let i=o.cooldown||1e3;o.id==="active_architect"&&(i=i-s.level*500);const r=this.skillManager.calculateFinalCooldown(i),l=this.skillCooldowns.get(o.id)||0;t-l>=r&&(this.activateSkill(s,t),this.skillCooldowns.set(o.id,t))}}activateSkill(t,e){const s=t.definition;switch(this.isAttacking=!0,this.attackEndTime=e+A.ATTACK_DURATION,this.setCharacterState("attack",!0),s.flashColor&&this.character.setTint(s.flashColor),s.id){case"active_soul_render":this.activateSoulRender(t);break;case"active_coder":this.activateCoder(t);break;case"active_vfx":this.activateVfx(t);break;case"active_architect":this.activateArchitect(t);break;default:console.log(`Skill activated: ${s.name}`)}}activateSoulRender(t){const e=this.monsterManager.getMonsters();if(e.length===0)return;let s=e[0],o=1/0;for(const M of e){const C=M.x-this.characterX,u=M.y-this.characterY,d=Math.sqrt(C*C+u*u);d<o&&(o=d,s=M)}const i=Math.atan2(s.y-this.characterY,s.x-this.characterX);this.facingRight=Math.cos(i)>=0,this.updateCharacterSprite();const r=this.gameBounds.height*.3,a=(60+t.level*10)/2*(Math.PI/180),c=2+t.level,h=A.DAMAGE_UNIT*c,{damage:n,isCrit:f}=this.skillManager.calculateFinalDamageWithCrit(h,this.currentLevel),S=[];for(const M of e){const C=this.gameBounds.height*M.definition.size*.5,u=M.x-this.characterX,d=M.y-this.characterY,b=Math.sqrt(u*u+d*d);if(b-C>r)continue;let g=Math.atan2(d,u)-i;for(;g>Math.PI;)g-=Math.PI*2;for(;g<-Math.PI;)g+=Math.PI*2;const w=b>0?Math.atan2(C,b):Math.PI;Math.abs(g)<=a+w&&S.push(M.id)}this.drawSectorEdge(i,r,a,t.definition.color);const y=t.definition.flashColor||t.definition.color;if(this.showGridSkillEffects)this.flashSkillAreaSector(this.characterX,this.characterY,r,i,a,y);else{const M=a*(180/Math.PI);this.flashSkillEffectSector(this.characterX,this.characterY,r,i,M,y)}if(S.length>0){const M=e.filter(d=>S.includes(d.id)).map(d=>({x:d.x,y:d.y})),C=this.monsterManager.damageMonsters(S,n);C.totalExp>0&&this.addExp(C.totalExp),f?this.flashCritCrossAtPositions(M):this.flashWhiteCrossAtPositions(M),this.shakeScreen(S.length);const u=f?" [CRIT!]":"";console.log(`Soul Render hit ${S.length} monsters for ${n} damage${u}, killed ${C.killCount}, exp +${C.totalExp}`)}const p=this.skillManager.getSoulRenderWaveChance(this.currentLevel);p>0&&Math.random()<p&&this.triggerSoulRenderWave(i,r,a,n,t)}drawSectorEdge(t,e,s,o){const i=this.add.graphics();this.skillGridContainer.add(i),i.setDepth(55);const r=t-s,l=t+s,a=this.characterX,c=this.characterY,h=500,n=300,f=this.time.now,S=15,y=(C,u,d,b,m)=>{for(let g=0;g<S;g++){const w=g/S,I=(g+1)/S,v=(w+I)/2,T=Math.min(1,v/.15),E=Math.min(1,(1-v)/.15),P=Math.min(T,E),B=d*P*P;if(B>.01){const G=e*w,R=e*I,H=b+Math.cos(C)*G,F=m+Math.sin(C)*G,_=b+Math.cos(C)*R,L=m+Math.sin(C)*R;i.lineStyle(u,16777215,B),i.beginPath(),i.moveTo(H,F),i.lineTo(_,L),i.strokePath()}}},p=()=>{const C=this.time.now-f,u=Math.min(C/h,1);i.clear();const d=this.worldToScreen(a,c),b=d.x,m=d.y;let g=0;C>n&&(g=(C-n)/(h-n));const w=1*(1-g);w>.01&&(y(r,2,w,b,m),y(l,2,w,b,m)),u>=1&&i.destroy()};p();const M=this.time.addEvent({delay:16,callback:p,callbackScope:this,repeat:Math.ceil(h/16)});this.time.delayedCall(h+50,()=>{i.active&&i.destroy(),M.remove()})}drawCircleEdge(t,e,s,o){const i=this.add.graphics();this.skillGridContainer.add(i),i.setDepth(55);const r=s??this.characterX,l=o??this.characterY,a=500,c=300,h=this.time.now,n=3,f=Math.PI*2/n,S=24,y=()=>{const M=this.time.now-h,C=Math.min(M/a,1);i.clear();const u=this.worldToScreen(r,l),d=u.x,b=u.y;let m=0;M>c&&(m=(M-c)/(a-c));const g=1*(1-m);if(g>.01)for(let w=0;w<n;w++){const I=w*f-Math.PI/2;for(let v=0;v<S;v++){const T=v/S,E=.2+.8*Math.abs(Math.cos(T*Math.PI)),P=g*E,B=I+v/S*f,G=I+(v+1)/S*f,R=d+Math.cos(B)*t,H=b+Math.sin(B)*t,F=d+Math.cos(G)*t,_=b+Math.sin(G)*t;i.lineStyle(2,16777215,P),i.beginPath(),i.moveTo(R,H),i.lineTo(F,_),i.strokePath()}}C>=1&&i.destroy()};y();const p=this.time.addEvent({delay:16,callback:y,callbackScope:this,repeat:Math.ceil(a/16)});this.time.delayedCall(a+50,()=>{i.active&&i.destroy(),p.remove()})}drawBeamEdge(t,e,s,o,i,r){const l=this.add.graphics();this.worldContainer.add(l);const a=i??this.characterX,c=r??this.characterY,h=Math.cos(t),n=Math.sin(t),f=800,S=380,y=this.time.now,p=20,M=()=>{const u=this.time.now-y,d=Math.min(u/f,1);l.clear();let b=0;u>S&&(b=(u-S)/(f-S));const m=.6*(1-b*.5);if(m>.01)for(let g=0;g<p;g++){const w=g/p,I=(g+1)/p,v=(w+I)/2,T=Math.min(1,v/.15),E=Math.min(1,(1-v)/.15),P=Math.min(T,E),B=m*P*P;if(B>.01){const G=a+h*e*w,R=c+n*e*w,H=a+h*e*I,F=c+n*e*I;l.lineStyle(2,16777215,B),l.beginPath(),l.moveTo(G,R),l.lineTo(H,F),l.strokePath()}}d>=1&&l.destroy()};M();const C=this.time.addEvent({delay:16,callback:M,callbackScope:this,repeat:Math.ceil(f/16)});this.time.delayedCall(f+50,()=>{l.active&&l.destroy(),C.remove()})}activateCoder(t){const e=this.monsterManager.getMonsters();if(e.length===0)return;const s=this.gameBounds.height*.1,o=2+t.level*.5,i=s*o,r=1+t.level,l=A.DAMAGE_UNIT*r,{damage:a,isCrit:c}=this.skillManager.calculateFinalDamageWithCrit(l,this.currentLevel),h=[];for(const f of e){const S=this.gameBounds.height*f.definition.size*.5,y=f.x-this.characterX,p=f.y-this.characterY;Math.sqrt(y*y+p*p)-S<=i&&h.push(f.id)}this.drawCircleEdge(i,t.definition.color);const n=t.definition.flashColor||t.definition.color;if(this.showGridSkillEffects?this.flashSkillAreaCircle(this.characterX,this.characterY,i,n):this.flashSkillEffectCircle(this.characterX,this.characterY,i,n),h.length>0){const f=e.filter(M=>h.includes(M.id)).map(M=>({x:M.x,y:M.y})),S=this.monsterManager.damageMonsters(h,a);S.totalExp>0&&this.addExp(S.totalExp),c?this.flashCritCrossAtPositions(f):this.flashWhiteCrossAtPositions(f),this.shakeScreen(h.length);const y=c?" [CRIT!]":"";console.log(`Coder hit ${h.length} monsters for ${a} damage${y}, killed ${S.killCount}, exp +${S.totalExp}`);const p=this.skillManager.getCoderBurstChance(this.currentLevel);p>0&&S.killedPositions.length>0&&this.triggerCoderBurst(S.killedPositions,i,a,t,p)}}triggerSoulRenderWave(t,e,s,o,i){const r=this.gameBounds.height*.1,l=r*5,a=e*s*2,c=i.definition.flashColor||i.definition.color,h=this.characterX,n=this.characterY;this.showGridSkillEffects?this.flashSkillAreaSectorMoving(h,n,e,t,s,c,l):this.flashSkillEffectSectorMoving(h,n,e,t,s,c,l);const f=1e3,S=300,y=r*1,p=M=>{const C=e+l*M,u=a/(2*C),d=this.monsterManager.getMonsters(),b=[];for(const m of d){const g=this.gameBounds.height*m.definition.size*.5,w=m.x-h,I=m.y-n,v=Math.sqrt(w*w+I*I);if(Math.abs(v-C)>y+g)continue;let E=Math.atan2(I,w)-t;for(;E>Math.PI;)E-=Math.PI*2;for(;E<-Math.PI;)E+=Math.PI*2;const P=v>0?Math.atan2(g,v):Math.PI;Math.abs(E)<=u+P&&b.push(m.id)}if(b.length>0){const m=d.filter(w=>b.includes(w.id)).map(w=>({x:w.x,y:w.y})),g=this.monsterManager.damageMonsters(b,o);g.totalExp>0&&this.addExp(g.totalExp),this.flashWhiteCrossAtPositions(m)}};for(let M=S;M<=f;M+=S){const C=M/f;this.time.delayedCall(M,()=>{p(C)})}}flashSkillAreaSectorMoving(t,e,s,o,i,r,l){const a=this.worldToScreen(t,e),c=a.x,h=a.y,n=A.SKILL_GRID_GAP,f=this.skillGridCellSize+n,S=1e3,y=this.time.now,p=Math.cos(o),M=Math.sin(o),C=s+l+s,u=[],d=Math.max(0,Math.floor((c-C)/f)),b=Math.min(this.skillGridCols-1,Math.ceil((c+C)/f)),m=Math.max(0,Math.floor((h-C)/f)),g=Math.min(this.skillGridRows-1,Math.ceil((h+C)/f));for(let v=m;v<=g;v++)for(let T=d;T<=b;T++){const E=T*f+this.skillGridCellSize/2,P=v*f+this.skillGridCellSize/2;u.push({col:T,row:v,screenX:E,screenY:P})}if(u.length===0)return;const w=[];for(const{col:v,row:T}of u){const E=v*f+this.skillGridCellSize/2,P=T*f+this.skillGridCellSize/2,B=this.add.rectangle(E,P,this.skillGridCellSize,this.skillGridCellSize,r,0);B.setVisible(!1),this.skillGridContainer.add(B),w.push(B)}const I=()=>{const v=this.time.now-y,T=Math.min(v/S,1),E=l*T,P=c+p*E,B=h+M*E,G=.5,R=T>G?(T-G)/(1-G):0;let H=0;for(const{screenX:F,screenY:_}of u){const L=w[H++];if(!L)continue;const Y=F-P,X=_-B,V=Math.sqrt(Y*Y+X*X),K=s*.5;if(V>=K&&V<=s){let D=Math.atan2(X,Y)-o;for(;D>Math.PI;)D-=Math.PI*2;for(;D<-Math.PI;)D+=Math.PI*2;if(Math.abs(D)<=i){const $=(V-K)/(s-K),O=Math.abs(D)/i,W=Math.max($,O),U=Math.max(0,Math.min(1,(W-.3)/.7)),Z=U*U*(3-2*U),j=(.15+Z*.6)*(1-R);if(j>.01){const Q=.5+Z*.5,et=r>>16&255,at=r>>8&255,gt=r&255,rt=Math.floor(et*Q),ht=Math.floor(at*Q),ct=Math.floor(gt*Q),it=rt<<16|ht<<8|ct;L.setFillStyle(it,j),L.setVisible(!0)}else L.setVisible(!1)}else L.setVisible(!1)}else L.setVisible(!1)}if(T>=1)for(const F of w)F.destroy();else this.time.delayedCall(16,I)};I()}triggerCoderBurst(t,e,s,o,i){const r=this.monsterManager.getMonsters();if(r.length===0)return;const l=e*.5;for(const a of t){if(Math.random()>=i)continue;const c=[];for(const n of r){const f=this.gameBounds.height*n.definition.size*.5,S=n.x-a.x,y=n.y-a.y;Math.sqrt(S*S+y*y)-f<=l&&c.push(n.id)}this.drawCircleEdge(l,o.definition.color,a.x,a.y);const h=o.definition.flashColor||o.definition.color;if(this.showGridSkillEffects?this.flashSkillAreaCircle(a.x,a.y,l,h):this.flashSkillEffectCircle(a.x,a.y,l,h),c.length>0){const n=r.filter(S=>c.includes(S.id)).map(S=>({x:S.x,y:S.y})),f=this.monsterManager.damageMonsters(c,s);f.totalExp>0&&this.addExp(f.totalExp),this.flashWhiteCrossAtPositions(n),console.log(`Coder Burst hit ${c.length} monsters for ${s} damage`)}}}activateVfx(t){const e=this.monsterManager.getMonsters();if(e.length===0)return;const s=t.level+1,o=this.gameBounds.height*1,i=this.gameBounds.height*.05,r=1+t.level,l=A.DAMAGE_UNIT*r,{damage:a,isCrit:c}=this.skillManager.calculateFinalDamageWithCrit(l,this.currentLevel),h=new Set,n=e.map((y,p)=>p),f=[];for(let y=0;y<s;y++){let p;if(n.length>0){const d=Math.floor(Math.random()*n.length),b=n[d];n.splice(d,1);const m=e[b];p=Math.atan2(m.y-this.characterY,m.x-this.characterX)}else p=Math.random()*Math.PI*2;f.push(p);for(const d of e){const b=this.gameBounds.height*d.definition.size*.5,m=d.x-this.characterX,g=d.y-this.characterY;if(Math.sqrt(m*m+g*g)-b>o)continue;const I=Math.cos(p),v=Math.sin(p);if(m*I+g*v<-b)continue;Math.abs(m*v-g*I)<=i/2+b&&h.add(d.id)}this.drawBeamEdge(p,o,i,t.definition.color);const M=this.characterX+Math.cos(p)*o,C=this.characterY+Math.sin(p)*o,u=t.definition.flashColor||t.definition.color;this.showGridSkillEffects?this.flashSkillAreaLine(this.characterX,this.characterY,M,C,i,u):this.flashSkillEffectLine(this.characterX,this.characterY,M,C,i,u)}f.length>0&&(this.facingRight=Math.cos(f[0])>=0,this.updateCharacterSprite());const S=Array.from(h);if(S.length>0){const p=e.filter(d=>S.includes(d.id)).map(d=>({x:d.x,y:d.y})),M=this.monsterManager.damageMonsters(S,a);M.totalExp>0&&this.addExp(M.totalExp),c?this.flashCritCrossAtPositions(p):this.flashWhiteCrossAtPositions(p),this.shakeScreen(S.length);const C=c?" [CRIT!]":"";console.log(`VFX (${s} beams) hit ${S.length} monsters for ${a} damage${C}, killed ${M.killCount}, exp +${M.totalExp}`);const u=this.skillManager.getVfxChainChance(this.currentLevel);u>0&&p.length>0&&this.triggerVfxChain(p,a,u,t)}}triggerVfxChain(t,e,s,o){const i=this.monsterManager.getMonsters();if(i.length===0)return;const r=this.gameBounds.height*.5,l=this.gameBounds.height*.05,a=o.definition.flashColor||o.definition.color,c=[Math.PI/4,Math.PI*3/4,Math.PI*5/4,Math.PI*7/4];for(const h of t){if(Math.random()>=s)continue;const n=new Set;for(const S of c){for(const M of i){const C=this.gameBounds.height*M.definition.size*.5,u=M.x-h.x,d=M.y-h.y;if(Math.sqrt(u*u+d*d)-C>r)continue;const m=Math.cos(S),g=Math.sin(S),w=u*m+d*g;if(w<-C||w>r+C)continue;Math.abs(u*g-d*m)<=l/2+C&&n.add(M.id)}this.drawBeamEdge(S,r,l,o.definition.color,h.x,h.y);const y=h.x+Math.cos(S)*r,p=h.y+Math.sin(S)*r;this.showGridSkillEffects?this.flashSkillAreaLine(h.x,h.y,y,p,l,a):this.flashSkillEffectLine(h.x,h.y,y,p,l,a)}const f=Array.from(n);if(f.length>0){const S=i.filter(p=>n.has(p.id)).map(p=>({x:p.x,y:p.y})),y=this.monsterManager.damageMonsters(f,e);y.totalExp>0&&this.addExp(y.totalExp),this.flashWhiteCrossAtPositions(S),console.log(`VFX X-Chain hit ${f.length} monsters for ${e} damage`)}}}_drawBeamEffect(t,e,s,o){const i=this.add.graphics();this.worldContainer.add(i);const r=this.characterX,l=this.characterY,a=r+Math.cos(t)*e,c=l+Math.sin(t)*e,h=s*1.5,n=Math.sin(t)*h/2,f=-Math.cos(t)*h/2,S=Math.sin(t)*h*.4/2,y=-Math.cos(t)*h*.4/2,p=15,M=1e3,C=this.time.now,u=()=>{const b=this.time.now-C,m=Math.min(b/M,1);i.clear();const g=.3,w=m<g?0:(m-g)/(1-g);for(let T=0;T<p;T++){const E=T/p,P=(T+1)/p,B=r+(a-r)*E,G=l+(c-l)*E,R=r+(a-r)*P,H=l+(c-l)*P,_=.85*(1-E*.6)*(1-w);_>.01&&(i.fillStyle(o,_),i.beginPath(),i.moveTo(B-n,G-f),i.lineTo(R-n,H-f),i.lineTo(R+n,H+f),i.lineTo(B+n,G+f),i.closePath(),i.fillPath())}for(let T=0;T<p;T++){const E=T/p,P=(T+1)/p,B=r+(a-r)*E,G=l+(c-l)*E,R=r+(a-r)*P,H=l+(c-l)*P,F=.98*(1-E*.5)*(1-w);F>.01&&(i.fillStyle(16777215,F),i.beginPath(),i.moveTo(B-S,G-y),i.lineTo(R-S,H-y),i.lineTo(R+S,H+y),i.lineTo(B+S,G+y),i.closePath(),i.fillPath())}const I=1*(1-w);I>.01&&(i.lineStyle(6,16777215,I),i.beginPath(),i.moveTo(r,l),i.lineTo(a,c),i.strokePath());const v=1*(1-w);v>.01&&(i.lineStyle(4,o,v),i.beginPath(),i.moveTo(r-n,l-f),i.lineTo(a-n,c-f),i.lineTo(a+n,c+f),i.lineTo(r+n,l+f),i.closePath(),i.strokePath(),i.lineStyle(2,16777215,v*.6),i.beginPath(),i.moveTo(r-n*1.1,l-f*1.1),i.lineTo(a-n*1.1,c-f*1.1),i.lineTo(a+n*1.1,c+f*1.1),i.lineTo(r+n*1.1,l+f*1.1),i.closePath(),i.strokePath()),m>=1&&i.destroy()},d=this.time.addEvent({delay:16,callback:u,callbackScope:this,repeat:Math.ceil(M/16)});this.time.delayedCall(M+50,()=>{i.active&&i.destroy(),d.remove()})}_drawCrossStarBurst(t,e){const o=this.gameBounds.height*.1*1,i=600;for(const r of t){const l=this.add.graphics();this.worldContainer.add(l);const a=this.time.now,c=()=>{const n=this.time.now-a,f=Math.min(n/i,1);l.clear();const S=f<.2?f/.2:1,y=f<.4?0:(f-.4)/.6,p=o*S,M=1-y;if(M>.01&&p>0){const C=p*.2,u=p,d=p*.4;l.fillStyle(16777215,M),l.fillCircle(r.x,r.y,d);for(let g=0;g<4;g++){const w=g*Math.PI/2,I=Math.cos(w),v=Math.sin(w),T=-v,E=I,P=6;for(let B=0;B<P;B++){const G=B/P,R=(B+1)/P,H=C*(1-G*.8),F=C*(1-R*.8),_=r.x+I*u*G,L=r.y+v*u*G,Y=r.x+I*u*R,X=r.y+v*u*R,V=M*(1-G*.7);l.fillStyle(e,V*.8),l.beginPath(),l.moveTo(_+T*H,L+E*H),l.lineTo(Y+T*F,X+E*F),l.lineTo(Y-T*F,X-E*F),l.lineTo(_-T*H,L-E*H),l.closePath(),l.fillPath();const K=H*.5,N=F*.5;l.fillStyle(16777215,V*.9),l.beginPath(),l.moveTo(_+T*K,L+E*K),l.lineTo(Y+T*N,X+E*N),l.lineTo(Y-T*N,X-E*N),l.lineTo(_-T*K,L-E*K),l.closePath(),l.fillPath()}}const b=u*.5,m=C*.6;for(let g=0;g<4;g++){const w=g*Math.PI/2+Math.PI/4,I=Math.cos(w),v=Math.sin(w),T=-v,E=I,P=4;for(let B=0;B<P;B++){const G=B/P,R=(B+1)/P,H=m*(1-G*.9),F=m*(1-R*.9),_=r.x+I*b*G,L=r.y+v*b*G,Y=r.x+I*b*R,X=r.y+v*b*R,V=M*(1-G*.8)*.7;l.fillStyle(e,V),l.beginPath(),l.moveTo(_+T*H,L+E*H),l.lineTo(Y+T*F,X+E*F),l.lineTo(Y-T*F,X-E*F),l.lineTo(_-T*H,L-E*H),l.closePath(),l.fillPath()}}}f>=1&&l.destroy()};c();const h=this.time.addEvent({delay:16,callback:c,callbackScope:this,repeat:Math.ceil(i/16)});this.time.delayedCall(i+50,()=>{l.active&&l.destroy(),h.remove()})}}activateArchitect(t){const e=this.skillManager.getArchitectExplosionChance(this.currentLevel);e>0&&this.currentShield>0&&Math.random()<e&&this.triggerShieldExplosion(t);const s=Math.floor(this.maxHp*.3);this.currentShield=s,this.maxShield=s;const o=1+t.level*1.5;this.shieldReflectDamage=A.DAMAGE_UNIT*o,this.drawShieldBarFill();const i=this.gameBounds.height*.15,r=t.definition.flashColor||t.definition.color;this.showGridSkillEffects?this.flashSkillAreaCircle(this.characterX,this.characterY,i,r):this.flashSkillEffectCircle(this.characterX,this.characterY,i,r),console.log(`Architect activated: Shield ${s}, Reflect damage ${this.shieldReflectDamage} (${o} units)`)}triggerShieldExplosion(t){const s=this.gameBounds.height*.1*3,o=t.definition.color,i=t.definition.flashColor||o,r=this.shieldReflectDamage;if(this.maxShield>0){const c=this.maxShield;this.currentHp=Math.min(this.currentHp+c,this.maxHp),console.log(`Shield explosion! Healed ${c} HP, current HP: ${this.currentHp}/${this.maxHp}`),this.drawHpBarFill(),this.updateHpText(),this.updateLowHpVignette(),this.showHpHealEffect(c)}this.drawCircleEdge(s,o),this.showGridSkillEffects?this.flashSkillAreaCircle(this.characterX,this.characterY,s,i):this.flashSkillEffectCircle(this.characterX,this.characterY,s,i);const l=this.monsterManager.getMonsters(),a=[];for(const c of l){const h=this.gameBounds.height*c.definition.size*.5,n=c.x-this.characterX,f=c.y-this.characterY;Math.sqrt(n*n+f*f)-h<=s&&a.push(c.id)}if(a.length>0){const c=l.filter(n=>a.includes(n.id)).map(n=>({x:n.x,y:n.y})),h=this.monsterManager.damageMonsters(a,r);h.totalExp>0&&this.addExp(h.totalExp),this.flashWhiteCrossAtPositions(c),this.shakeScreen(a.length),console.log(`Shield Explosion hit ${a.length} monsters for ${r} damage`)}}_drawShieldActivateEffect(){const t=this.add.graphics();this.worldContainer.add(t);const e=this.characterX,s=this.characterY-this.characterSize/2,o=this.characterSize*1.2,i=16763904,r=800,l=this.time.now,a=()=>{const h=this.time.now-l,n=Math.min(h/r,1);t.clear();const f=n<.2?n/.2:1,S=n<.2?0:(n-.2)/.8,y=o*(.3+.7*f),p=1-S;if(p>.01){for(let d=8;d>=1;d--){const b=y*d/8,m=p*(1-(d-1)/8)*.6;m>.01&&(t.fillStyle(i,m),t.fillCircle(e,s,b))}const C=4;for(let d=C;d>=1;d--){const b=y*.4*d/C,m=p*(1-(d-1)/C)*.9;m>.01&&(t.fillStyle(16777215,m),t.fillCircle(e,s,b))}t.lineStyle(5,i,p*.9),t.strokeCircle(e,s,y),t.lineStyle(2,16777215,p*.7),t.strokeCircle(e,s,y*.95);const u=y*.7;t.lineStyle(3,16777215,p*.5),t.beginPath();for(let d=0;d<6;d++){const b=d*Math.PI/3,m=e+Math.cos(b)*u,g=s+Math.sin(b)*u;d===0?t.moveTo(m,g):t.lineTo(m,g)}t.closePath(),t.strokePath()}n>=1&&t.destroy()};a();const c=this.time.addEvent({delay:16,callback:a,callbackScope:this,repeat:Math.ceil(r/16)});this.time.delayedCall(r+50,()=>{t.active&&t.destroy(),c.remove()})}handleExpTestInput(){if(!(!this.keyPlus||!this.keyMinus||!this.keyShift)){if(this.keyShift.isDown&&z.Input.Keyboard.JustDown(this.keyBackspace)){this.showGridSkillEffects=!this.showGridSkillEffects,console.log(`Grid skill effects: ${this.showGridSkillEffects?"ON":"OFF"}`);return}if(this.keyShift.isDown&&z.Input.Keyboard.JustDown(this.keyZero)){this.maxOutAllSkills();return}if(this.keyCtrl.isDown&&this.keyShift.isDown){const t=[{key:this.keyF5,skillId:"active_soul_render"},{key:this.keyF6,skillId:"active_coder"},{key:this.keyF7,skillId:"active_vfx"},{key:this.keyF8,skillId:"active_architect"},{key:this.keyF9,skillId:"passive_titanium_liver"},{key:this.keyF10,skillId:"passive_sync_rate"},{key:this.keyF11,skillId:"passive_retina_module"},{key:this.keyF12,skillId:"passive_ai_enhancement"}];for(const{key:e,skillId:s}of t)if(e&&z.Input.Keyboard.JustDown(e)){this.maxOutSingleSkill(s);return}}if(this.keyShift.isDown&&z.Input.Keyboard.JustDown(this.keyPlus)){this.levelUp();return}this.keyPlus.isDown&&!this.keyShift.isDown&&this.addExp(10),this.keyMinus.isDown&&this.addExp(-10)}}maxOutSingleSkill(t){const e=ft.find(l=>l.id===t);if(!e)return;const s=this.skillManager.getSkillLevel(t),o=e.type==="passive";if(s>=e.maxLevel){console.log(`Test: ${e.name} is already MAX`);return}if(o&&s<0&&this.skillManager.isPassiveSlotsFull()){console.log(`Test: Passive slots full, cannot add ${e.name}`);return}const i=s<0?-1:s,r=e.maxLevel-i;this.currentLevel+=r,this.monsterManager.setPlayerLevel(this.currentLevel);for(let l=0;l<r;l++)this.skillManager.learnOrUpgradeSkill(t);this.recalculateMaxHp(),this.recalculateMoveSpeed(),this.currentHp=this.maxHp,this.displayedHp=this.maxHp,this.currentExp=0,this.maxExp=Math.floor(A.BASE_EXP*Math.pow(A.EXP_GROWTH_RATE,this.currentLevel)),this.drawHpBarFill(),this.updateHpText(),this.drawExpBarFill(),this.levelText.setText(`Lv.${this.currentLevel}`),this.updateSkillBarDisplay(),console.log(`Test: ${e.name} maxed! Player level: ${this.currentLevel}`)}maxOutAllSkills(){this.currentLevel=24;const e=this.skillManager.getActiveSkillDefinitions();for(const s of e)for(let o=0;o<=s.maxLevel;o++)this.skillManager.learnOrUpgradeSkill(s.id);this.monsterManager.setPlayerLevel(this.currentLevel),this.recalculateMaxHp(),this.recalculateMoveSpeed(),this.currentHp=this.maxHp,this.displayedHp=this.maxHp,this.currentExp=0,this.maxExp=Math.floor(A.BASE_EXP*Math.pow(A.EXP_GROWTH_RATE,this.currentLevel)),this.drawHpBarFill(),this.updateHpText(),this.drawExpBarFill(),this.levelText.setText(`Lv.${this.currentLevel}`),this.updateSkillBarDisplay(),console.log("Test: Jumped to level 24 with all active skills maxed!")}addExp(t){t>0&&(t=this.skillManager.calculateFinalExp(t)),this.currentExp+=t,this.currentExp<0&&(this.currentExp=0),this.currentExp>=this.maxExp&&this.levelUp(),this.drawExpBarFill()}levelUp(){this.currentLevel++,this.currentExp=0,this.maxExp=Math.floor(A.BASE_EXP*Math.pow(A.EXP_GROWTH_RATE,this.currentLevel)),this.recalculateMaxHp(),this.currentHp=this.maxHp,this.displayedHp=this.maxHp,this.monsterManager.setPlayerLevel(this.currentLevel)&&this.monsterManager.spawnBoss(this.cameraOffsetX,this.cameraOffsetY),this.levelText.setText(`Lv.${this.currentLevel}`),this.drawHpBarFill(),this.updateHpText(),this.updateLowHpVignette(),this.showSkillPanel(),this.drawExpBarFill(),console.log(`Level up! Lv.${this.currentLevel}, MaxHP: ${this.maxHp}, NextExp: ${this.maxExp}`)}recalculateMaxHp(){const t=A.BASE_HP+A.HP_PER_LEVEL*this.currentLevel,e=this.maxHp;if(this.maxHp=this.skillManager.calculateFinalMaxHp(t),this.maxHp>e&&e>0){const s=this.currentHp/e;this.currentHp=Math.floor(this.maxHp*s)}this.currentHp=Math.min(this.currentHp,this.maxHp)}recalculateMoveSpeed(){this.moveSpeed=this.skillManager.calculateFinalMoveSpeed(this.baseMoveSpeed)}handleSkillPanelInput(){if(!this.cursors)return;const t=this.currentSkillChoices.length;t===1?z.Input.Keyboard.JustDown(this.cursors.S)&&(this.selectedSkillIndex===0?this.confirmSkillSelection():this.setSelectedSkill(0)):t===2?(z.Input.Keyboard.JustDown(this.cursors.A)&&(this.selectedSkillIndex===0?this.confirmSkillSelection():this.setSelectedSkill(0)),z.Input.Keyboard.JustDown(this.cursors.D)&&(this.selectedSkillIndex===1?this.confirmSkillSelection():this.setSelectedSkill(1))):(z.Input.Keyboard.JustDown(this.cursors.A)&&(this.selectedSkillIndex===0?this.confirmSkillSelection():this.setSelectedSkill(0)),z.Input.Keyboard.JustDown(this.cursors.S)&&(this.selectedSkillIndex===1?this.confirmSkillSelection():this.setSelectedSkill(1)),z.Input.Keyboard.JustDown(this.cursors.D)&&(this.selectedSkillIndex===2?this.confirmSkillSelection():this.setSelectedSkill(2)))}setSelectedSkill(t){this.updateSkillCardStyle(this.selectedSkillIndex,!1),this.selectedSkillIndex=t,this.updateSkillCardStyle(this.selectedSkillIndex,!0)}updateSkillCardStyle(t,e){const s=this.skillCardBgs[t],o=this.skillOptions[t];!s||!o||(e?(s.setFillStyle(3355443),s.setStrokeStyle(3,16777215),this.tweens.add({targets:o,scaleX:1.05,scaleY:1.05,duration:100})):(s.setFillStyle(2236962),s.setStrokeStyle(2,6710886),this.tweens.add({targets:o,scaleX:1,scaleY:1,duration:100})))}confirmSkillSelection(){if(this.currentSkillChoices.length===0||this.selectedSkillIndex>=this.currentSkillChoices.length)return;const t=this.currentSkillChoices[this.selectedSkillIndex];this.selectSkill(this.selectedSkillIndex,t.id)}handleKeyboardInput(t){if(!this.cursors)return;let e=0,s=0;if(this.cursors.W.isDown&&(s=-1),this.cursors.S.isDown&&(s=1),this.cursors.A.isDown&&(e=-1),this.cursors.D.isDown&&(e=1),e!==0||s!==0){if(this.isKeyboardMoving=!0,this.isPointerDown=!1,e!==0&&(this.facingRight=e>0),e!==0&&s!==0){const i=1/Math.sqrt(2);e*=i,s*=i}const o=this.moveSpeed*t/1e3;this.characterX+=e*o,this.characterY+=s*o,this.characterX=z.Math.Clamp(this.characterX,this.characterSize,this.mapWidth-this.characterSize),this.characterY=z.Math.Clamp(this.characterY,this.characterSize,this.mapHeight-this.characterSize),this.setCharacterState("run"),this.updateCharacterSprite(),this.updateCamera()}else this.isKeyboardMoving=!1,this.isPointerDown||(this.setCharacterState("idle"),this.updateCharacterSprite())}onPointerDown(t){this.isPaused||this.isPointerInGameArea(t)&&(this.isPointerDown=!0,this.updateMoveDirectionFromPointer(t))}onPointerMove(t){!this.isPointerDown||this.isPaused||this.isPointerInGameArea(t)&&this.updateMoveDirectionFromPointer(t)}onPointerUp(){this.isPointerDown=!1,this.isKeyboardMoving||(this.setCharacterState("idle"),this.updateCharacterSprite())}isPointerInGameArea(t){return t.x>=this.gameBounds.x&&t.x<=this.gameBounds.x+this.gameBounds.width&&t.y>=this.gameBounds.y&&t.y<=this.gameBounds.y+this.gameBounds.height}updateMoveDirectionFromPointer(t){const e=t.x-this.gameBounds.x,s=t.y-this.gameBounds.y,o=e+this.cameraOffsetX,i=s+this.cameraOffsetY,r=o-this.characterX,l=i-this.characterY,a=Math.sqrt(r*r+l*l);a>0?(this.moveDirX=r/a,this.moveDirY=l/a):(this.moveDirX=0,this.moveDirY=0)}moveCharacter(t){const e=this.moveSpeed*t/1e3,s=this.characterX+this.moveDirX*e,o=this.characterY+this.moveDirY*e;this.characterX=z.Math.Clamp(s,this.characterSize,this.mapWidth-this.characterSize),this.characterY=z.Math.Clamp(o,this.characterSize,this.mapHeight-this.characterSize),this.moveDirX!==0&&this.updateCharacterFacing(this.characterX+this.moveDirX),this.setCharacterState("run"),this.updateCharacterSprite(),this.updateCamera()}updateCamera(t=!1){const e=this.cameraOffsetX+this.gameBounds.width/2,s=this.cameraOffsetY+this.gameBounds.height/2,o=this.characterX-e,i=this.characterY-s,r=this.gameBounds.width*A.CAMERA_DEAD_ZONE,l=this.gameBounds.height*A.CAMERA_DEAD_ZONE;t?(this.cameraOffsetX=this.characterX-this.gameBounds.width/2,this.cameraOffsetY=this.characterY-this.gameBounds.height/2):(Math.abs(o)>r/2&&(o>0?this.cameraOffsetX+=o-r/2:this.cameraOffsetX+=o+r/2),Math.abs(i)>l/2&&(i>0?this.cameraOffsetY+=i-l/2:this.cameraOffsetY+=i+l/2)),this.cameraOffsetX=z.Math.Clamp(this.cameraOffsetX,0,this.mapWidth-this.gameBounds.width),this.cameraOffsetY=z.Math.Clamp(this.cameraOffsetY,0,this.mapHeight-this.gameBounds.height),this.worldContainer.setPosition(this.gameBounds.x-this.cameraOffsetX,this.gameBounds.y-this.cameraOffsetY),this.characterContainer.setPosition(this.gameBounds.x-this.cameraOffsetX,this.gameBounds.y-this.cameraOffsetY)}updateRevealMask(t){this.revealMask&&(this.revealMask.clear(),this.revealMask.fillStyle(16777215),this.revealMask.fillCircle(t.x,t.y,t.radius))}onRevealComplete(){this.gameAreaContainer.clearMask(!0),this.uiContainer.clearMask(!0),this.revealMask.destroy(),this.registry.events.off("reveal-update",this.updateRevealMask,this),this.registry.events.off("reveal-complete",this.onRevealComplete,this);const t=document.getElementById("controls");t&&t.classList.add("visible"),this.showSkillPanel(),this.monsterManager.startSpawning(),this.playRandomGameBgm()}playRandomGameBgm(){const t=["bgm_game_01","bgm_game_02"];let e;if(this.currentBgmKey&&t.length>1){const s=t.filter(o=>o!==this.currentBgmKey);e=s[Math.floor(Math.random()*s.length)]}else e=t[Math.floor(Math.random()*t.length)];this.currentBgmKey=e,this.gameBgm&&(this.gameBgm.stop(),this.gameBgm.destroy()),this.cache.audio.exists(e)&&(this.gameBgm=this.sound.add(e,{volume:.5,loop:!1}),this.gameBgm.on("complete",()=>{this.playRandomGameBgm()}),this.gameBgm.play())}createFullscreenBackground(t,e){this.background=this.add.image(t/2,e/2,"background");const s=t/this.background.width,o=e/this.background.height,i=Math.max(s,o);this.background.setScale(i)}drawGameBorder(){this.boundsBorder=this.add.rectangle(this.gameBounds.x+this.gameBounds.width/2,this.gameBounds.y+this.gameBounds.height/2,this.gameBounds.width,this.gameBounds.height,0),this.boundsBorder.setStrokeStyle(2,4473924)}createHpBar(){this.hpBarContainer=this.add.container(0,0),this.hpBarContainer.setDepth(1001);const t=this.skillGridCellSize,e=this.gameBounds.y+t*2,s=Math.max(A.MIN_FONT_SIZE_MEDIUM,Math.floor(this.gameBounds.height*.03));this.hpText=this.add.text(this.gameBounds.x+this.gameBounds.width/2,e+t/2,`${this.currentHp} / ${this.maxHp}`,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${s}px`,color:"#ffffff",fontStyle:"bold",stroke:"#000000",strokeThickness:4}),this.hpText.setResolution(2),this.hpText.setOrigin(.5,.5),this.hpText.setDepth(1002),this.hpBarContainer.add(this.hpText),this.drawHpBarFill(),this.uiContainer.add(this.hpBarContainer)}drawHpBarFill(){const t=[1,2,3],e=[1,2],s=this.skillGridCols-2,o=this.currentHp/this.maxHp,i=Math.floor(s*o),r=this.displayedHp/this.maxHp,l=Math.floor(s*r);for(const a of t)for(let c=0;c<s;c++){const h=c+1,n=a*this.skillGridCols+h,f=this.skillGridCells[n];f&&(f.setFillStyle(0,.9),f.setVisible(!0),f.setDepth(1e3))}if(l>i)for(const a of t)for(let c=i;c<l;c++){const h=c+1,n=a*this.skillGridCols+h,f=this.skillGridCells[n];if(!f)continue;const S=t.indexOf(a),y=S===0?.85:S===1?.75:.65;f.setFillStyle(16777215,y)}if(i>0)for(const a of t)for(let c=0;c<i;c++){const h=c+1,n=a*this.skillGridCols+h,f=this.skillGridCells[n];if(!f)continue;const S=c/s,y=this.hpBarFlowOffset,p=(S+y)%1,M=(Math.sin(p*Math.PI*2-Math.PI/2)+1)/2,C=Math.floor(136-34*M),u=0,d=Math.floor(34+102*M),b=C<<16|u<<8|d,m=t.indexOf(a),g=m===0?.95:m===1?.85:.75;f.setFillStyle(b,g)}if(this.currentShield>0&&this.maxShield>0){const a=this.currentShield/this.maxShield,c=Math.floor(s*a);for(const h of e)for(let n=0;n<s;n++){const f=n+1,S=h*this.skillGridCols+f,y=this.skillGridCells[S];if(y&&n<c){const p=n/s,M=this.shieldBarFlowOffset,C=(p+M)%1,u=(Math.sin(C*Math.PI*2-Math.PI/2)+1)/2,d=255,b=Math.floor(204+51*u),m=Math.floor(0+204*u),g=d<<16|b<<8|m,w=h===e[0]?.95:.8;y.setFillStyle(g,w)}}}}updateHpBarFlow(t){this.hpBarFlowOffset+=.2*t/1e3,this.hpBarFlowOffset>=1&&(this.hpBarFlowOffset-=1),this.updateDamageDisplay(t),this.drawHpBarFill()}updateDamageDisplay(t){if(this.displayedHp>this.currentHp)if(this.hpDamageDelay>0)this.hpDamageDelay-=t;else{const s=(this.displayedHp-this.currentHp)*A.HP_DAMAGE_LERP_SPEED*(t/1e3);this.displayedHp-=Math.max(1,s),this.displayedHp<this.currentHp&&(this.displayedHp=this.currentHp)}else this.displayedHp<this.currentHp&&(this.displayedHp=this.currentHp)}updateHpText(){this.hpText&&(this.currentShield>0?this.hpText.setText(`${this.currentHp}+${this.currentShield}/${this.maxHp}`):this.hpText.setText(`${this.currentHp}/${this.maxHp}`))}createShieldBar(){const t=this.skillGridCellSize,e=this.gameBounds.y+t*2,s=Math.max(A.MIN_FONT_SIZE_SMALL,Math.floor(this.gameBounds.height*.025));this.shieldText=this.add.text(this.gameBounds.x+this.gameBounds.width-10,e+t/2,"",{fontFamily:"monospace",fontSize:`${s}px`,color:"#ffdd44",fontStyle:"bold",stroke:"#000000",strokeThickness:3}),this.shieldText.setOrigin(1,.5),this.shieldText.setDepth(1002),this.shieldText.setVisible(!1),this.uiContainer.add(this.shieldText)}drawShieldBarFill(){this.shieldText.setVisible(!1),this.updateHpText()}updateShieldBarFlow(t){if(this.currentShield<=0)return;const e=.6;this.shieldBarFlowOffset+=e*t/1e3,this.shieldBarFlowOffset>=1&&(this.shieldBarFlowOffset-=1),this.drawShieldBarFill()}updateShieldAura(t){if(this.shieldAuraGraphics.clear(),this.currentShield<=0)return;const e=this.characterX,s=this.characterY,o=this.characterSize*.8,i=this.characterSize*.35,r=s-this.characterSize*.15;for(let a=5;a>=0;a--){const c=1+a*.08,h=.12-a*.018,n=3+a*2;this.shieldAuraGraphics.lineStyle(n,16777215,h),this.shieldAuraGraphics.strokeEllipse(e,r,o*c,i*c)}this.shieldSparkleTimer+=t;const l=80;this.shieldSparkleTimer>=l&&(this.shieldSparkleTimer-=l,this.createShieldSparkle(e,r,o,i))}createShieldSparkle(t,e,s,o){const i=Math.random()*Math.PI*2,r=t+Math.cos(i)*(s/2),l=e+Math.sin(i)*(o/2),a=this.add.graphics();this.characterContainer.add(a);const c=this.gameBounds.height/10,h=c*.08,n=c*.2,f=c*.5,S=600+Math.random()*200,y=this.time.now,p=()=>{const C=this.time.now-y,u=Math.min(C/S,1);a.clear();const d=l-f*u,b=Math.pow(u,.5),m=h+(n-h)*b,g=1-u;g>.01&&(a.fillStyle(16768324,g*.9),a.fillRect(r-m/2,d-m/2,m,m),a.lineStyle(1,16777215,g*.6),a.strokeRect(r-m/2,d-m/2,m,m)),u>=1&&a.destroy()};p();const M=this.time.addEvent({delay:16,callback:p,callbackScope:this,repeat:Math.ceil(S/16)});this.time.delayedCall(S+50,()=>{a.active&&a.destroy(),M.remove()})}updateHpRegen(t){const e=this.skillManager.getTitaniumLiverRegenInterval();if(!(e<=0)){if(this.currentHp>=this.maxHp){this.hpRegenTimer=0;return}if(this.hpRegenTimer+=t,this.hpRegenTimer>=e){this.hpRegenTimer-=e;const s=Math.max(1,Math.floor(this.maxHp*.01));this.currentHp=Math.min(this.currentHp+s,this.maxHp),this.drawHpBarFill(),this.updateHpText(),this.updateLowHpVignette(),this.showHpHealEffect(s),console.log(`HP Regen: +${s} HP (${this.currentHp}/${this.maxHp})`)}}}showHpHealEffect(t){const e=this.characterX,s=this.characterY-this.characterSize*.3,o=Math.min(8,Math.max(3,Math.floor(t/10)+3));for(let i=0;i<o;i++)this.time.delayedCall(i*40,()=>{this.createHpHealParticle(e,s)})}createHpHealParticle(t,e){const s=Math.random()*Math.PI*2,o=this.characterSize*.4,i=this.characterSize*.25,r=t+Math.cos(s)*o*(.3+Math.random()*.7),l=e+Math.sin(s)*i*(.3+Math.random()*.7),a=this.add.graphics();this.characterContainer.add(a);const c=this.gameBounds.height/10,h=c*(.1+Math.random()*.08),n=c*(.5+Math.random()*.3),f=700+Math.random()*300,S=this.time.now,y=[6702335,8939263,7820782,10057727],p=y[Math.floor(Math.random()*y.length)],M=()=>{const u=this.time.now-S,d=Math.min(u/f,1);a.clear();const b=l-n*d;let m,g;if(d<.2?(m=.6+d*2,g=1-d*5):(m=1-(d-.2)/.8,g=0),m>.01){const w=p>>16&255,I=p>>8&255,v=p&255,T=Math.round(w+(255-w)*g),E=Math.round(I+(255-I)*g),P=Math.round(v+(255-v)*g),B=T<<16|E<<8|P;a.fillStyle(B,m*.9),a.fillRect(r-h/2,b-h/2,h,h),a.lineStyle(1,16777215,m*.7),a.strokeRect(r-h/2,b-h/2,h,h)}d>=1&&a.destroy()};M();const C=this.time.addEvent({delay:16,callback:M,callbackScope:this,repeat:Math.ceil(f/16)});this.time.delayedCall(f+50,()=>{a.active&&a.destroy(),C.remove()})}takeDamage(t,e=[]){var l;const s=this.skillManager.getSyncRateDodgeChance(this.currentLevel);if(s>0&&Math.random()<s){console.log(`Dodged! (${(s*100).toFixed(1)}% chance)`),this.flashDodgeEffect();return}let i=this.skillManager.calculateFinalDamageTaken(t),r=0;if(this.currentShield>0){const a=this.currentShield>0;if(this.currentShield>=i?(r=i,this.currentShield-=i,i=0):(r=this.currentShield,i-=this.currentShield,this.currentShield=0),a&&this.currentShield===0&&this.maxShield>0){const c=this.maxShield;this.currentHp=Math.min(this.currentHp+c,this.maxHp),console.log(`Shield broken! Healed ${c} HP, current HP: ${this.currentHp}/${this.maxHp}`),this.drawHpBarFill(),this.updateHpText(),this.updateLowHpVignette(),this.showHpHealEffect(c)}if(this.drawShieldBarFill(),r>0&&this.showGridSkillEffects&&this.flashShieldHitEffect(),this.shieldReflectDamage>0&&e.length>0){const c=e.map(n=>n.id),h=this.monsterManager.damageMonsters(c,this.shieldReflectDamage);h.totalExp>0&&this.addExp(h.totalExp),console.log(`Shield reflected ${this.shieldReflectDamage} damage to ${e.length} monsters, killed ${h.killCount}`)}}if(i>0?(this.currentHp-=i,this.currentHp<0&&(this.currentHp=0),this.hpDamageDelay=A.HP_DAMAGE_DELAY,this.drawHpBarFill(),this.updateHpText(),this.isHurt=!0,this.hurtEndTime=this.time.now+A.HURT_DURATION,this.isPointerDown=!1,this.isKeyboardMoving=!1,this.setCharacterState("hurt"),this.updateCharacterSprite(),this.flashCharacter(),this.updateLowHpVignette(),console.log(`Player took ${i} damage (${r} absorbed by shield), HP: ${this.currentHp}/${this.maxHp}`)):console.log(`Shield absorbed all ${r} damage, Shield: ${this.currentShield}`),this.currentHp<=0)if(!this.reviveUsed&&this.skillManager.hasTitaniumLiverRevive()){this.reviveUsed=!0,this.currentHp=this.maxHp,this.displayedHp=this.maxHp,console.log("【不死】觸發！復活並回滿 HP！"),this.triggerShadowExplosion(),this.drawHpBarFill(),this.updateHpText(),this.updateLowHpVignette(),this.flashReviveEffect();const a=this.skillManager.getPlayerSkill("passive_titanium_liver");(l=a==null?void 0:a.definition.maxExtraAbility)!=null&&l.triggerQuote&&this.showTriggerCutIn(a.definition,"【不死】觸發",a.definition.maxExtraAbility.triggerQuote)}else console.log("Player died!")}_flashShieldEffect(){const t=this.add.graphics();this.worldContainer.add(t);const e=this.characterX,s=this.characterY-this.characterSize/2,o=this.characterSize*1,i=16768324,r=600;let l=this.time.now;const a=()=>{const h=this.time.now-l,n=Math.min(h/r,1);t.clear();const f=.3,y=1-(n<f?0:(n-f)/(1-f));if(y>.01){for(let C=6;C>=1;C--){const u=o*C/6,d=y*(1-(C-1)/6)*.5;d>.01&&(t.fillStyle(i,d),t.fillCircle(e,s,u))}const M=o*.4;t.fillStyle(16777215,y*.8),t.fillCircle(e,s,M),t.lineStyle(5,i,y*.9),t.strokeCircle(e,s,o),t.lineStyle(2,16777215,y*.7),t.strokeCircle(e,s,o*.95)}n>=1&&t.destroy()},c=this.time.addEvent({delay:16,callback:a,callbackScope:this,repeat:Math.ceil(r/16)});this.time.delayedCall(r+50,()=>{t.active&&t.destroy(),c.remove()})}flashShieldHitEffect(){const t=this.worldToScreen(this.characterX,this.characterY),e=t.x,s=t.y,o=A.SKILL_GRID_GAP,i=this.skillGridCellSize+o,r=16763904,l=this.gameBounds.height*.2,a=400,c=200,h=this.time.now,n=[],f=Math.max(0,Math.floor((e-l)/i)),S=Math.min(this.skillGridCols-1,Math.ceil((e+l)/i)),y=Math.max(0,Math.floor((s-l)/i)),p=Math.min(this.skillGridRows-1,Math.ceil((s+l)/i));for(let d=y;d<=p;d++)for(let b=f;b<=S;b++){const m=b*i+this.skillGridCellSize/2,g=d*i+this.skillGridCellSize/2,w=m-e,I=g-s,v=Math.sqrt(w*w+I*I);v<=l&&n.push({col:b,row:d,dist:v})}if(n.length===0)return;const M=[];for(const{col:d,row:b}of n){const m=d*i+this.skillGridCellSize/2,g=b*i+this.skillGridCellSize/2,w=this.add.rectangle(m,g,this.skillGridCellSize,this.skillGridCellSize,r,0);w.setVisible(!1),this.skillGridContainer.add(w),M.push(w)}const C=()=>{const d=this.time.now-h,b=Math.min(d/a,1),m=Math.min(d/c,1),g=l*m,w=l*.3,I=Math.max(0,g-w);let v=0;d>c&&(v=(d-c)/(a-c));let T=0;for(const{dist:E}of n){const P=M[T++];if(P)if(E>=I&&E<=g){const B=(I+g)/2,G=Math.abs(E-B),R=w/2,H=G/R,_=.9*(1-H*.5)*(1-v);if(_>.01){if(d<c&&H<.3){const L=r>>16&255,Y=r>>8&255,X=r&255,V=Math.min(255,L+Math.floor((255-L)*.5)),K=Math.min(255,Y+Math.floor((255-Y)*.5)),N=Math.min(255,X+Math.floor((255-X)*.5)),D=V<<16|K<<8|N;P.setFillStyle(D,_)}else P.setFillStyle(r,_);P.setVisible(!0)}else P.setVisible(!1)}else P.setVisible(!1)}if(b>=1)for(const E of M)E.destroy()};C();const u=this.time.addEvent({delay:16,callback:C,callbackScope:this,repeat:Math.ceil(a/16)});this.time.delayedCall(a+50,()=>{u.remove();for(const d of M)d.active&&d.destroy()})}flashCharacter(){this.character.setTint(16777215),this.time.delayedCall(50,()=>{this.character.setTint(16724787)}),this.time.delayedCall(100,()=>{this.character.setTint(16777215)}),this.time.delayedCall(150,()=>{this.character.clearTint()})}flashDodgeEffect(){this.character.setTint(6737151),this.time.delayedCall(50,()=>{this.character.setTint(16777215)}),this.time.delayedCall(100,()=>{this.character.setTint(6737151)}),this.time.delayedCall(150,()=>{this.character.clearTint()})}flashReviveEffect(){const t=[6684774,2228258,8913032,4456516,11141290];let e=0;const s=()=>{e<t.length?(this.character.setTint(t[e]),e++,this.time.delayedCall(80,s)):this.character.clearTint()};s()}triggerShadowExplosion(){const e=this.gameBounds.height*.1*5,s=this.monsterManager.getMonsters(),o=[];for(const i of s){const r=i.x-this.characterX,l=i.y-this.characterY,a=Math.sqrt(r*r+l*l),c=this.gameBounds.height*i.definition.size*.5;a-c<=e&&o.push(i.id)}if(o.length>0){const i=s.filter(a=>o.includes(a.id)).map(a=>({x:a.x,y:a.y})),l=this.monsterManager.damageMonsters(o,999999);l.totalExp>0&&this.addExp(l.totalExp),this.flashShadowCrossAtPositions(i),console.log(`【暗影爆炸】秒殺 ${o.length} 隻怪物，獲得 ${l.totalExp} 經驗`)}this.drawCircleEdge(e,6684774),this.showGridSkillEffects?this.flashSkillAreaCircle(this.characterX,this.characterY,e,8913032):this.flashSkillEffectCircle(this.characterX,this.characterY,e,8913032),this.cameras.main.shake(200,.01)}_drawShadowExplosionEffect(t){const e=this.add.graphics();this.worldContainer.add(e);const s=this.characterX,o=this.characterY,i=4456516,r=800,l=this.time.now,a=()=>{const h=this.time.now-l,n=Math.min(h/r,1);e.clear();const f=t*n,S=.6*(1-n);S>.01&&(e.fillStyle(i,S),e.fillCircle(s,o,f),e.lineStyle(4,8913032,S*.8),e.strokeCircle(s,o,f)),n>=1&&e.destroy()};a();const c=this.time.addEvent({delay:16,callback:a,callbackScope:this,repeat:Math.ceil(r/16)});this.time.delayedCall(r+50,()=>{c.remove(),e.active&&e.destroy()})}flashShadowCrossAtPositions(t){t.forEach(e=>{this.flashShadowCrossAt(e.x,e.y)})}flashShadowCrossAt(t,e){const s=this.worldToScreen(t,e),o=A.SKILL_GRID_GAP,i=this.skillGridCellSize+o,r=Math.floor(s.x/i),l=Math.floor(s.y/i),a=r*i+this.skillGridCellSize/2,c=l*i+this.skillGridCellSize/2,h=5,n=500,f=this.time.now,S=Math.random()<.5?1:-1,y=(Math.PI/4+Math.random()*Math.PI/4)*S,p=[];p.push({offsetX:0,offsetY:0,dist:0});const M=[{dc:1,dr:0},{dc:-1,dr:0},{dc:0,dr:1},{dc:0,dr:-1}];for(const{dc:m,dr:g}of M)for(let w=1;w<=h;w++)p.push({offsetX:m*w*i,offsetY:g*w*i,dist:w});if(p.length===0)return;const C=8913032,u=[];for(let m=0;m<p.length;m++){const g=this.add.rectangle(a,c,this.skillGridCellSize,this.skillGridCellSize,C,0);g.setVisible(!1),this.skillGridContainer.add(g),u.push(g)}const d=()=>{const m=this.time.now-f,g=Math.min(m/n,1),w=y*g,I=Math.cos(w),v=Math.sin(w),T=h*g;for(let E=0;E<p.length;E++){const{offsetX:P,offsetY:B,dist:G}=p[E],R=u[E];if(!R)continue;const H=a+P*I-B*v,F=c+P*v+B*I;if(R.setPosition(H,F),G>=T){const L=1-G/h*.2;let Y=1;T>0&&G<T+1&&(Y=G-T);const X=L*Math.max(0,Y);X>.01?(R.setFillStyle(C,X),R.setVisible(!0)):R.setVisible(!1)}else R.setVisible(!1)}if(g>=1)for(const E of u)E.destroy()};d();const b=this.time.addEvent({delay:16,callback:d,callbackScope:this,repeat:Math.ceil(n/16)});this.time.delayedCall(n+50,()=>{b.remove();for(const m of u)m.active&&m.destroy()})}shakeScreen(t){t<10||this.cameras.main.shake(100,.005)}createLowHpVignette(){console.log(`Vignette initialized (grid: ${this.skillGridCols}x${this.skillGridRows})`)}updateLowHpVignette(){const t=this.currentHp/this.maxHp;this.isLowHp=t<=.3,!this.isLowHp&&this.currentShield<=0&&this.clearVignetteCells()}clearVignetteCells(){for(const t of this.vignetteEdgeCells){const e=Math.floor(t/this.skillGridCols),s=t%this.skillGridCols;if(e===0||e===this.skillGridRows-1||s===0||s===this.skillGridCols-1||e>=1&&e<=3)continue;const o=this.skillGridCells[t];o&&(o.setFillStyle(16777215,0),o.setVisible(!1))}this.vignetteEdgeCells.clear()}updateLowHpVignetteBreathing(t){if(!this.isLowHp&&this.currentShield<=0)return;this.lowHpBreathTimer+=t;const e=1500;this.lowHpBreathTimer>=e&&(this.lowHpBreathTimer-=e);const s=this.lowHpBreathTimer/e,o=Math.sin(s*Math.PI*2)*.5+.5;this.drawGridVignette(o)}drawGridVignette(t){const e=.2+t*.2;let s;this.currentShield>0?s=16768324:s=16720418;const o=this.skillGridCols/2,i=this.skillGridRows/2,r=this.skillGridCols/2*2,l=this.skillGridRows/2*2,a=4,c=this.skillGridRows-3;for(let h=a;h<c;h++)for(let n=1;n<this.skillGridCols-1;n++){const f=h*this.skillGridCols+n,S=this.skillGridCells[f];if(!S)continue;const y=(n-o)/r,p=(h-i)/l,M=Math.sqrt(y*y+p*p);if(M>.5){const C=Math.min(1,(M-.5)/.25),u=e*C;u>.01&&(S.setFillStyle(s,u),S.setVisible(!0),this.vignetteEdgeCells.add(f))}}}createExpBar(){this.expBarContainer=this.add.container(0,0),this.expBarContainer.setDepth(1002);const t=Math.max(A.MIN_FONT_SIZE_LARGE,Math.floor(this.gameBounds.height*.03)),e=this.skillGridCellSize,s=this.gameBounds.y+this.gameBounds.height-e*2;this.levelText=this.add.text(this.gameBounds.x+10,s-5,`Lv.${this.currentLevel}`,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${t}px`,color:"#ffffff",fontStyle:"bold",stroke:"#000000",strokeThickness:3}),this.levelText.setResolution(2),this.levelText.setOrigin(0,1),this.expBarContainer.add(this.levelText),this.timerText=this.add.text(this.gameBounds.x+this.gameBounds.width-10,s-5,"00:00",{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${t}px`,color:"#ffffff",fontStyle:"bold",stroke:"#000000",strokeThickness:3}),this.timerText.setResolution(2),this.timerText.setOrigin(1,1),this.expBarContainer.add(this.timerText),this.uiContainer.add(this.expBarContainer)}drawExpBarFill(){const t=[this.skillGridRows-3,this.skillGridRows-2],e=this.skillGridCols-2;for(const i of t)for(let r=0;r<e;r++){const l=r+1,a=i*this.skillGridCols+l,c=this.skillGridCells[a];c&&(c.setFillStyle(0,.9),c.setVisible(!0),c.setDepth(1e3))}const s=this.currentExp/this.maxExp,o=Math.floor(e*s);if(!(o<=0))for(const i of t)for(let r=0;r<o;r++){const l=r+1,a=i*this.skillGridCols+l,c=this.skillGridCells[a];if(!c)continue;const h=r/e,n=this.expBarFlowOffset,f=(h+n)%1,S=(Math.sin(f*Math.PI*2-Math.PI/2)+1)/2,y=Math.floor(68+68*S),p=Math.floor(136-68*S),C=y<<16|p<<8|255,u=i===this.skillGridRows-2?.95:.8;c.setFillStyle(C,u)}}updateExpBarFlow(t){this.expBarFlowOffset+=.2*t/1e3,this.expBarFlowOffset>=1&&(this.expBarFlowOffset-=1),this.drawExpBarFill()}drawBorderFrame(){for(let s=0;s<this.skillGridCols;s++){const o=0*this.skillGridCols+s,i=this.skillGridCells[o];i&&(i.setFillStyle(3355443,.95),i.setVisible(!0),i.setDepth(1001))}for(let s=0;s<this.skillGridCols;s++){const o=(this.skillGridRows-1)*this.skillGridCols+s,i=this.skillGridCells[o];i&&(i.setFillStyle(3355443,.95),i.setVisible(!0),i.setDepth(1001))}for(let s=1;s<this.skillGridRows-1;s++){const o=s*this.skillGridCols+0,i=this.skillGridCells[o];i&&(i.setFillStyle(3355443,.95),i.setVisible(!0),i.setDepth(1001))}for(let s=1;s<this.skillGridRows-1;s++){const o=s*this.skillGridCols+(this.skillGridCols-1),i=this.skillGridCells[o];i&&(i.setFillStyle(3355443,.95),i.setVisible(!0),i.setDepth(1001))}}drawFloorGrid(){this.floorGrid.clear();const t=this.gameBounds.height/10,e=Math.ceil(this.mapWidth/t),s=Math.ceil(this.mapHeight/t);for(let l=0;l<s;l++)for(let a=0;a<e;a++){const c=a*t,h=l*t;(l+a)%2===0?this.floorGrid.fillStyle(3355443,1):this.floorGrid.fillStyle(4473924,1),this.floorGrid.fillRect(c,h,t,t),this.floorGrid.lineStyle(1,5592405,.5),this.floorGrid.strokeRect(c,h,t,t)}this.floorGrid.lineStyle(4,16729156,1),this.floorGrid.strokeRect(0,0,this.mapWidth,this.mapHeight),this.floorGrid.lineStyle(2,16776960,1);const o=this.mapWidth/2,i=this.mapHeight/2,r=t;this.floorGrid.strokeRect(o-r/2,i-r/2,r,r);for(let l=0;l<s;l+=5)for(let a=0;a<e;a+=5){const c=a*t+t/2,h=l*t+t/2;this.floorGrid.fillStyle(6710886,1),this.floorGrid.fillCircle(c,h,4)}}createSkillBar(){const t=this.skillGridCellSize,e=A.SKILL_GRID_GAP,s=8,o=s*(t+e)-e,i=1,r=2,l=A.ACTIVE_SKILLS,a=A.PASSIVE_SKILLS,c=l*s+(l-1)*i,h=a*s+(a-1)*i,f=(c+r+h)*(t+e)-e,S=this.gameBounds.x+(this.gameBounds.width-f)/2,y=2*(t+e),p=t+e,M=this.gameBounds.y+this.gameBounds.height-y-o-p;let C=S;for(let u=0;u<l;u++){const d=C+o/2,b=M+o/2,m=this.add.container(d,b),g=this.add.rectangle(0,0,o,o);g.setStrokeStyle(0,16777215,0),g.setFillStyle(0,0),m.add(g);const w=this.add.rectangle(0,0,o-4,o-4,3355443,0);m.add(w),this.skillIconSprites.push(null);const I=Math.max(A.MIN_FONT_SIZE_SMALL,Math.floor(o*.2)),v=this.add.text(0,o*.3,"",{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${I}px`,color:"#ffffff",fontStyle:"bold",stroke:"#000000",strokeThickness:3});v.setResolution(2),v.setOrigin(.5,.5),m.add(v),this.skillIcons.push(g),this.skillIconContainers.push(m),this.skillLevelTexts.push(v),m.setDepth(1002),this.uiContainer.add(m),this.drawSkillIconGrid(C,M,s,u),C+=o+i*(t+e)}C+=(r-i)*(t+e);for(let u=0;u<a;u++){const d=C+o/2,b=M+o/2,m=this.add.container(d,b),g=this.add.rectangle(0,0,o,o);g.setStrokeStyle(0,16777215,0),g.setFillStyle(0,0),m.add(g);const w=this.add.rectangle(0,0,o-4,o-4,3355443,0);m.add(w),this.skillIconSprites.push(null);const I=Math.max(A.MIN_FONT_SIZE_SMALL,Math.floor(o*.2)),v=this.add.text(0,o*.3,"",{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${I}px`,color:"#ffffff",fontStyle:"bold",stroke:"#000000",strokeThickness:3});v.setResolution(2),v.setOrigin(.5,.5),m.add(v),this.skillIcons.push(g),this.skillIconContainers.push(m),this.skillLevelTexts.push(v),m.setDepth(1002),this.uiContainer.add(m),this.drawSkillIconGrid(C,M,s,l+u),C+=o+i*(t+e)}this.createSkillInfoPanel(),this.setupSkillIconInteractions()}drawSkillIconGrid(t,e,s,o){const i=this.add.graphics();i.setDepth(1001),this.uiContainer.add(i),this.skillIconGridData[o]={startX:t,startY:e,gridSize:s},this.redrawSkillIconGrid(o,0),this.skillIconGridGraphics[o]=i}redrawSkillIconGrid(t,e){const s=this.skillIconGridGraphics[t],o=this.skillIconGridData[t];if(!s||!o)return;s.clear();const i=this.skillGridCellSize,r=A.SKILL_GRID_GAP,{startX:l,startY:a,gridSize:c}=o,h=A.ACTIVE_SKILLS,n=t<h,f=n?this.skillManager.getPlayerActiveSkills():this.skillManager.getPlayerPassiveSkills(),S=n?t:t-h;if(!f[S]){s.fillStyle(0,.5);for(let d=0;d<c;d++)for(let b=0;b<c;b++){const m=l+b*(i+r),g=a+d*(i+r);s.fillRect(m,g,i,i)}return}const p=[],M=Math.floor(c/2);for(let d=M;d<c;d++)p.push({row:0,col:d});for(let d=1;d<c;d++)p.push({row:d,col:c-1});for(let d=c-2;d>=0;d--)p.push({row:c-1,col:d});for(let d=c-2;d>=1;d--)p.push({row:d,col:0});p.push({row:0,col:0});for(let d=1;d<M;d++)p.push({row:0,col:d});const C=p.length,u=Math.floor(C*e);for(let d=0;d<C;d++){const{row:b,col:m}=p[d],g=l+m*(i+r),w=a+b*(i+r);if(d<u){const I=this.getSkillColorForIndex(t);s.fillStyle(I,.4)}else s.fillStyle(0,.5);s.fillRect(g,w,i,i)}}getSkillColorForIndex(t){const e=A.ACTIVE_SKILLS,s=t<e,o=s?this.skillManager.getPlayerActiveSkills():this.skillManager.getPlayerPassiveSkills(),i=s?t:t-e,r=o[i];return r?r.definition.color:6710886}updateSkillCooldownDisplay(){const t=this.time.now,e=this.skillManager.getPlayerActiveSkills();for(let i=0;i<e.length;i++){const r=e[i];if(!r){this.redrawSkillIconGrid(i,0);continue}const l=r.definition;let a=l.cooldown||1e3;l.id==="active_architect"&&(a=a-r.level*500);const c=this.skillManager.calculateFinalCooldown(a),h=this.skillCooldowns.get(l.id)||0,n=t-h;if(n>=c)this.redrawSkillIconGrid(i,1);else{const f=n/c;this.redrawSkillIconGrid(i,f)}}const s=this.skillManager.getPlayerPassiveSkills(),o=A.ACTIVE_SKILLS;for(let i=0;i<s.length;i++){const r=s[i];if(!r){this.redrawSkillIconGrid(o+i,0);continue}const l=r.definition;let a=1;switch(l.id){case"passive_titanium_liver":{const c=this.skillManager.getTitaniumLiverRegenInterval();c>0&&this.currentHp<this.maxHp&&(a=this.hpRegenTimer/c);break}}this.redrawSkillIconGrid(o+i,a)}}updateTimerDisplay(){const t=Math.floor(this.gameTimer/1e3),e=Math.floor(t/60),s=t%60,o=`${e.toString().padStart(2,"0")}:${s.toString().padStart(2,"0")}`;this.timerText.setText(o)}createSkillInfoPanel(){const t=this.gameBounds,e=200,s=80,o=t.width*.05,i=t.x+o,r=t.y+t.height-s-o-60;this.skillInfoPanel=this.add.container(i,r),this.skillInfoPanel.setDepth(1003),this.skillInfoBg=this.add.rectangle(0,0,e,s,0,.7),this.skillInfoBg.setOrigin(0,0),this.skillInfoBg.setStrokeStyle(1,6710886),this.skillInfoPanel.add(this.skillInfoBg);const l=10,a=Math.max(A.MIN_FONT_SIZE_SMALL,12);this.skillInfoText=this.add.text(l,l,"",{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${a}px`,color:"#ffffff",wordWrap:{width:e-l*2}}),this.skillInfoText.setResolution(2),this.skillInfoPanel.add(this.skillInfoText),this.skillInfoPanel.setVisible(!1),this.uiContainer.add(this.skillInfoPanel)}setupSkillIconInteractions(){const t=A.ACTIVE_SKILLS;for(let e=0;e<this.skillIconContainers.length;e++){const s=this.skillIconContainers[e],o=e<t,i=o?e:e-t;s.setSize(s.getBounds().width,s.getBounds().height),s.setInteractive({useHandCursor:!0}),s.on("pointerdown",()=>{this.showSkillInfo(o,i)})}}showSkillInfo(t,e){const o=(t?this.skillManager.getPlayerActiveSkills():this.skillManager.getPlayerPassiveSkills())[e];if(!o){this.skillInfoPanel.setVisible(!1);return}const i=[];i.push(`【${o.definition.name}】${lt.formatLevel(o.level,o.definition.maxLevel)}`),t?this.appendActiveSkillInfo(i,o):this.appendPassiveSkillInfo(i,o),this.skillInfoText.setText(i.join(`
`));const r=this.skillInfoText.getBounds(),l=10;this.skillInfoBg.setSize(Math.max(180,r.width+l*2),r.height+l*2),this.skillInfoPanel.setVisible(!0),this.skillInfoHideTimer&&this.skillInfoHideTimer.destroy(),this.skillInfoHideTimer=this.time.delayedCall(3e3,()=>{this.skillInfoPanel.setVisible(!1)})}appendActiveSkillInfo(t,e){const s=e.level,o=this.skillManager.getAiEnhancementDamageBonus(),i=this.skillManager.getSyncRateCooldownReduction();switch(e.definition.id){case"active_soul_render":{const r=60+s*10,l=2+s,a=A.DAMAGE_UNIT*l,c=Math.floor(a*(1+o)),n=((e.definition.cooldown||1e3)*(1-i)/1e3).toFixed(1);t.push(`扇形角度: ${r}°`),t.push(`傷害: ${c}`),t.push(`冷卻: ${n}s`);break}case"active_coder":{const r=2+s*.5,l=1+s,a=A.DAMAGE_UNIT*l,c=Math.floor(a*(1+o)),n=((e.definition.cooldown||1500)*(1-i)/1e3).toFixed(1);t.push(`範圍: ${r} 單位`),t.push(`傷害: ${c}`),t.push(`冷卻: ${n}s`);break}case"active_vfx":{const r=s+1,l=1+s,a=A.DAMAGE_UNIT*l,c=Math.floor(a*(1+o)),n=((e.definition.cooldown||2500)*(1-i)/1e3).toFixed(1);t.push(`光束數: ${r} 道`),t.push(`傷害: ${c}`),t.push(`冷卻: ${n}s`);break}case"active_architect":{const l=Math.floor(this.maxHp*.3),a=1+s*1.5,c=A.DAMAGE_UNIT*a,n=((e.definition.cooldown||1e4)*(1-i)/1e3).toFixed(1);t.push(`護盾: ${l} (霸體)`),t.push(`反傷: ${c}`),t.push(`回血: ${l}`),t.push(`冷卻: ${n}s`);break}}this.appendMaxExtraAbility(t,e)}appendMaxExtraAbility(t,e){const s=this.skillManager.getMaxExtraAbilityText(e.definition.id,this.currentLevel);s&&(t.push(""),t.push(s))}appendPassiveSkillInfo(t,e){switch(e.definition.id){case"passive_titanium_liver":{const s=this.skillManager.getTitaniumLiverHpBonus(),o=this.skillManager.getTitaniumLiverRegenInterval()/1e3;if(t.push(`HP 加成: +${Math.round(s*100)}%`),t.push(`最大 HP: ${this.maxHp}`),t.push(`回復: 每 ${o} 秒 +1% HP`),this.skillManager.hasTitaniumLiverRevive()){const i=this.reviveUsed?"(已使用)":"(待命)";t.push(`【不死】抵銷一次死亡 ${i}`)}break}case"passive_sync_rate":{const s=this.skillManager.getSyncRateSpeedBonus(),o=this.skillManager.getSyncRateCooldownReduction();t.push(`移速加成: +${Math.round(s*100)}%`),t.push(`冷卻減少: -${Math.round(o*100)}%`);break}case"passive_retina_module":{const s=this.skillManager.getRetinaModuleExpBonus();t.push(`經驗加成: +${Math.round(s*100)}%`);break}case"passive_ai_enhancement":{const s=this.skillManager.getAiEnhancementDamageBonus(),o=this.skillManager.getAiEnhancementDefenseBonus();t.push(`攻擊加成: +${Math.round(s*100)}%`),t.push(`防禦加成: +${Math.round(o*100)}%`);break}}this.appendMaxExtraAbility(t,e)}updateSkillBarDisplay(){const t=this.skillManager.getPlayerActiveSkills(),e=this.skillManager.getPlayerPassiveSkills(),s=[...t,...e],o=this.skillGridCellSize,i=A.SKILL_GRID_GAP,l=8*(o+i)-i;for(let a=0;a<this.skillIconContainers.length;a++){const c=this.skillIconContainers[a],h=this.skillLevelTexts[a],n=s[a],f=c.list[1],S=this.skillIconSprites[a];if(n)if(f.setFillStyle(n.definition.color,.5),h.setText(lt.formatLevel(n.level,n.definition.maxLevel)),n.definition.iconPrefix){const p=n.definition.iconPrefix.startsWith("P")?`skill_icon_${n.definition.iconPrefix}`:`skill_icon_${n.definition.iconPrefix}${n.level.toString().padStart(2,"0")}`;if(this.textures.exists(p)){if(S)S.setTexture(p),S.setVisible(!0);else{const M=this.add.sprite(0,0,p);M.setOrigin(.5,.5);const u=(l-8)/Math.max(M.width,M.height);M.setScale(u),c.addAt(M,2),this.skillIconSprites[a]=M}f.setAlpha(0)}else S&&S.setVisible(!1),f.setAlpha(1)}else S&&S.setVisible(!1),f.setAlpha(1);else f.setFillStyle(3355443,0),f.setAlpha(1),h.setText(""),S&&S.setVisible(!1)}}createCharacterAnimations(){this.anims.create({key:"char_idle",frames:[{key:"char_idle_1"},{key:"char_idle_2"}],frameRate:2,repeat:-1}),this.anims.create({key:"char_run",frames:[{key:"char_run_1"},{key:"char_run_2"}],frameRate:8,repeat:-1}),this.anims.create({key:"char_attack",frames:[{key:"char_attack_1"},{key:"char_attack_2"}],frameRate:8,repeat:0}),this.anims.create({key:"char_hurt",frames:[{key:"char_hurt"}],frameRate:2,repeat:0})}updateCharacterSprite(){this.character.setPosition(this.characterX,this.characterY),this.character.setScale((this.facingRight?1:-1)*(this.characterSize/this.character.height),this.characterSize/this.character.height)}setCharacterState(t,e=!1){this.characterState!==t&&(this.isHurt&&!e&&t!=="hurt"||this.isAttacking&&!e&&t!=="hurt"||(this.characterState=t,this.character.play(`char_${t}`)))}updateCharacterFacing(t){t>this.characterX?this.facingRight=!0:t<this.characterX&&(this.facingRight=!1)}createSkillPanel(){this.skillPanelContainer=this.add.container(0,0),this.skillPanelContainer.setVisible(!1),this.uiContainer.add(this.skillPanelContainer);const t=this.add.rectangle(this.gameBounds.x+this.gameBounds.width/2,this.gameBounds.y+this.gameBounds.height/2,this.gameBounds.width,this.gameBounds.height,0,.8);t.setInteractive(),this.skillPanelContainer.add(t);const e=this.gameBounds.y+this.gameBounds.height*.12,s=this.add.text(this.gameBounds.x+this.gameBounds.width/2,e,"選擇技能",{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_LARGE,Math.floor(this.gameBounds.height*.07))}px`,color:"#ffffff",fontStyle:"bold"});s.setResolution(2),s.setOrigin(.5,.5),this.skillPanelContainer.add(s);const o=e+this.gameBounds.height*.06,i=this.add.text(this.gameBounds.x+this.gameBounds.width/2,o,"提升你的數位能力",{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_SMALL,Math.floor(this.gameBounds.height*.025))}px`,color:"#cccccc"});i.setResolution(2),i.setOrigin(.5,.5),this.skillPanelContainer.add(i),this.createSkillOptions();const r=this.gameBounds.y+this.gameBounds.height*.92,l=this.isMobile?"點兩次確認":"重複按同一鍵確認",a=this.add.text(this.gameBounds.x+this.gameBounds.width/2,r,l,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_SMALL,Math.floor(this.gameBounds.height*.022))}px`,color:"#888888"});a.setResolution(2),a.setOrigin(.5,.5),this.skillPanelContainer.add(a)}createSkillCutIn(){this.skillCutInContainer=this.add.container(0,0),this.skillCutInContainer.setVisible(!1),this.skillCutInContainer.setDepth(1e3),this.uiContainer.add(this.skillCutInContainer)}showSkillCutIn(t,e){this.skillCutInContainer.removeAll(!0);const s=this.gameBounds.height*.18,o=this.gameBounds.y+this.gameBounds.height*.25,i=this.gameBounds.width*.15,r=this.gameBounds.width-i*2,l=this.add.rectangle(this.gameBounds.x+this.gameBounds.width/2,o,r,s,0,.75);this.skillCutInContainer.add(l);const a=this.add.graphics(),c=this.gameBounds.x,h=this.gameBounds.x+i,n=20;for(let v=0;v<n;v++){const T=v/n*.75,E=c+i/n*v,P=i/n+1;a.fillStyle(0,T),a.fillRect(E,o-s/2,P,s)}this.skillCutInContainer.add(a);const f=this.add.graphics(),S=this.gameBounds.x+this.gameBounds.width-i;for(let v=0;v<n;v++){const T=(1-v/n)*.75,E=S+i/n*v,P=i/n+1;f.fillStyle(0,T),f.fillRect(E,o-s/2,P,s)}this.skillCutInContainer.add(f);const y=3,p=this.add.graphics(),M=o-s/2-y/2;for(let v=0;v<n;v++){const T=v/n*.8,E=c+i/n*v,P=i/n+1;p.fillStyle(t.color,T),p.fillRect(E,M,P,y)}p.fillStyle(t.color,.8),p.fillRect(h,M,r,y);for(let v=0;v<n;v++){const T=(1-v/n)*.8,E=S+i/n*v,P=i/n+1;p.fillStyle(t.color,T),p.fillRect(E,M,P,y)}this.skillCutInContainer.add(p);const C=this.add.graphics(),u=o+s/2-y/2;for(let v=0;v<n;v++){const T=v/n*.8,E=c+i/n*v,P=i/n+1;C.fillStyle(t.color,T),C.fillRect(E,u,P,y)}C.fillStyle(t.color,.8),C.fillRect(h,u,r,y);for(let v=0;v<n;v++){const T=(1-v/n)*.8,E=S+i/n*v,P=i/n+1;C.fillStyle(t.color,T),C.fillRect(E,u,P,y)}this.skillCutInContainer.add(C);const d=e>=t.maxLevel?"MAX":`Lv.${e}`,b=`${t.name} 提升到 ${d}`,m=this.add.text(this.gameBounds.x+this.gameBounds.width/2,o-s*.3,b,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_LARGE,Math.floor(s*.32))}px`,color:"#ffffff",fontStyle:"bold"});m.setResolution(2),m.setOrigin(.5,.5),this.skillCutInContainer.add(m);let g="";if(t.levelUpQuotes&&t.levelUpQuotes[e]&&(g=t.levelUpQuotes[e]),g){const v=this.add.text(this.gameBounds.x+this.gameBounds.width/2,o+s*.05,g,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_LARGE,Math.floor(s*.28))}px`,color:"#ffffff"});v.setResolution(2),v.setOrigin(.5,.5),this.skillCutInContainer.add(v)}let w=t.description;t.levelUpMessages&&t.levelUpMessages[e]&&(w=t.levelUpMessages[e]);const I=this.add.text(this.gameBounds.x+this.gameBounds.width/2,o+s*.25,w,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_MEDIUM,Math.floor(s*.18))}px`,color:z.Display.Color.IntegerToColor(t.color).rgba});if(I.setResolution(2),I.setOrigin(.5,.5),this.skillCutInContainer.add(I),e>=t.maxLevel&&t.maxExtraAbility){const v=t.maxExtraAbility,T=v.isPercentage?(v.perLevel*100).toFixed(2):v.perLevel.toFixed(2);let E=`【${v.name}】${v.description.replace("{value}",`角色每級 +${T}${v.unit}`)}`;const P=this.add.text(this.gameBounds.x+this.gameBounds.width/2,o+s*.42,E,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_MEDIUM,Math.floor(s*.16))}px`,color:"#ffcc00"});P.setResolution(2),P.setOrigin(.5,.5),this.skillCutInContainer.add(P)}this.skillCutInContainer.setX(-this.gameBounds.width),this.skillCutInContainer.setVisible(!0),this.skillCutInContainer.setAlpha(1),this.tweens.add({targets:this.skillCutInContainer,x:0,duration:250,ease:"Power2.easeOut",onComplete:()=>{this.time.delayedCall(2e3,()=>{this.tweens.add({targets:this.skillCutInContainer,x:this.gameBounds.width,duration:250,ease:"Power2.easeIn",onComplete:()=>{this.skillCutInContainer.setVisible(!1),this.skillCutInContainer.setX(0)}})})}})}showTriggerCutIn(t,e,s){this.skillCutInContainer.removeAll(!0);const o=this.gameBounds.height*.15,i=this.gameBounds.y+this.gameBounds.height*.25,r=this.gameBounds.width*.15,l=this.gameBounds.width-r*2,a=this.add.rectangle(this.gameBounds.x+this.gameBounds.width/2,i,l,o,0,.85);this.skillCutInContainer.add(a);const c=this.add.graphics(),h=this.gameBounds.x,n=20;for(let g=0;g<n;g++){const w=g/n*.85,I=h+r/n*g,v=r/n+1;c.fillStyle(0,w),c.fillRect(I,i-o/2,v,o)}this.skillCutInContainer.add(c);const f=this.add.graphics(),S=this.gameBounds.x+this.gameBounds.width-r;for(let g=0;g<n;g++){const w=(1-g/n)*.85,I=S+r/n*g,v=r/n+1;f.fillStyle(0,w),f.fillRect(I,i-o/2,v,o)}this.skillCutInContainer.add(f);const y=3,p=this.gameBounds.x+r,M=this.add.graphics(),C=i-o/2-y/2;for(let g=0;g<n;g++){const w=g/n*.8,I=h+r/n*g,v=r/n+1;M.fillStyle(t.color,w),M.fillRect(I,C,v,y)}M.fillStyle(t.color,.8),M.fillRect(p,C,l,y);for(let g=0;g<n;g++){const w=(1-g/n)*.8,I=S+r/n*g,v=r/n+1;M.fillStyle(t.color,w),M.fillRect(I,C,v,y)}this.skillCutInContainer.add(M);const u=this.add.graphics(),d=i+o/2-y/2;for(let g=0;g<n;g++){const w=g/n*.8,I=h+r/n*g,v=r/n+1;u.fillStyle(t.color,w),u.fillRect(I,d,v,y)}u.fillStyle(t.color,.8),u.fillRect(p,d,l,y);for(let g=0;g<n;g++){const w=(1-g/n)*.8,I=S+r/n*g,v=r/n+1;u.fillStyle(t.color,w),u.fillRect(I,d,v,y)}this.skillCutInContainer.add(u);const b=this.add.text(this.gameBounds.x+this.gameBounds.width/2,i-o*.25,e,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_LARGE,Math.floor(o*.35))}px`,color:z.Display.Color.IntegerToColor(t.color).rgba,fontStyle:"bold"});b.setResolution(2),b.setOrigin(.5,.5),this.skillCutInContainer.add(b);const m=this.add.text(this.gameBounds.x+this.gameBounds.width/2,i+o*.15,s,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_MEDIUM,Math.floor(o*.25))}px`,color:"#ffffff"});m.setResolution(2),m.setOrigin(.5,.5),this.skillCutInContainer.add(m),this.skillCutInContainer.setX(-this.gameBounds.width),this.skillCutInContainer.setVisible(!0),this.skillCutInContainer.setAlpha(1),this.tweens.add({targets:this.skillCutInContainer,x:0,duration:250,ease:"Power2.easeOut",onComplete:()=>{this.time.delayedCall(2e3,()=>{this.tweens.add({targets:this.skillCutInContainer,x:this.gameBounds.width,duration:250,ease:"Power2.easeIn",onComplete:()=>{this.skillCutInContainer.setVisible(!1),this.skillCutInContainer.setX(0)}})})}})}createSkillOptions(){if(this.skillOptions.forEach(c=>c.destroy()),this.skillOptions=[],this.skillCardBgs=[],this.currentSkillChoices=this.skillManager.getRandomSkillOptions(),this.currentSkillChoices.length===0)return;const t=this.gameBounds.width*.25,e=this.gameBounds.height*(this.isMobile?.55:.5),s=this.gameBounds.width*.05,o=this.currentSkillChoices.length,i=t*o+s*(o-1),r=this.gameBounds.x+(this.gameBounds.width-i)/2+t/2,l=this.gameBounds.y+this.gameBounds.height*.55;let a;o===1?a=["S"]:o===2?a=["A","D"]:a=["A","S","D"];for(let c=0;c<this.currentSkillChoices.length;c++){const h=this.currentSkillChoices[c],n=this.skillManager.getSkillLevel(h.id),f=n<0,S=f?"-":n,y=f?0:n+1,p=r+c*(t+s),M=this.add.container(p,l),C=this.add.rectangle(0,0,t,e,2236962);C.setStrokeStyle(2,6710886),M.add(C);const u=this.add.text(0,-e*.42,h.type==="active"?"ACTIVE":"PASSIVE",{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_SMALL,Math.floor(e*.045))}px`,color:h.type==="active"?"#ff6666":"#66ffff",fontStyle:"bold"});u.setResolution(2),u.setOrigin(.5,.5),M.add(u);const d=t*.5,b=-e*.18,m=this.add.rectangle(0,b,d,d,h.color,.3);if(m.setStrokeStyle(2,h.color),M.add(m),h.iconPrefix){const _=h.iconPrefix.startsWith("P")?`skill_icon_${h.iconPrefix}`:`skill_icon_${h.iconPrefix}${y.toString().padStart(2,"0")}`;if(this.textures.exists(_)){const L=this.add.sprite(0,b,_);L.setOrigin(.5,.5);const X=(d-8)/Math.max(L.width,L.height);L.setScale(X),M.add(L),m.setAlpha(0)}}const g=e*.06,w=this.add.text(0,g,h.name,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_MEDIUM,Math.floor(e*.08))}px`,color:"#ffffff",fontStyle:"bold"});if(w.setResolution(2),w.setOrigin(.5,.5),M.add(w),h.subtitle){const F=this.add.text(0,e*.12,h.subtitle,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_SMALL,Math.floor(e*.04))}px`,color:"#999999"});F.setResolution(2),F.setOrigin(.5,.5),M.add(F)}let I;y>=h.maxLevel?I=`Lv.${S} → MAX`:f?I=`NEW → Lv.${y}`:I=`Lv.${S} → Lv.${y}`;const v=this.add.text(0,e*.2,I,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_SMALL,Math.floor(e*.05))}px`,color:y>=h.maxLevel?"#ffff00":"#88ff88",fontStyle:"bold"});v.setResolution(2),v.setOrigin(.5,.5),M.add(v);const T=this.isMobile?0:e*.12,E=e*.5-T*.5-e*.03,P=e*.26,B=E-T*.5-P-e*.02,G=Math.max(A.MIN_FONT_SIZE_SMALL,Math.floor(e*.04)),R=this.add.text(0,P,h.description,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${G}px`,color:"#dddddd",wordWrap:{width:t*.85},align:"center"});if(R.setResolution(2),R.setOrigin(.5,0),R.height>B){const F=Math.max(A.MIN_FONT_SIZE_SMALL-2,Math.floor(G*.8));R.setStyle({fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${F}px`,color:"#dddddd",wordWrap:{width:t*.85},align:"center"})}if(M.add(R),!this.isMobile){const F=this.add.text(0,E,`[ ${a[c]} ]`,{fontFamily:'"Noto Sans TC", sans-serif',fontSize:`${Math.max(A.MIN_FONT_SIZE_MEDIUM,Math.floor(e*.06))}px`,color:"#ffff00",fontStyle:"bold"});F.setResolution(2),F.setOrigin(.5,.5),M.add(F)}C.setInteractive({useHandCursor:!0});const H=c;C.on("pointerover",()=>{this.setSelectedSkill(H)}),C.on("pointerdown",()=>{this.isMobile?this.selectedSkillIndex===H?this.confirmSkillSelection():this.setSelectedSkill(H):(this.setSelectedSkill(H),this.confirmSkillSelection())}),this.skillPanelContainer.add(M),this.skillOptions.push(M),this.skillCardBgs.push(C)}this.selectedSkillIndex=0}showSkillPanel(){if(!this.skillManager.hasUpgradeableSkills()){console.log("All skills are maxed out! Continue leveling for HP growth.");return}this.createSkillOptions(),this.currentSkillChoices.length!==0&&(this.isPaused=!0,this.isPointerDown=!1,this.skillPanelContainer.setVisible(!0),this.selectedSkillIndex=0,this.skillCardBgs.forEach((t,e)=>{e===0?(t.setFillStyle(3355443),t.setStrokeStyle(3,16777215)):(t.setFillStyle(2236962),t.setStrokeStyle(2,6710886))}),this.skillPanelContainer.setAlpha(0),this.tweens.add({targets:this.skillPanelContainer,alpha:1,duration:200}),this.skillOptions.forEach((t,e)=>{t.setScale(e===0?1.05:1),t.setY(this.gameBounds.y+this.gameBounds.height*.55+50),t.setAlpha(0),this.tweens.add({targets:t,y:this.gameBounds.y+this.gameBounds.height*.55,alpha:1,duration:300,delay:e*100,ease:"Back.easeOut"})}))}hideSkillPanel(){this.tweens.add({targets:this.skillPanelContainer,alpha:0,duration:200,onComplete:()=>{this.skillPanelContainer.setVisible(!1),this.isPaused=!1}})}selectSkill(t,e){const s=this.currentSkillChoices[t];if(!this.skillManager.learnOrUpgradeSkill(e)){console.warn(`Failed to learn/upgrade skill: ${e}`);return}const i=this.skillManager.getPlayerSkill(e),r=(i==null?void 0:i.level)??0;console.log(`Skill upgraded: ${e} -> Lv.${r}`),this.updateSkillBarDisplay(),(i==null?void 0:i.definition.type)==="passive"&&(this.recalculateMaxHp(),this.recalculateMoveSpeed(),this.drawHpBarFill(),this.updateHpText(),console.log(`Passive skill effect applied. MaxHP: ${this.maxHp}, MoveSpeed: ${this.moveSpeed}`));const l=this.skillOptions[t];this.tweens.add({targets:l,scaleX:1.1,scaleY:1.1,duration:100,yoyo:!0,onComplete:()=>{this.hideSkillPanel(),this.showSkillCutIn(s,r)}})}createSkillGrid(){const t=this.cameras.main.width,e=1920,s=20/this.gridScaleMultiplier,o=6/this.gridScaleMultiplier,i=Math.min(1,t/e);this.skillGridCellSize=Math.max(o,Math.floor(s*i));const r=A.SKILL_GRID_GAP;this.skillGridCols=Math.ceil((this.gameBounds.width+r)/(this.skillGridCellSize+r)),this.skillGridRows=Math.ceil((this.gameBounds.height+r)/(this.skillGridCellSize+r)),this.skillGridContainer=this.add.container(this.gameBounds.x,this.gameBounds.y),this.skillGridContainer.setDepth(3);for(let l=0;l<this.skillGridRows;l++)for(let a=0;a<this.skillGridCols;a++){const c=a*(this.skillGridCellSize+r)+this.skillGridCellSize/2,h=l*(this.skillGridCellSize+r)+this.skillGridCellSize/2,n=this.add.rectangle(c,h,this.skillGridCellSize,this.skillGridCellSize,16777215,0);n.setVisible(!1),this.skillGridCells.push(n),this.skillGridContainer.add(n)}this.drawBorderFrame()}recreateSkillGrid(){this.skillGridCells.forEach(t=>t.destroy()),this.skillGridCells=[],this.skillGridContainer&&this.skillGridContainer.destroy(),this.createSkillGrid(),this.recreateSkillBar(),this.bringUIToTop()}bringUIToTop(){this.characterContainer&&this.uiContainer.bringToTop(this.characterContainer),this.hpBarContainer&&this.uiContainer.bringToTop(this.hpBarContainer),this.shieldText&&this.uiContainer.bringToTop(this.shieldText),this.expBarContainer&&this.uiContainer.bringToTop(this.expBarContainer),this.skillIconContainers.forEach(t=>{this.uiContainer.bringToTop(t)}),this.skillIconGridGraphics.forEach(t=>{this.uiContainer.bringToTop(t)}),this.skillInfoPanel&&this.uiContainer.bringToTop(this.skillInfoPanel),this.skillPanelContainer&&this.uiContainer.bringToTop(this.skillPanelContainer)}recreateSkillBar(){this.skillIcons.forEach(t=>t.destroy()),this.skillIcons=[],this.skillIconContainers.forEach(t=>t.destroy()),this.skillIconContainers=[],this.skillLevelTexts.forEach(t=>t.destroy()),this.skillLevelTexts=[],this.skillIconGridGraphics.forEach(t=>t.destroy()),this.skillIconGridGraphics=[],this.skillIconGridData=[],this.skillIconSprites=[],this.skillInfoPanel&&this.skillInfoPanel.destroy(),this.createSkillBar()}initSkillEffectPool(){for(let t=0;t<A.SKILL_EFFECT_POOL_SIZE;t++){const e=this.add.sprite(0,0,A.TEXTURE_CIRCLE);e.setVisible(!1),e.setActive(!1),e.setDepth(51),this.worldContainer.add(e),this.skillEffectPool.push(e)}}getSkillEffectSprite(){let t=this.skillEffectPool.pop();return t||(t=this.add.sprite(0,0,A.TEXTURE_CIRCLE),t.setDepth(51),this.worldContainer.add(t)),t.setVisible(!0),t.setActive(!0),this.activeSkillEffects.push(t),t}releaseSkillEffectSprite(t){t.setVisible(!1),t.setActive(!1),t.setScale(1),t.setRotation(0),t.setAlpha(1),t.setTint(16777215);const e=this.activeSkillEffects.indexOf(t);e>-1&&this.activeSkillEffects.splice(e,1),this.skillEffectPool.push(t)}getSectorTextureKey(t){const e=[30,40,50,60,70,80,90,100,110,120,130,140,150,160];let s=e[0],o=Math.abs(t-s);for(const i of e){const r=Math.abs(t-i);r<o&&(o=r,s=i)}return A.TEXTURE_SECTOR_PREFIX+s}flashSkillEffectSector(t,e,s,o,i,r){const l=this.getSkillEffectSprite();if(!l)return;const a=this.getSectorTextureKey(i*2);l.setTexture(a),l.setPosition(t,e),l.setRotation(o);const c=s*2/A.EFFECT_TEXTURE_SIZE;l.setScale(c),l.setTint(r),l.setAlpha(0),this.tweens.add({targets:l,alpha:{from:0,to:.75},scale:{from:c*.5,to:c},duration:150,ease:"Quad.easeOut",onComplete:()=>{this.time.delayedCall(150,()=>{this.tweens.add({targets:l,alpha:0,scale:c*1.1,duration:200,ease:"Quad.easeIn",onComplete:()=>{this.releaseSkillEffectSprite(l)}})})}})}flashSkillEffectCircle(t,e,s,o){const i=this.getSkillEffectSprite();if(!i)return;i.setTexture(A.TEXTURE_CIRCLE),i.setPosition(t,e);const r=s*2/A.EFFECT_TEXTURE_SIZE;i.setScale(r),i.setTint(o),i.setAlpha(0),this.tweens.add({targets:i,alpha:{from:0,to:.75},scale:{from:r*.3,to:r},duration:150,ease:"Quad.easeOut",onComplete:()=>{this.time.delayedCall(150,()=>{this.tweens.add({targets:i,alpha:0,scale:r*1.2,duration:200,ease:"Quad.easeIn",onComplete:()=>{this.releaseSkillEffectSprite(i)}})})}})}flashSkillEffectLine(t,e,s,o,i,r){const l=this.getSkillEffectSprite();if(!l)return;l.setTexture(A.TEXTURE_LINE);const a=s-t,c=o-e,h=Math.sqrt(a*a+c*c),n=(t+s)/2,f=(e+o)/2,S=Math.atan2(c,a);l.setPosition(n,f),l.setRotation(S);const y=h/A.EFFECT_TEXTURE_SIZE,p=i/A.EFFECT_LINE_HEIGHT;l.setScale(y,p),l.setTint(r),l.setAlpha(0),this.tweens.add({targets:l,alpha:{from:0,to:.85},scaleY:{from:p*.5,to:p},duration:80,ease:"Quad.easeOut",onComplete:()=>{this.time.delayedCall(300,()=>{this.tweens.add({targets:l,alpha:0,scaleY:p*.2,duration:400,ease:"Quad.easeIn",onComplete:()=>{this.releaseSkillEffectSprite(l)}})})}})}flashSkillEffectSectorMoving(t,e,s,o,i,r,l){const a=this.getSkillEffectSprite();if(!a)return;const c=s*i*2,h=i*(180/Math.PI),n=this.getSectorTextureKey(h*2);a.setTexture(n),a.setPosition(t,e),a.setRotation(o);const f=s*2/A.EFFECT_TEXTURE_SIZE;a.setScale(f),a.setTint(r),a.setAlpha(.4);const S=1e3,y=this.time.now,p=()=>{const M=this.time.now-y,C=Math.min(M/S,1);if(C>=1){this.releaseSkillEffectSprite(a);return}const u=s+l*C,b=c/(2*u)*(180/Math.PI),m=this.getSectorTextureKey(b*2);a.texture.key!==m&&a.setTexture(m);const g=u*2/A.EFFECT_TEXTURE_SIZE;a.setScale(g);const w=.4*(1-C*.5);a.setAlpha(w),this.time.delayedCall(16,p)};p()}worldToScreen(t,e){return{x:t-this.cameraOffsetX,y:e-this.cameraOffsetY}}showSkillRangeCircle(t,e,s,o,i=.3){const r=this.worldToScreen(t,e),l=r.x,a=r.y,c=A.SKILL_GRID_GAP,h=this.skillGridCellSize+c,n=Math.max(0,Math.floor((l-s)/h)),f=Math.min(this.skillGridCols-1,Math.ceil((l+s)/h)),S=Math.max(0,Math.floor((a-s)/h)),y=Math.min(this.skillGridRows-1,Math.ceil((a+s)/h));for(let p=S;p<=y;p++)for(let M=n;M<=f;M++){const C=M*h+this.skillGridCellSize/2,u=p*h+this.skillGridCellSize/2,d=C-l,b=u-a;if(Math.sqrt(d*d+b*b)<=s){const g=p*this.skillGridCols+M;this.activateSkillGridCell(g,o,i)}}}showSkillRangeSector(t,e,s,o,i,r,l=.3){const a=this.worldToScreen(t,e),c=a.x,h=a.y,n=A.SKILL_GRID_GAP,f=this.skillGridCellSize+n,S=Math.max(0,Math.floor((c-s)/f)),y=Math.min(this.skillGridCols-1,Math.ceil((c+s)/f)),p=Math.max(0,Math.floor((h-s)/f)),M=Math.min(this.skillGridRows-1,Math.ceil((h+s)/f));for(let C=p;C<=M;C++)for(let u=S;u<=y;u++){const d=u*f+this.skillGridCellSize/2,b=C*f+this.skillGridCellSize/2,m=d-c,g=b-h,w=Math.sqrt(m*m+g*g);if(w<=s&&w>0){const I=Math.atan2(g,m);let v=Math.abs(I-o);if(v>Math.PI&&(v=2*Math.PI-v),v<=i){const T=C*this.skillGridCols+u;this.activateSkillGridCell(T,r,l)}}}}showSkillRangeLine(t,e,s,o,i,r,l=.3){const a=this.worldToScreen(t,e),c=this.worldToScreen(s,o),h=A.SKILL_GRID_GAP,n=this.skillGridCellSize+h,f=c.x-a.x,S=c.y-a.y,y=Math.sqrt(f*f+S*S);if(y===0)return;const p=f/y,M=S/y,C=-M,u=p,d=i/2,b=[{x:a.x+C*d,y:a.y+u*d},{x:a.x-C*d,y:a.y-u*d},{x:c.x+C*d,y:c.y+u*d},{x:c.x-C*d,y:c.y-u*d}],m=Math.min(...b.map(B=>B.x)),g=Math.max(...b.map(B=>B.x)),w=Math.min(...b.map(B=>B.y)),I=Math.max(...b.map(B=>B.y)),v=Math.max(0,Math.floor(m/n)),T=Math.min(this.skillGridCols-1,Math.ceil(g/n)),E=Math.max(0,Math.floor(w/n)),P=Math.min(this.skillGridRows-1,Math.ceil(I/n));for(let B=E;B<=P;B++)for(let G=v;G<=T;G++){const R=G*n+this.skillGridCellSize/2,H=B*n+this.skillGridCellSize/2,F=Math.max(0,Math.min(1,((R-a.x)*p+(H-a.y)*M)/y)),_=a.x+F*f,L=a.y+F*S;if(Math.sqrt((R-_)**2+(H-L)**2)<=d){const X=B*this.skillGridCols+G;this.activateSkillGridCell(X,r,l)}}}clearSkillGrid(){for(const t of this.activeSkillGridCells){if(this.vignetteEdgeCells.has(t)&&(this.isLowHp||this.currentShield>0))continue;const e=Math.floor(t/this.skillGridCols),s=t%this.skillGridCols;if(e===0||e===this.skillGridRows-1||s===0||s===this.skillGridCols-1||e>=1&&e<=3||e>=this.skillGridRows-3)continue;const o=this.skillGridCells[t];o&&o.setVisible(!1)}this.activeSkillGridCells.clear()}activateSkillGridCell(t,e,s){if(t<0||t>=this.skillGridCells.length)return;const o=this.skillGridCells[t];o&&(o.setFillStyle(e,s),o.setVisible(!0),this.activeSkillGridCells.add(t))}flashGridAt(t,e,s,o=1){const i=this.worldToScreen(t,e),r=A.SKILL_GRID_GAP,l=this.skillGridCellSize+r,a=Math.floor(i.x/l),c=Math.floor(i.y/l),h=600,n=200,f=this.time.now,S=[];for(let M=-o;M<=o;M++)for(let C=-o;C<=o;C++){const u=a+C,d=c+M;if(u<0||u>=this.skillGridCols||d<0||d>=this.skillGridRows)continue;const b=Math.sqrt(M*M+C*C);if(b<=o){const m=d*this.skillGridCols+u,g=this.skillGridCells[m];g&&S.push({cell:g,dist:b})}}if(S.length===0)return;const y=()=>{const M=this.time.now-f,C=Math.min(M/h,1);let u=0;M>n&&(u=(M-n)/(h-n));for(const{cell:d,dist:b}of S){const m=b/Math.max(o,1),w=(1-m*.4)*(1-u);if(w>.01)if(M<n){const v=(1-m)*.5;if(d.setFillStyle(s,w),d.setVisible(!0),b<o*.5){const T=s>>16&255,E=s>>8&255,P=s&255,B=Math.min(255,T+Math.floor((255-T)*v)),G=Math.min(255,E+Math.floor((255-E)*v)),R=Math.min(255,P+Math.floor((255-P)*v)),H=B<<16|G<<8|R;d.setFillStyle(H,w)}}else d.setFillStyle(s,w),d.setVisible(!0);else d.setVisible(!1)}if(C>=1)for(const{cell:d}of S)d.setVisible(!1),d.setAlpha(1)};y();const p=this.time.addEvent({delay:16,callback:y,callbackScope:this,repeat:Math.ceil(h/16)});this.time.delayedCall(h+50,()=>{p.remove();for(const{cell:M}of S)M.setVisible(!1),M.setAlpha(1)})}flashGridAtPositions(t,e,s=1){t.forEach(o=>{this.flashGridAt(o.x,o.y,e,s)})}flashWhiteCrossAt(t,e){const s=this.worldToScreen(t,e),o=A.SKILL_GRID_GAP,i=this.skillGridCellSize+o,r=Math.floor(s.x/i),l=Math.floor(s.y/i),a=r*i+this.skillGridCellSize/2,c=l*i+this.skillGridCellSize/2,h=3,n=300,f=this.time.now,S=Math.random()<.5?1:-1,y=(Math.PI/9+Math.random()*Math.PI/6)*S,p=[];p.push({offsetX:0,offsetY:0,dist:0});const M=[{dc:1,dr:0},{dc:-1,dr:0},{dc:0,dr:1},{dc:0,dr:-1}];for(const{dc:b,dr:m}of M)for(let g=1;g<=h;g++)p.push({offsetX:b*g*i,offsetY:m*g*i,dist:g});if(p.length===0)return;const C=[];for(let b=0;b<p.length;b++){const m=this.add.rectangle(a,c,this.skillGridCellSize,this.skillGridCellSize,16777215,0);m.setVisible(!1),this.skillGridContainer.add(m),C.push(m)}const u=()=>{const b=this.time.now-f,m=Math.min(b/n,1),g=y*m,w=Math.cos(g),I=Math.sin(g),v=h*m;for(let T=0;T<p.length;T++){const{offsetX:E,offsetY:P,dist:B}=p[T],G=C[T];if(!G)continue;const R=a+E*w-P*I,H=c+E*I+P*w;if(G.setPosition(R,H),B>=v){const _=1-B/h*.5;let L=1;v>0&&B<v+1&&(L=B-v);const Y=_*Math.max(0,L);Y>.01?(G.setFillStyle(16777215,Y),G.setVisible(!0)):G.setVisible(!1)}else G.setVisible(!1)}if(m>=1)for(const T of C)T.destroy()};u();const d=this.time.addEvent({delay:16,callback:u,callbackScope:this,repeat:Math.ceil(n/16)});this.time.delayedCall(n+50,()=>{d.remove();for(const b of C)b.active&&b.destroy()})}flashCritCrossAt(t,e){const s=this.worldToScreen(t,e),o=A.SKILL_GRID_GAP,i=this.skillGridCellSize+o,r=Math.floor(s.x/i),l=Math.floor(s.y/i),a=r*i+this.skillGridCellSize/2,c=l*i+this.skillGridCellSize/2,h=4,n=400,f=this.time.now,S=Math.random()<.5?1:-1,y=(Math.PI/6+Math.random()*Math.PI/6)*S,p=[];p.push({offsetX:0,offsetY:0,dist:0});const M=[{dc:1,dr:0},{dc:-1,dr:0},{dc:0,dr:1},{dc:0,dr:-1}];for(const{dc:m,dr:g}of M)for(let w=1;w<=h;w++)p.push({offsetX:m*w*i,offsetY:g*w*i,dist:w});if(p.length===0)return;const C=16746496,u=[];for(let m=0;m<p.length;m++){const g=this.add.rectangle(a,c,this.skillGridCellSize,this.skillGridCellSize,C,0);g.setVisible(!1),this.skillGridContainer.add(g),u.push(g)}const d=()=>{const m=this.time.now-f,g=Math.min(m/n,1),w=y*g,I=Math.cos(w),v=Math.sin(w),T=h*g;for(let E=0;E<p.length;E++){const{offsetX:P,offsetY:B,dist:G}=p[E],R=u[E];if(!R)continue;const H=a+P*I-B*v,F=c+P*v+B*I;if(R.setPosition(H,F),G>=T){const L=1-G/h*.3;let Y=1;T>0&&G<T+1&&(Y=G-T);const X=L*Math.max(0,Y);X>.01?(R.setFillStyle(C,X),R.setVisible(!0)):R.setVisible(!1)}else R.setVisible(!1)}if(g>=1)for(const E of u)E.destroy()};d();const b=this.time.addEvent({delay:16,callback:d,callbackScope:this,repeat:Math.ceil(n/16)});this.time.delayedCall(n+50,()=>{b.remove();for(const m of u)m.active&&m.destroy()})}flashWhiteCrossAtPositions(t){t.forEach(e=>{this.flashWhiteCrossAt(e.x,e.y)})}flashCritCrossAtPositions(t){t.forEach(e=>{this.flashCritCrossAt(e.x,e.y)})}flashDeathEffect(t,e){const s=this.worldToScreen(t,e),o=A.SKILL_GRID_GAP,i=this.skillGridCellSize+o,r=Math.floor(s.x/i),l=Math.floor(s.y/i),a=3,c=400,h=this.time.now,n=[];for(let u=0;u<a;u++){const d=Math.random()*Math.PI*2,b=2+Math.random()*2;n.push({col:r+Math.round(Math.cos(d)*b),row:l+Math.round(Math.sin(d)*b),radius:3+Math.floor(Math.random()*3)})}const f=new Map;for(const u of n){const d=u.radius;for(let b=-d;b<=d;b++)for(let m=-d;m<=d;m++){const g=Math.sqrt(b*b+m*m);if(g<=d){const w=u.col+m,I=u.row+b;if(w>=0&&w<this.skillGridCols&&I>=0&&I<this.skillGridRows){const v=`${w},${I}`,T=f.get(v);(!T||g<T.dist)&&f.set(v,{col:w,row:I,dist:g})}}}}const S=Array.from(f.values());if(S.length===0)return;const y=Math.max(...S.map(u=>u.dist)),p=[];for(const{col:u,row:d,dist:b}of S){const m=u*i+this.skillGridCellSize/2,g=d*i+this.skillGridCellSize/2,w=this.add.rectangle(m,g,this.skillGridCellSize,this.skillGridCellSize,16777215,0);w.setVisible(!1),this.skillGridContainer.add(w),p.push({rect:w,dist:b})}const M=()=>{const u=this.time.now-h,d=Math.min(u/c,1);for(const{rect:b,dist:m}of p){const g=m/(y+1),w=g+.5;let I=0;if(d>=g&&d<=w&&(d<g+.1?I=(d-g)/.1:I=1-(d-g-.1)/(w-g-.1),I=Math.max(0,Math.min(.8,I))),I>.01){const v=200+Math.floor(Math.random()*55),T=v<<16|v<<8|v;b.setFillStyle(T,I),b.setVisible(!0)}else b.setVisible(!1)}if(d>=1)for(const{rect:b}of p)b.destroy()};M();const C=this.time.addEvent({delay:16,callback:M,callbackScope:this,repeat:Math.ceil(c/16)});this.time.delayedCall(c+50,()=>{C.remove();for(const{rect:u}of p)u.active&&u.destroy()})}flashSkillAreaSector(t,e,s,o,i,r){const l=t,a=e,c=A.SKILL_GRID_GAP,h=this.skillGridCellSize+c,n=500,f=150,S=150,y=this.time.now,p=[],M=l-s,C=l+s,u=a-s,d=a+s;for(let w=u;w<=d;w+=h)for(let I=M;I<=C;I+=h){const v=Math.round(I/h)*h,T=Math.round(w/h)*h,E=v-l,P=T-a,B=Math.sqrt(E*E+P*P);if(B<=s&&B>0){const G=Math.atan2(P,E);let R=Math.abs(G-o);R>Math.PI&&(R=2*Math.PI-R),R<=i&&p.push({worldX:v,worldY:T,dist:B,angleDist:R})}}if(p.length===0)return;const b=[];for(const{worldX:w,worldY:I}of p){const v=this.add.rectangle(w,I,this.skillGridCellSize,this.skillGridCellSize,r,0);v.setVisible(!1),v.setDepth(50),this.worldContainer.add(v),b.push(v)}const m=()=>{const w=this.time.now-y,I=Math.min(w/n,1),v=Math.min(w/f,1),T=s*v;let E=0;w>f+S&&(E=(w-f-S)/(n-f-S));const P=s*E;let B=0;for(const{dist:G,angleDist:R}of p){const H=b[B++];if(H)if(G<=T&&G>=P){const F=G/s,_=R/i,X=Math.max(F,_),V=Math.max(0,Math.min(1,(X-.3)/.7)),K=V*V*(3-2*V),N=.15+K*.6;let D=1;if(P>0){const O=s*.15;G<P+O&&(D=(G-P)/O)}const $=N*D;if($>.01){const O=.5+K*.5,W=r>>16&255,U=r>>8&255,Z=r&255;let q=W,j=U,Q=Z;if(X>.85&&w<f+S){const at=(X-.85)/.15;q=Math.min(255,W+Math.floor((255-W)*at*.3)),j=Math.min(255,U+Math.floor((255-U)*at*.3)),Q=Math.min(255,Z+Math.floor((255-Z)*at*.3))}else q=Math.floor(W*O),j=Math.floor(U*O),Q=Math.floor(Z*O);const et=q<<16|j<<8|Q;H.setFillStyle(et,$),H.setVisible(!0)}else H.setVisible(!1)}else H.setVisible(!1)}if(I>=1)for(const G of b)G.destroy()};m();const g=this.time.addEvent({delay:16,callback:m,callbackScope:this,repeat:Math.ceil(n/16)});this.time.delayedCall(n+50,()=>{g.remove();for(const w of b)w.active&&w.destroy()})}flashSkillAreaCircle(t,e,s,o){const i=t,r=e,l=A.SKILL_GRID_GAP,a=this.skillGridCellSize+l,c=500,h=150,n=150,f=this.time.now,S=[],y=i-s,p=i+s,M=r-s,C=r+s;for(let m=M;m<=C;m+=a)for(let g=y;g<=p;g+=a){const w=Math.round(g/a)*a,I=Math.round(m/a)*a,v=w-i,T=I-r,E=Math.sqrt(v*v+T*T);E<=s&&S.push({worldX:w,worldY:I,dist:E})}if(S.length===0)return;const u=[];for(const{worldX:m,worldY:g}of S){const w=this.add.rectangle(m,g,this.skillGridCellSize,this.skillGridCellSize,o,0);w.setVisible(!1),w.setDepth(50),this.worldContainer.add(w),u.push(w)}const d=()=>{const m=this.time.now-f,g=Math.min(m/c,1),w=Math.min(m/h,1),I=s*w;let v=0;m>h+n&&(v=(m-h-n)/(c-h-n));const T=s*v;let E=0;for(const{dist:P}of S){const B=u[E++];if(B)if(P<=I&&P>=T){const G=P/s,R=Math.max(0,Math.min(1,(G-.3)/.7)),H=R*R*(3-2*R),F=.15+H*.6;let _=1;if(T>0){const Y=s*.15;P<T+Y&&(_=(P-T)/Y)}const L=F*_;if(L>.01){const Y=.5+H*.5,X=o>>16&255,V=o>>8&255,K=o&255;let N=X,D=V,$=K;if(G>.85&&m<h+n){const W=(G-.85)/.15;N=Math.min(255,X+Math.floor((255-X)*W*.3)),D=Math.min(255,V+Math.floor((255-V)*W*.3)),$=Math.min(255,K+Math.floor((255-K)*W*.3))}else N=Math.floor(X*Y),D=Math.floor(V*Y),$=Math.floor(K*Y);const O=N<<16|D<<8|$;B.setFillStyle(O,L),B.setVisible(!0)}else B.setVisible(!1)}else B.setVisible(!1)}if(g>=1)for(const P of u)P.destroy()};d();const b=this.time.addEvent({delay:16,callback:d,callbackScope:this,repeat:Math.ceil(c/16)});this.time.delayedCall(c+50,()=>{b.remove();for(const m of u)m.active&&m.destroy()})}flashSkillAreaLine(t,e,s,o,i,r){const l=t,a=e,c=s,h=o,n=A.SKILL_GRID_GAP,f=this.skillGridCellSize+n,S=c-l,y=h-a,p=Math.sqrt(S*S+y*y);if(p===0)return;const M=S/p,C=y/p,u=-C,d=M,b=i/2,m=800,g=80,w=300,I=m-g-w,v=this.time.now,T=[],E=[{x:l+u*b,y:a+d*b},{x:l-u*b,y:a-d*b},{x:c+u*b,y:h+d*b},{x:c-u*b,y:h-d*b}],P=Math.min(...E.map(L=>L.x)),B=Math.max(...E.map(L=>L.x)),G=Math.min(...E.map(L=>L.y)),R=Math.max(...E.map(L=>L.y));for(let L=G;L<=R;L+=f)for(let Y=P;Y<=B;Y+=f){const X=Math.round(Y/f)*f,V=Math.round(L/f)*f,K=X-l,N=V-a,D=K*M+N*C;if(D<0||D>p)continue;const $=l+M*D,O=a+C*D,W=Math.sqrt((X-$)**2+(V-O)**2);W<=b&&T.push({worldX:X,worldY:V,distAlong:D,distToLine:W})}if(T.length===0)return;const H=[];for(const{worldX:L,worldY:Y}of T){const X=this.add.rectangle(L,Y,this.skillGridCellSize,this.skillGridCellSize,r,0);X.setVisible(!1),X.setDepth(50),this.worldContainer.add(X),H.push(X)}const F=()=>{const L=this.time.now-v,Y=Math.min(L/m,1),X=Math.min(L/g,1),V=p*X;let K=0;L>g+w&&(K=(L-g-w)/I);const N=p*K,D=1-K;let $=0;for(const{distAlong:O,distToLine:W}of T){const U=H[$++];if(!U)continue;const Z=b*D;if(O<=V&&O>=N&&W<=Z){const q=Z>0?W/Z:1,j=1-q*q;let Q=.2+j*.5;const et=O/p,at=Math.min(1,et/.15),gt=Math.min(1,(1-et)/.15),rt=Math.min(at,gt);Q*=rt*rt;let ht=1;if(N>0){const it=p*.1;O<N+it&&(ht=(O-N)/it)}const ct=Q*ht;if(ct>.01){const it=.6+j*.4,pt=r>>16&255,ut=r>>8&255,mt=r&255;let St,Mt,Ct;if(q<.2&&L<g+w){const xt=1-q/.2;St=Math.min(255,pt+Math.floor((255-pt)*xt*.3)),Mt=Math.min(255,ut+Math.floor((255-ut)*xt*.3)),Ct=Math.min(255,mt+Math.floor((255-mt)*xt*.3))}else St=Math.floor(pt*it),Mt=Math.floor(ut*it),Ct=Math.floor(mt*it);const Tt=St<<16|Mt<<8|Ct;U.setFillStyle(Tt,ct),U.setVisible(!0)}else U.setVisible(!1)}else U.setVisible(!1)}if(Y>=1)for(const O of H)O.destroy()};F();const _=this.time.addEvent({delay:16,callback:F,callbackScope:this,repeat:Math.ceil(m/16)});this.time.delayedCall(m+50,()=>{_.remove();for(const L of H)L.active&&L.destroy()})}};k(A,"MAP_SCALE",10),k(A,"ACTIVE_SKILLS",4),k(A,"PASSIVE_SKILLS",3),k(A,"CAMERA_DEAD_ZONE",.3),k(A,"HP_DAMAGE_DELAY",1e3),k(A,"HP_DAMAGE_LERP_SPEED",3),k(A,"MIN_FONT_SIZE_LARGE",14),k(A,"MIN_FONT_SIZE_MEDIUM",12),k(A,"MIN_FONT_SIZE_SMALL",10),k(A,"BASE_HP",200),k(A,"HP_PER_LEVEL",50),k(A,"BASE_EXP",100),k(A,"EXP_GROWTH_RATE",1.2),k(A,"DAMAGE_UNIT",10),k(A,"HURT_DURATION",200),k(A,"ATTACK_DURATION",150),k(A,"SKILL_GRID_GAP",1),k(A,"SKILL_EFFECT_POOL_SIZE",50),k(A,"TEXTURE_SECTOR_PREFIX","effect_sector_"),k(A,"TEXTURE_CIRCLE","effect_circle"),k(A,"TEXTURE_LINE","effect_line"),k(A,"EFFECT_TEXTURE_SIZE",256),k(A,"EFFECT_LINE_HEIGHT",64);let yt=A;const Bt=7,Gt={0:{width:5,pixels:[" ### ","#   #","#  ##","# # #","##  #","#   #"," ### "]},1:{width:3,pixels:[" # ","## "," # "," # "," # "," # ","###"]},2:{width:5,pixels:[" ### ","#   #","    #","  ## "," #   ","#    ","#####"]},3:{width:5,pixels:[" ### ","#   #","    #","  ## ","    #","#   #"," ### "]},4:{width:5,pixels:["#   #","#   #","#   #","#####","    #","    #","    #"]},5:{width:5,pixels:["#####","#    ","#    ","#### ","    #","#   #"," ### "]},6:{width:5,pixels:[" ### ","#    ","#    ","#### ","#   #","#   #"," ### "]},7:{width:5,pixels:["#####","    #","   # ","  #  ","  #  ","  #  ","  #  "]},8:{width:5,pixels:[" ### ","#   #","#   #"," ### ","#   #","#   #"," ### "]},9:{width:5,pixels:[" ### ","#   #","#   #"," ####","    #","    #"," ### "]},A:{width:5,pixels:[" ### ","#   #","#   #","#####","#   #","#   #","#   #"]},D:{width:5,pixels:["#### ","#   #","#   #","#   #","#   #","#   #","#### "]},E:{width:4,pixels:["####","#   ","#   ","### ","#   ","#   ","####"]},G:{width:5,pixels:[" ### ","#    ","#    ","# ###","#   #","#   #"," ### "]},I:{width:3,pixels:["###"," # "," # "," # "," # "," # ","###"]},L:{width:4,pixels:["#   ","#   ","#   ","#   ","#   ","#   ","####"]},N:{width:5,pixels:["#   #","##  #","# # #","#  ##","#   #","#   #","#   #"]},O:{width:5,pixels:[" ### ","#   #","#   #","#   #","#   #","#   #"," ### "]},P:{width:4,pixels:["### ","#  #","#  #","### ","#   ","#   ","#   "]},R:{width:4,pixels:["### ","#  #","#  #","### ","# # ","#  #","#  #"]},S:{width:4,pixels:[" ###","#   ","#   "," ## ","   #","   #","### "]},T:{width:5,pixels:["#####","  #  ","  #  ","  #  ","  #  ","  #  ","  #  "]},"%":{width:5,pixels:["##  #","## # ","  #  "," #   "," # ##","#  ##","   ##"]}," ":{width:3,pixels:["   ","   ","   ","   ","   ","   ","   "]}},Rt={charHeight:Bt,chars:Gt};class Lt{constructor(){k(this,"font");this.font=Rt}textToPixels(x,t,e){const s=[],o=x.letterSpacing??1,i=x.color.replace("#",""),r=parseInt(i.substring(0,2),16),l=parseInt(i.substring(2,4),16),a=parseInt(i.substring(4,6),16),c=r<<16|l<<8|a;let h=0;const n=x.text.toUpperCase().split("");for(let C=0;C<n.length;C++){const u=this.font.chars[n[C]];u&&(h+=u.width,C<n.length-1&&(h+=o))}const f=Math.floor(t*x.position.x),S=Math.floor(e*x.position.y),y=f-Math.floor(h/2),p=S-Math.floor(this.font.charHeight/2);let M=y;for(const C of n){const u=this.font.chars[C];if(u){for(let d=0;d<u.pixels.length;d++){const b=u.pixels[d];for(let m=0;m<b.length;m++)if(b[m]==="#"){const g=M+m,w=p+d;g>=0&&g<t&&w>=0&&w<e&&s.push({gridX:g,gridY:w,color:c})}}M+=u.width+o}}return s}processConfig(x,t,e){const s=new Map;for(const o of x.texts){const i=this.textToPixels(o,t,e);s.set(o.id,i)}return s}}const Ht=[{id:"title",text:"PRESS TO START",letterSpacing:2,position:{x:.5,y:.5},color:"#ffffff"}],Ft={texts:Ht},ot=class ot extends z.Scene{constructor(){super("GridScene");k(this,"cells",[]);k(this,"cols",0);k(this,"rows",0);k(this,"cellWidth",10);k(this,"cellHeight",10);k(this,"gap",1);k(this,"isAnimating",!1);k(this,"isReady",!1);k(this,"textRenderer");k(this,"textPixels",new Map);k(this,"cursorGlowRadius",4);k(this,"glowPhase",0);k(this,"textBreathPhase",0);k(this,"isLoading",!0);k(this,"loadingCells",new Set);k(this,"backgroundImage");k(this,"titleBgm");this.textRenderer=new Lt}preload(){this.load.image("background","background.png"),this.load.image("char_idle_1","sprites/character/IDEL01.png"),this.load.image("char_idle_2","sprites/character/IDEL02.png"),this.load.image("char_run_1","sprites/character/RUN01.png"),this.load.image("char_run_2","sprites/character/RUN02.png"),this.load.image("char_attack_1","sprites/character/ATTACK01.png"),this.load.image("char_attack_2","sprites/character/ATTACK02.png"),this.load.image("char_hurt","sprites/character/HURT01.png"),this.load.audio("bgm_title","audio/BGM00.mp3"),this.load.audio("bgm_game_01","audio/BGM01.mp3"),this.load.audio("bgm_game_02","audio/BGM02.mp3"),this.load.image("effect_circle","effects/circle.png"),this.load.image("effect_line","effects/line.png");const t=[30,40,50,60,70,80,90,100,110,120,130,140,150,160];for(const s of t)this.load.image(`effect_sector_${s}`,`effects/sector_${s}.png`);const e=["A","B","C"];for(const s of e)for(let o=0;o<=5;o++)this.load.image(`skill_icon_${s}${o.toString().padStart(2,"0")}`,`icons/skills/${s}${o.toString().padStart(2,"0")}.png`);for(let s=1;s<=4;s++)this.load.image(`skill_icon_P${s.toString().padStart(2,"0")}`,`icons/skills/P${s.toString().padStart(2,"0")}.png`);this.load.on("progress",s=>{this.updateLoadingProgress(Math.floor(s*100))})}create(){this.cameras.main.setBackgroundColor("rgba(0,0,0,0)"),this.createBackground(),this.calculateGridSize(),this.createGrid(),this.showLoadingText(0),this.startEntryAnimation(),this.preloadGameAssets(),this.input.on("pointerdown",t=>{if(!this.isReady||this.isAnimating)return;const e=Math.floor(t.x/(this.cellWidth+this.gap)),s=Math.floor(t.y/(this.cellHeight+this.gap));this.startExitAnimation(e,s)}),this.input.on("pointermove",t=>{!this.isReady||this.isAnimating||this.updateCursorGlow(t.x,t.y)})}update(t,e){if(!this.isReady||this.isAnimating)return;this.glowPhase+=e*.002,this.textBreathPhase+=e*.004;const s=this.input.activePointer;s&&this.updateCursorGlow(s.x,s.y),this.updateTextBreath()}updateTextBreath(){const t=.5+.5*Math.sin(this.textBreathPhase),e=Math.floor(204+51*t),s=e<<16|e<<8|e,o=.5+.5*Math.sin(this.textBreathPhase*3),i=t>.6?o*.8:0,r=new Set;this.cells.forEach(l=>{l.isText&&r.add(`${l.x},${l.y}`)}),this.cells.forEach(l=>{if(l.isText)l.graphics.setFillStyle(s),l.graphics.setAlpha(.95);else{const a=`${l.x-1},${l.y-1}`;r.has(a)&&i>0&&(l.graphics.setFillStyle(8939263),l.graphics.setAlpha(i))}})}updateCursorGlow(t,e){const s=Math.floor(t/(this.cellWidth+this.gap)),o=Math.floor(e/(this.cellHeight+this.gap)),i=.3+.7*(.5+.5*Math.sin(this.glowPhase));this.cells.forEach(r=>{const l=r.x-s,a=r.y-o,c=Math.sqrt(l*l+a*a);if(c<=this.cursorGlowRadius){const n=(1-c/this.cursorGlowRadius)*i,f=r.originalColor>>16&255,S=r.originalColor>>8&255,y=r.originalColor&255,p=Math.min(255,Math.floor(f+(255-f)*n)),M=Math.min(255,Math.floor(S+(255-S)*n)),C=Math.min(255,Math.floor(y+(255-y)*n)),u=p<<16|M<<8|C;r.graphics.setFillStyle(u)}else r.graphics.setFillStyle(r.originalColor)})}createBackground(){const t=this.cameras.main.width,e=this.cameras.main.height;this.backgroundImage=this.add.image(t/2,e/2,"background");const s=t/this.backgroundImage.width,o=e/this.backgroundImage.height,i=Math.max(s,o);this.backgroundImage.setScale(i),this.backgroundImage.setDepth(-1)}showLoadingText(t){this.loadingCells.forEach(o=>{this.cells[o]&&(this.cells[o].originalColor=2236962,this.cells[o].isText=!1,this.cells[o].graphics.setFillStyle(2236962),this.cells[o].graphics.setAlpha(.2))}),this.loadingCells.clear();const e=`LOADING ${t}%`;this.textRenderer.textToPixels({id:"loading",text:e,letterSpacing:2,position:{x:.5,y:.5},color:"#ffffff"},this.cols,this.rows).forEach(o=>{const i=o.gridY*this.cols+o.gridX;this.cells[i]&&(this.cells[i].originalColor=o.color,this.cells[i].isText=!0,this.cells[i].graphics.setFillStyle(o.color),this.cells[i].graphics.setAlpha(.95),this.loadingCells.add(i))})}updateLoadingProgress(t){this.isLoading&&this.showLoadingText(t)}preloadGameAssets(){let t=0;const e=this.time.addEvent({delay:50,callback:()=>{t+=Math.random()*15,t>=100&&(t=100,e.destroy(),this.onLoadingComplete()),this.showLoadingText(Math.floor(t))},loop:!0})}onLoadingComplete(){this.isLoading=!1,this.time.delayedCall(500,()=>{this.cells.forEach(t=>{t.originalColor=2236962,t.isText=!1,t.graphics.setFillStyle(2236962),t.graphics.setAlpha(.2)}),this.loadingCells.clear(),this.time.delayedCall(300,()=>{this.processTextConfig(),this.textPixels.forEach(t=>{t.forEach(e=>{const s=e.gridY*this.cols+e.gridX;this.cells[s]&&(this.cells[s].graphics.setFillStyle(e.color),this.cells[s].graphics.setAlpha(.95))})}),this.isAnimating||(this.isReady=!0),this.cache.audio.exists("bgm_title")&&(this.titleBgm=this.sound.add("bgm_title",{volume:.5,loop:!0}),this.titleBgm.play())})})}calculateGridSize(){const t=this.cameras.main.width,e=this.cameras.main.height,s=Math.min(1,t/ot.BASE_WIDTH),o=Math.max(ot.MIN_CELL_SIZE,Math.floor(ot.BASE_CELL_SIZE*s));this.gap=1,this.cellWidth=o,this.cellHeight=o,this.cols=Math.ceil((t+this.gap)/(o+this.gap)),this.rows=Math.ceil((e+this.gap)/(o+this.gap));const i=.05,r=t*(1-i*2),l=e*(1-i*2),a=16/9,c=r/l;let h,n;c>a?(n=l,h=l*a):(h=r,n=r/a);const f=(t-h)/2,S=(e-n)/2;this.registry.set("gameBounds",{x:f,y:S,width:h,height:n}),console.log(`Grid: ${this.cols}x${this.rows}, cellSize: ${o}, gameBounds: ${h.toFixed(0)}x${n.toFixed(0)}`)}createGrid(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.cols;e++){const s=e*(this.cellWidth+this.gap)+this.cellWidth/2,o=t*(this.cellHeight+this.gap)+this.cellHeight/2,i=this.add.rectangle(s,o,this.cellWidth,this.cellHeight,2236962);i.setAlpha(0),this.cells.push({x:e,y:t,graphics:i,delay:0,originalColor:2236962,isText:!1})}}processTextConfig(){this.textPixels=this.textRenderer.processConfig(Ft,this.cols,this.rows),this.textPixels.forEach(t=>{t.forEach(e=>{const s=e.gridY*this.cols+e.gridX;this.cells[s]&&(this.cells[s].originalColor=e.color,this.cells[s].isText=!0)})})}startEntryAnimation(){this.isAnimating=!0;const t=new Set;for(let p=0;p<this.cells.length;p++)t.add(p);const e=20,s=50,o=10,r=Math.floor(200/o),l=3e3;let a=0,c=!1;const h=(p,M)=>M*this.cols+p,n=p=>({x:p%this.cols,y:Math.floor(p/this.cols)}),f=p=>{const M=this.cells[p];M.graphics.setAlpha(1),M.graphics.setFillStyle(16777215),this.tweens.add({targets:M.graphics,fillColor:{from:16777215,to:M.originalColor},alpha:{from:1,to:.2},duration:80,ease:"Linear"})},S=p=>{const{x:M,y:C}=n(p),u=r,d=[];for(let g=0;g<=u;g++)d[g]=[];for(let g=-u;g<=u;g++)for(let w=-u;w<=u;w++){const I=M+w,v=C+g;if(I>=0&&I<this.cols&&v>=0&&v<this.rows){const T=Math.sqrt(w*w+g*g),E=Math.floor(T);if(E<=u){const P=h(I,v);d[E].push(P)}}}let b=0;const m=()=>{b>u||(d[b].forEach(g=>{t.has(g)&&(t.delete(g),f(g))}),b++,b<=u&&this.time.delayedCall(o,m))};m()},y=()=>{if(c)return;if(a>=l||t.size===0){this.finishEntry(t),c=!0;return}const p=Array.from(t),M=Math.min(e,p.length);for(let C=0;C<M&&p.length!==0;C++){const u=Math.floor(Math.random()*p.length),d=p[u];p.splice(u,1),t.has(d)&&S(d)}a+=s,t.size>0&&a<l?this.time.delayedCall(s,y):c||(this.finishEntry(t),c=!0)};y()}finishEntry(t){t.forEach(e=>{const s=this.cells[e];s.graphics.setAlpha(.2),s.graphics.setFillStyle(s.originalColor)}),this.time.delayedCall(100,()=>{this.isAnimating=!1,this.isLoading||(this.isReady=!0)})}startExitAnimation(t,e){this.isAnimating=!0,this.titleBgm&&this.titleBgm.isPlaying&&this.titleBgm.stop();const s=this.cameras.main.width,o=this.cameras.main.height;this.scene.launch("MainScene"),this.scene.bringToTop("GridScene");const i=t*(this.cellWidth+this.gap)+this.cellWidth/2,r=e*(this.cellHeight+this.gap)+this.cellHeight/2;this.registry.events.emit("reveal-update",{x:i,y:r,radius:0}),this.cells.forEach(n=>{n.graphics.setFillStyle(0),n.graphics.setAlpha(1)}),this.backgroundImage.setVisible(!1);const l=5;let a=0;this.cells.forEach(n=>{const f=n.x-t,S=n.y-e,y=Math.sqrt(f*f+S*S);n.delay=Math.floor(y*l),n.delay>a&&(a=n.delay)});const c=Math.sqrt(Math.max(i,s-i)**2+Math.max(r,o-r)**2)+50,h=a+150;this.tweens.addCounter({from:0,to:c,duration:h,ease:"Linear",onUpdate:n=>{const f=n.getValue()??0;this.registry.events.emit("reveal-update",{x:i,y:r,radius:f})}}),this.cells.forEach(n=>{this.time.delayedCall(n.delay,()=>{n.graphics.setFillStyle(16777215),n.graphics.setAlpha(1),this.tweens.addCounter({from:0,to:100,duration:200,ease:"Linear",onUpdate:f=>{const S=f.getValue()??0;let y,p;S<15?(y=16777215,p=1):S<30?(y=16776960,p=1):S<50?(y=16746496,p=1):S<70?(y=16720384,p=1-(S-50)/50):(y=6684672,p=1-(S-50)/50),n.graphics.setFillStyle(y),n.graphics.setAlpha(Math.max(0,p))},onComplete:()=>{n.graphics.setVisible(!1)}})})}),this.time.delayedCall(a+200,()=>{this.registry.events.emit("reveal-complete"),this.scene.stop("GridScene")})}};k(ot,"BASE_CELL_SIZE",10),k(ot,"MIN_CELL_SIZE",4),k(ot,"BASE_WIDTH",1920);let wt=ot;const Et=document.getElementById("version-info");Et&&(Et.textContent="v0.6.0");let J=null;function Dt(){return window.innerWidth>window.innerHeight}function vt(){return window.visualViewport?window.visualViewport.height:window.innerHeight}function _t(){if(J)return;const tt={type:z.AUTO,width:window.innerWidth,height:vt(),parent:"app",backgroundColor:"#111111",pixelArt:!0,scale:{mode:z.Scale.RESIZE,autoCenter:z.Scale.CENTER_BOTH},physics:{default:"arcade",arcade:{gravity:{x:0,y:0},debug:!1}},scene:[wt,At,yt]};J=new z.Game(tt),J.events.once("ready",()=>{J&&J.sound&&(J.sound.volume=.5)})}function bt(){(window.innerWidth>900||Dt())&&_t()}bt();window.addEventListener("resize",bt);window.addEventListener("orientationchange",()=>{setTimeout(bt,100)});window.visualViewport&&window.visualViewport.addEventListener("resize",()=>{J&&J.scale.resize(window.innerWidth,vt())});document.addEventListener("fullscreenchange",()=>{J&&setTimeout(()=>{J.scale.resize(window.innerWidth,vt())},100)});window.addEventListener("volumechange",tt=>{J&&J.sound&&(J.sound.volume=tt.detail.volume)});
