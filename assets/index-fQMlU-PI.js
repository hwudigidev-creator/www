var At=Object.defineProperty;var It=(J,m,t)=>m in J?At(J,m,{enumerable:!0,configurable:!0,writable:!0,value:t}):J[m]=t;var k=(J,m,t)=>It(J,typeof m!="symbol"?m+"":m,t);import{P as _}from"./phaser-0RJB29YE.js";(function(){const m=document.createElement("link").relList;if(m&&m.supports&&m.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))e(i);new MutationObserver(i=>{for(const a of i)if(a.type==="childList")for(const s of a.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&e(s)}).observe(document,{childList:!0,subtree:!0});function t(i){const a={};return i.integrity&&(a.integrity=i.integrity),i.referrerPolicy&&(a.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?a.credentials="include":i.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function e(i){if(i.ep)return;i.ep=!0;const a=t(i);fetch(i.href,a)}})();class Bt extends _.Scene{constructor(){super("BootScene")}preload(){}create(){this.scene.start("MainScene")}}const dt=[{id:"active_soul_render",name:"靈魂渲染",subtitle:"動畫大師",description:"朝最近敵人發射 3 單位扇形攻擊，每級擴大 10°",type:"active",color:6724095,flashColor:6737151,cooldown:1e3,maxLevel:5,levelUpMessages:["60° 扇形、2 傷害","70° 扇形、3 傷害","80° 扇形、4 傷害","90° 扇形、5 傷害","100° 扇形、6 傷害","110° 扇形、7 傷害，已達最大等級！"],maxExtraAbility:{name:"穿透",description:"攻擊後 {value} 機率發射扇形波",baseValue:0,perLevel:.004,unit:"%",isPercentage:!0}},{id:"active_coder",name:"遊戲先知",subtitle:"編碼者",description:"對周圍 2 單位敵人造成傷害，每級增加 0.5 單位範圍",type:"active",color:11167487,flashColor:13404415,cooldown:1500,maxLevel:5,levelUpMessages:["2 單位範圍、1 傷害","2.5 單位範圍、2 傷害","3 單位範圍、3 傷害","3.5 單位範圍、4 傷害","4 單位範圍、5 傷害","4.5 單位範圍、6 傷害，已達最大等級！"],maxExtraAbility:{name:"爆發",description:"擊殺時 {value} 機率再發動",baseValue:0,perLevel:.002,unit:"%",isPercentage:!0}},{id:"active_vfx",name:"超級導演",subtitle:"視效師",description:"朝隨機敵人發射 10 單位貫穿光束，每級增加 1 道",type:"active",color:6750054,flashColor:8978312,cooldown:2500,maxLevel:5,levelUpMessages:["1 道光束、1 傷害","2 道光束、2 傷害","3 道光束、3 傷害","4 道光束、4 傷害","5 道光束、5 傷害","6 道光束、6 傷害，已達最大等級！"],maxExtraAbility:{name:"連鎖",description:"擊殺時 {value} 機率再發射",baseValue:0,perLevel:.002,unit:"%",isPercentage:!0}},{id:"active_architect",name:"靈魂統領",subtitle:"架構師",description:"產生 30% HP 護盾（霸體）並反傷攻擊者，護盾消失時回復等值 HP",type:"active",color:16763904,flashColor:16768324,cooldown:1e4,maxLevel:5,levelUpMessages:["30% HP 護盾、1 反傷","30% HP 護盾、2.5 反傷","30% HP 護盾、4 反傷","30% HP 護盾、5.5 反傷","30% HP 護盾、7 反傷","30% HP 護盾、8.5 反傷，已達最大等級！"],maxExtraAbility:{name:"堅守",description:"護盾覆蓋時 {value} 機率炸開",baseValue:0,perLevel:.01,unit:"%",isPercentage:!0}},{id:"passive_titanium_liver",name:"鈦金肝",description:"提升 10% HP 總量並每 15 秒回復 1% 最大 HP，每級再 +10% HP、回復間隔 -1 秒",type:"passive",color:11189196,maxLevel:5,levelUpMessages:["+10% HP、每 15 秒回血","+20% HP、每 14 秒回血","+30% HP、每 13 秒回血","+40% HP、每 12 秒回血","+50% HP、每 11 秒回血","+60% HP、每 10 秒回血，已達最大等級！"],maxExtraAbility:{name:"再生",description:"回復量 +{value}",baseValue:0,perLevel:.001,unit:"%",isPercentage:!0}},{id:"passive_sync_rate",name:"精神同步率強化",description:"提升 10% 移速、減少 8% 冷卻，每級再疊加",type:"passive",color:14518340,maxLevel:5,levelUpMessages:["+10% 移速、-8% 冷卻","+20% 移速、-16% 冷卻","+30% 移速、-24% 冷卻","+40% 移速、-32% 冷卻","+50% 移速、-40% 冷卻","+60% 移速、-48% 冷卻，已達最大等級！"],maxExtraAbility:{name:"迅捷",description:"閃避機率 +{value}",baseValue:0,perLevel:.001,unit:"%",isPercentage:!0}},{id:"passive_retina_module",name:"視網膜增強模組",description:"提升 30% 經驗取得，每級再 +30%",type:"passive",color:10035763,maxLevel:5,levelUpMessages:["+30% 經驗","+60% 經驗","+90% 經驗","+120% 經驗","+150% 經驗","+180% 經驗，已達最大等級！"],maxExtraAbility:{name:"洞察",description:"暴擊率 +{value}",baseValue:0,perLevel:.001,unit:"%",isPercentage:!0}},{id:"passive_ai_enhancement",name:"AI賦能強化",description:"提升 25% 攻擊、15% 防禦，每級再疊加",type:"passive",color:6719658,maxLevel:5,levelUpMessages:["+25% 攻擊、+15% 防禦","+50% 攻擊、+30% 防禦","+75% 攻擊、+45% 防禦","+100% 攻擊、+60% 防禦","+125% 攻擊、+75% 防禦","+150% 攻擊、+90% 防禦，已達最大等級！"],maxExtraAbility:{name:"超載",description:"暴擊傷害 +{value}",baseValue:0,perLevel:.002,unit:"%",isPercentage:!0}}],rt=class rt{constructor(){k(this,"playerSkills",new Map)}getActiveSkillDefinitions(){return dt.filter(m=>m.type==="active")}getPassiveSkillDefinitions(){return dt.filter(m=>m.type==="passive")}getPlayerSkill(m){return this.playerSkills.get(m)}getPlayerActiveSkills(){const m=[];this.playerSkills.forEach(e=>{e.definition.type==="active"&&m.push(e)});const t=[];for(let e=0;e<4;e++)t.push(m[e]||null);return t}getPlayerPassiveSkills(){const m=[];this.playerSkills.forEach(e=>{e.definition.type==="passive"&&m.push(e)});const t=[];for(let e=0;e<rt.MAX_PASSIVE_SLOTS;e++)t.push(m[e]||null);return t}getOwnedPassiveCount(){let m=0;return this.playerSkills.forEach(t=>{t.definition.type==="passive"&&m++}),m}isPassiveSlotsFull(){return this.getOwnedPassiveCount()>=rt.MAX_PASSIVE_SLOTS}getSkillLevel(m){const t=this.playerSkills.get(m);return t?t.level:-1}isSkillMaxLevel(m){const t=this.playerSkills.get(m);return t?t.level>=t.definition.maxLevel:!1}learnOrUpgradeSkill(m){const t=dt.find(i=>i.id===m);if(!t)return!1;const e=this.playerSkills.get(m);if(e){if(e.level>=t.maxLevel)return!1;e.level++}else this.playerSkills.set(m,{definition:t,level:0});return!0}getUpgradeableActiveSkills(){return this.getActiveSkillDefinitions().filter(m=>{const t=this.playerSkills.get(m.id);return!t||t.level<m.maxLevel})}getUpgradeablePassiveSkills(){const m=this.isPassiveSlotsFull();return this.getPassiveSkillDefinitions().filter(t=>{const e=this.playerSkills.get(t.id);return m?e&&e.level<t.maxLevel:!e||e.level<t.maxLevel})}hasAnyActiveSkill(){return this.getActiveSkillDefinitions().some(t=>this.playerSkills.has(t.id))}getRandomSkillOptions(){const m=this.getUpgradeableActiveSkills(),t=this.getUpgradeablePassiveSkills(),e=[];if(!this.hasAnyActiveSkill()){const s=this.shuffleArray([...m]);for(let n=0;n<Math.min(3,s.length);n++)e.push(s[n]);return e}const i=this.shuffleArray([...m]);for(let s=0;s<Math.min(2,i.length);s++)e.push(i[s]);const a=this.shuffleArray([...t]);return a.length>0&&e.push(a[0]),e}hasUpgradeableSkills(){return this.getUpgradeableActiveSkills().length>0||this.getUpgradeablePassiveSkills().length>0}shuffleArray(m){for(let t=m.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[m[t],m[e]]=[m[e],m[t]]}return m}static formatLevel(m,t=5){return m<=0?"Lv.0":m>=t?"MAX":`Lv.${m}`}getTitaniumLiverHpBonus(){const m=this.playerSkills.get("passive_titanium_liver");return m?(m.level+1)*.1:0}getTitaniumLiverRegenInterval(){const m=this.playerSkills.get("passive_titanium_liver");return m?(15-m.level)*1e3:0}hasTitaniumLiver(){return this.playerSkills.has("passive_titanium_liver")}getSyncRateSpeedBonus(){const m=this.playerSkills.get("passive_sync_rate");return m?(m.level+1)*.1:0}getSyncRateCooldownReduction(){const m=this.playerSkills.get("passive_sync_rate");return m?(m.level+1)*.08:0}getRetinaModuleExpBonus(){const m=this.playerSkills.get("passive_retina_module");return m?(m.level+1)*.3:0}getAiEnhancementDamageBonus(){const m=this.playerSkills.get("passive_ai_enhancement");return m?(m.level+1)*.25:0}getAiEnhancementDefenseBonus(){const m=this.playerSkills.get("passive_ai_enhancement");return m?(m.level+1)*.15:0}calculateFinalMaxHp(m){const t=this.getTitaniumLiverHpBonus();return Math.floor(m*(1+t))}calculateFinalMoveSpeed(m){const t=this.getSyncRateSpeedBonus();return m*(1+t)}calculateFinalCooldown(m){const t=this.getSyncRateCooldownReduction();return m*(1-t)}calculateFinalExp(m){const t=this.getRetinaModuleExpBonus();return Math.floor(m*(1+t))}calculateFinalDamage(m){const t=this.getAiEnhancementDamageBonus();return Math.floor(m*(1+t))}calculateFinalDamageTaken(m){const t=this.getAiEnhancementDefenseBonus();return Math.floor(m*(1-t))}getMaxExtraAbilityValue(m,t){const e=this.playerSkills.get(m);if(!e||e.level<e.definition.maxLevel)return 0;const i=e.definition.maxExtraAbility;return i?i.baseValue+i.perLevel*t:0}getMaxExtraAbilityText(m,t){const e=this.playerSkills.get(m);if(!e||e.level<e.definition.maxLevel)return null;const i=e.definition.maxExtraAbility;if(!i)return null;const a=this.getMaxExtraAbilityValue(m,t),s=i.isPercentage?(a*100).toFixed(1):a.toFixed(1);return`【${i.name}】${i.description.replace("{value}",s+i.unit)}`}getAllMaxExtraAbilities(m){const t=[];return this.playerSkills.forEach((e,i)=>{const a=this.getMaxExtraAbilityText(i,m);a&&t.push({skillId:i,text:a})}),t}getSoulRenderWaveChance(m){return this.getMaxExtraAbilityValue("active_soul_render",m)}getCoderBurstChance(m){return this.getMaxExtraAbilityValue("active_coder",m)}getVfxChainChance(m){return this.getMaxExtraAbilityValue("active_vfx",m)}getArchitectExplosionChance(m){return this.getMaxExtraAbilityValue("active_architect",m)}getTitaniumLiverExtraRegen(m){return this.getMaxExtraAbilityValue("passive_titanium_liver",m)}getSyncRateDodgeChance(m){return this.getMaxExtraAbilityValue("passive_sync_rate",m)}getRetinaModuleCritChance(m){return this.getMaxExtraAbilityValue("passive_retina_module",m)}getAiEnhancementCritDamage(m){return this.getMaxExtraAbilityValue("passive_ai_enhancement",m)}};k(rt,"MAX_PASSIVE_SLOTS",3);let nt=rt;const Gt=[{id:"slime",name:"史萊姆",color:6750054,speed:1,damage:1,size:.08,hp:30,exp:20}],it=class it{constructor(m,t,e,i,a){k(this,"scene");k(this,"monsters",[]);k(this,"nextMonsterId",0);k(this,"container");k(this,"spawnInterval",2e3);k(this,"lastSpawnTime",0);k(this,"isSpawning",!1);k(this,"gameBounds");k(this,"mapWidth");k(this,"mapHeight");k(this,"playerLevel",0);k(this,"gridCellSize",4);k(this,"gridScaleMultiplier",3);this.scene=m,this.container=t,this.gameBounds=e,this.mapWidth=i,this.mapHeight=a,this.updateGridCellSize()}setPlayerLevel(m){this.playerLevel=m}setGridScaleMultiplier(m){this.gridScaleMultiplier=m,this.updateGridCellSize()}updateGridCellSize(){const m=this.scene.cameras.main.width,t=1920,e=20/this.gridScaleMultiplier,i=6/this.gridScaleMultiplier,a=Math.min(1,m/t);this.gridCellSize=Math.max(i,Math.floor(e*a))}calculateMonsterHp(m){return Math.floor(m*Math.pow(it.HP_GROWTH_RATE,this.playerLevel))}calculateMonsterDamage(){const m=Math.max(1,this.playerLevel);return it.DAMAGE_UNIT*m}calculateMonsterExp(m){const t=Math.floor(this.playerLevel/5);return m*Math.pow(2,t)}startSpawning(){this.isSpawning=!0,this.lastSpawnTime=this.scene.time.now}stopSpawning(){this.isSpawning=!1}update(m,t,e,i,a){const s=this.scene.time.now;let n=0;const o=[];if(this.isSpawning&&s-this.lastSpawnTime>=this.spawnInterval){const c=1+Math.floor(this.playerLevel/5);for(let r=0;r<c;r++)this.spawnMonster(t,e,i,a);this.lastSpawnTime=s}const l=this.gameBounds.height*.1,h=this.gameBounds.height*.1;return this.monsters.forEach(c=>{const r=t-c.x,d=e-c.y,y=Math.sqrt(r*r+d*d);if(y>h){const u=c.definition.speed*this.gameBounds.height*.1*m/1e3/y;c.x+=r*u,c.y+=d*u}else s-c.lastDamageTime>=3e3&&(n+=this.calculateMonsterDamage(),c.lastDamageTime=s,o.push(c));this.drawMonster(c,l,i,a,m)}),{damage:n,hitMonsters:o}}spawnMonster(m,t,e,i){const a=["top","left","right"],s=a[Math.floor(Math.random()*a.length)];let n,o;const l=100,h=e,c=e+this.gameBounds.width,r=i;switch(s){case"top":n=h+Math.random()*this.gameBounds.width,o=r-l;break;case"left":n=h-l,o=r+Math.random()*this.gameBounds.height;break;case"right":n=c+l,o=r+Math.random()*this.gameBounds.height;break}n=Phaser.Math.Clamp(n,0,this.mapWidth),o=Phaser.Math.Clamp(o,0,this.mapHeight);const d=Gt[0],y=this.scene.add.graphics(),S=this.calculateMonsterHp(d.hp),g={id:this.nextMonsterId++,definition:d,x:n,y:o,hp:S,graphics:y,lastDamageTime:0,bouncePhase:Math.random()*Math.PI*2,bounceSpeed:3+Math.random()*2,squashStretch:1,flashStartTime:0};this.monsters.push(g),this.container.add(y)}drawMonster(m,t,e,i,a=16){const s=m.graphics;s.clear(),m.bouncePhase+=m.bounceSpeed*a/1e3,m.bouncePhase>Math.PI*2&&(m.bouncePhase-=Math.PI*2);const n=.08;m.squashStretch=1+Math.sin(m.bouncePhase)*n;const o=m.x,l=m.y,h=this.gridCellSize,c=it.GRID_GAP,r=h+c,d=Math.ceil(t/r/2),y=m.definition.color;let S=y>>16&255,g=y>>8&255,u=y&255;const p=300;let M=!1,f=0;if(m.flashStartTime>0){const E=this.scene.time.now-m.flashStartTime;if(E<p){M=!0,f=Math.floor(E/60)%2;const I=E<p/2?1:1-(E-p/2)/(p/2);f===0?(S=Math.min(255,Math.floor(S+(255-S)*I)),g=Math.min(255,Math.floor(g+(255-g)*I)),u=Math.min(255,Math.floor(u+(255-u)*I))):(S=Math.min(255,Math.floor(S+(255-S)*I)),g=Math.floor(g*(1-I*.8)),u=Math.floor(u*(1-I*.8)))}else m.flashStartTime=0}const w=m.squashStretch,C=1/m.squashStretch,x=l,b=t*w;for(let E=-d;E<=0;E++)for(let I=-d;I<=d;I++){const A=I/d/C,G=E/d,R=A*A+G*G;if(R<=1.1){const F=.5+(1-Math.pow(Math.min(1,R),.5))*.5,D=M?1:1+(1-G)*.4,X=Math.min(255,Math.floor(S*D)),O=Math.min(255,Math.floor(g*D)),L=Math.min(255,Math.floor(u*D)),Y=X<<16|O<<8|L,z=o+I*r*C,$=x+E*r*w;s.fillStyle(Y,F*(R<=1?1:(1.1-R)/.1)),s.fillRect(z-h/2,$-h/2,h,h)}}const v=0;for(let E=-d;E<=d;E++){const I=E/d/C;if(Math.abs(I)<=1){const A=o+E*r*C,G=x+v*r*w,R=M?1:.7,H=Math.floor(S*R),F=Math.floor(g*R),D=Math.floor(u*R),X=H<<16|F<<8|D;s.fillStyle(X,.9),s.fillRect(A-h/2,G-h/2,h,h)}}const P=t*.18*C,T=x-b*.5;if(s.fillStyle(0,1),s.fillRect(o-P-h/2,T-h/2,h,h),s.fillRect(o+P-h/2,T-h/2,h,h),!M){const E=o-t*.22*C,I=x-b*.7;s.fillStyle(16777215,.8),s.fillRect(E-h/2,I-h/2,h,h)}}removeMonster(m){const t=this.monsters.findIndex(e=>e.id===m);t!==-1&&(this.monsters[t].graphics.destroy(),this.monsters.splice(t,1))}getMonsters(){return this.monsters}clearAllMonsters(){this.monsters.forEach(m=>{m.graphics.destroy()}),this.monsters=[]}setSpawnInterval(m){this.spawnInterval=m}damageMonster(m,t){const e=this.monsters.find(i=>i.id===m);if(!e)return{killed:!1,exp:0};if(e.hp-=t,this.flashMonster(e),e.hp<=0){const i=this.calculateMonsterExp(e.definition.exp);return this.playDeathSmoke(e.x,e.y),this.removeMonster(m),{killed:!0,exp:i}}return{killed:!1,exp:0}}flashMonster(m){m.flashStartTime=this.scene.time.now}playDeathSmoke(m,t){const e=this.scene;e.flashDeathEffect&&e.flashDeathEffect(m,t)}damageMonsters(m,t){let e=0,i=0;const a=[];for(const s of m){const n=this.monsters.find(h=>h.id===s),o=n?{x:n.x,y:n.y}:null,l=this.damageMonster(s,t);l.killed&&o&&(e+=l.exp,i++,a.push(o))}return{totalExp:e,killCount:i,killedPositions:a}}};k(it,"HP_GROWTH_RATE",1.1),k(it,"DAMAGE_UNIT",10),k(it,"GRID_GAP",1);let xt=it;const B=class B extends _.Scene{constructor(){super("MainScene");k(this,"character");k(this,"characterState","idle");k(this,"facingRight",!0);k(this,"skillIcons",[]);k(this,"skillIconGridGraphics",[]);k(this,"skillIconGridData",[]);k(this,"gameBounds");k(this,"boundsBorder");k(this,"background");k(this,"gameAreaContainer");k(this,"revealMask");k(this,"mapWidth");k(this,"mapHeight");k(this,"characterX");k(this,"characterY");k(this,"characterSize");k(this,"isMoving",!1);k(this,"isPointerDown",!1);k(this,"targetX");k(this,"targetY");k(this,"baseMoveSpeed",0);k(this,"moveSpeed",0);k(this,"floorGrid");k(this,"worldContainer");k(this,"characterContainer");k(this,"uiContainer");k(this,"cameraOffsetX",0);k(this,"cameraOffsetY",0);k(this,"cursors");k(this,"isKeyboardMoving",!1);k(this,"skillPanelContainer");k(this,"isPaused",!1);k(this,"skillOptions",[]);k(this,"skillCardBgs",[]);k(this,"selectedSkillIndex",0);k(this,"currentSkillChoices",[]);k(this,"skillCutInContainer");k(this,"skillManager",new nt);k(this,"skillIconContainers",[]);k(this,"skillLevelTexts",[]);k(this,"skillInfoPanel");k(this,"skillInfoBg");k(this,"skillInfoText");k(this,"skillInfoHideTimer");k(this,"currentExp",0);k(this,"maxExp",100);k(this,"currentLevel",0);k(this,"expBarContainer");k(this,"expBarFlowOffset",0);k(this,"levelText");k(this,"currentHp",200);k(this,"maxHp",200);k(this,"hpBarContainer");k(this,"hpBarFlowOffset",0);k(this,"hpText");k(this,"currentShield",0);k(this,"maxShield",0);k(this,"shieldBarFlowOffset",0);k(this,"shieldReflectDamage",0);k(this,"shieldText");k(this,"shieldAuraGraphics");k(this,"shieldSparkleTimer",0);k(this,"hpRegenTimer",0);k(this,"displayedHp",200);k(this,"hpDamageDelay",0);k(this,"isMobile",!1);k(this,"keyPlus");k(this,"keyMinus");k(this,"keyShift");k(this,"keyCtrl");k(this,"keyZero");k(this,"keyBackspace");k(this,"keyF5");k(this,"keyF6");k(this,"keyF7");k(this,"keyF8");k(this,"keyF9");k(this,"keyF10");k(this,"keyF11");k(this,"keyF12");k(this,"showLegacySkillEffects",!1);k(this,"monsterManager");k(this,"isHurt",!1);k(this,"hurtEndTime",0);k(this,"lowHpBreathTimer",0);k(this,"isLowHp",!1);k(this,"vignetteEdgeCells",new Set);k(this,"skillCooldowns",new Map);k(this,"isAttacking",!1);k(this,"attackEndTime",0);k(this,"gameBgm");k(this,"currentBgmKey","");k(this,"skillGridContainer");k(this,"skillGridCells",[]);k(this,"skillGridCols",0);k(this,"skillGridRows",0);k(this,"skillGridCellSize",10);k(this,"gridScaleMultiplier",3)}create(){this.cameras.main.setBackgroundColor("#111111"),this.isMobile=this.sys.game.device.input.touch&&window.innerWidth<1024,this.gridScaleMultiplier=this.isMobile?2:3;const t=this.cameras.main.width,e=this.cameras.main.height;if(this.gameBounds=this.registry.get("gameBounds"),!this.gameBounds){const o=t*.9,l=e*(1-.05*2),h=16/9,c=o/l;let r,d;c>h?(d=l,r=l*h):(r=o,d=o/h),this.gameBounds={x:(t-r)/2,y:(e-d)/2,width:r,height:d}}this.mapWidth=this.gameBounds.width*B.MAP_SCALE,this.mapHeight=this.gameBounds.height*B.MAP_SCALE,this.characterSize=this.gameBounds.height*.15,this.baseMoveSpeed=this.gameBounds.height*.3,this.moveSpeed=this.baseMoveSpeed,this.characterX=this.mapWidth/2,this.characterY=this.mapHeight/2,this.createFullscreenBackground(t,e),this.gameAreaContainer=this.add.container(0,0),this.gameAreaContainer.setDepth(0),this.drawGameBorder(),this.worldContainer=this.add.container(this.gameBounds.x,this.gameBounds.y),this.floorGrid=this.add.graphics(),this.drawFloorGrid(),this.worldContainer.add(this.floorGrid),this.createCharacterAnimations(),this.characterContainer=this.add.container(this.gameBounds.x,this.gameBounds.y),this.shieldAuraGraphics=this.add.graphics(),this.characterContainer.add(this.shieldAuraGraphics),this.character=this.add.sprite(this.characterX,this.characterY,"char_idle_1"),this.character.setScale(this.characterSize/this.character.height),this.character.setOrigin(.5,1),this.character.play("char_idle"),this.characterContainer.add(this.character),this.monsterManager=new xt(this,this.worldContainer,this.gameBounds,this.mapWidth,this.mapHeight),this.monsterManager.setGridScaleMultiplier(this.gridScaleMultiplier),this.gameAreaContainer.add([this.boundsBorder,this.worldContainer]);const i=this.make.graphics({x:0,y:0});i.fillStyle(16777215),i.fillRect(this.gameBounds.x,this.gameBounds.y,this.gameBounds.width,this.gameBounds.height);const a=i.createGeometryMask();this.worldContainer.setMask(a),this.uiContainer=this.add.container(0,0),this.uiContainer.setDepth(10),this.createSkillGrid(),window.addEventListener("gridscalechange",n=>{this.gridScaleMultiplier=n.detail.scale,this.recreateSkillGrid(),this.monsterManager.setGridScaleMultiplier(n.detail.scale)}),this.characterContainer.setDepth(60),this.characterContainer.setMask(a),this.uiContainer.add(this.characterContainer),this.createSkillBar(),this.revealMask=this.make.graphics({x:0,y:0});const s=this.revealMask.createGeometryMask();this.gameAreaContainer.setMask(s),this.uiContainer.setMask(s),this.registry.events.on("reveal-update",this.updateRevealMask,this),this.registry.events.on("reveal-complete",this.onRevealComplete,this),this.input.on("pointerdown",this.onPointerDown,this),this.input.on("pointermove",this.onPointerMove,this),this.input.on("pointerup",this.onPointerUp,this),this.input.keyboard&&(this.cursors={W:this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.W),A:this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.A),S:this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.S),D:this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.D)},this.keyPlus=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.PLUS),this.keyMinus=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.MINUS),this.keyShift=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.SHIFT),this.keyCtrl=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.CTRL),this.keyZero=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.ZERO),this.keyBackspace=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.BACKSPACE),this.keyF5=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.F5),this.keyF6=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.F6),this.keyF7=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.F7),this.keyF8=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.F8),this.keyF9=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.F9),this.keyF10=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.F10),this.keyF11=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.F11),this.keyF12=this.input.keyboard.addKey(_.Input.Keyboard.KeyCodes.F12)),this.updateCamera(!0),this.createHpBar(),this.createShieldBar(),this.createExpBar(),this.createSkillPanel(),this.createSkillCutIn(),this.createLowHpVignette()}update(t,e){if(this.updateHpBarFlow(e),this.updateShieldBarFlow(e),this.updateExpBarFlow(e),this.updateShieldAura(e),this.updateHpRegen(e),this.updateLowHpVignetteBreathing(e),this.updateSkillCooldownDisplay(),this.isPaused){this.handleSkillPanelInput();return}this.handleExpTestInput();const i=this.time.now;this.isHurt&&i>=this.hurtEndTime&&(this.isHurt=!1,this.setCharacterState("idle"),this.updateCharacterSprite()),this.isAttacking&&i>=this.attackEndTime&&(this.isAttacking=!1,this.character.clearTint(),this.isMoving||this.isKeyboardMoving?this.setCharacterState("run",!0):this.setCharacterState("idle",!0)),this.isHurt||(this.handleKeyboardInput(e),this.isMoving&&!this.isKeyboardMoving&&this.moveCharacter(e));const a=this.monsterManager.update(e,this.characterX,this.characterY,this.cameraOffsetX,this.cameraOffsetY);a.damage>0&&this.takeDamage(a.damage,a.hitMonsters),this.updateSkillRangePreview(i),this.tryActivateSkills(i)}updateSkillRangePreview(t){if(this.clearSkillGrid(),this.isHurt)return;const e=this.skillManager.getPlayerActiveSkills();for(const i of e){if(!i)continue;const a=i.definition;let s=a.cooldown||1e3;a.id==="active_architect"&&(s=s-i.level*500);const n=this.skillManager.calculateFinalCooldown(s),o=this.skillCooldowns.get(a.id)||0;t-o>=n&&this.showSkillPreview(i)}}showSkillPreview(t){const e=t.definition,i=e.color,a=.2;switch(e.id){case"active_soul_render":{const s=this.monsterManager.getMonsters();if(s.length===0)return;let n=0,o=1/0;for(const r of s){const d=r.x-this.characterX,y=r.y-this.characterY,S=Math.sqrt(d*d+y*y);S<o&&(o=S,n=Math.atan2(y,d))}const l=this.gameBounds.height*.3,c=(60+t.level*10)/2*(Math.PI/180);this.showSkillRangeSector(this.characterX,this.characterY,l,n,c,i,a);break}case"active_coder":{const s=this.gameBounds.height*.1,n=2+t.level*.5,o=s*n;this.showSkillRangeCircle(this.characterX,this.characterY,o,i,a);break}case"active_vfx":{const s=this.monsterManager.getMonsters();if(s.length===0)return;const n=Math.min(t.level+1,s.length),o=this.gameBounds.height*1,l=this.gameBounds.height*.05,h=[...s].sort((c,r)=>{const d=Math.sqrt((c.x-this.characterX)**2+(c.y-this.characterY)**2),y=Math.sqrt((r.x-this.characterX)**2+(r.y-this.characterY)**2);return d-y});for(let c=0;c<n;c++){const r=h[c],d=r.x-this.characterX,y=r.y-this.characterY,S=Math.sqrt(d*d+y*y);if(S>0){const g=this.characterX+d/S*o,u=this.characterY+y/S*o;this.showSkillRangeLine(this.characterX,this.characterY,g,u,l,i,a)}}break}case"active_architect":{const s=this.gameBounds.height*.15;this.showSkillRangeCircle(this.characterX,this.characterY,s,i,a);break}}}tryActivateSkills(t){if(this.isHurt)return;const e=this.skillManager.getPlayerActiveSkills();for(const i of e){if(!i)continue;const a=i.definition;let s=a.cooldown||1e3;a.id==="active_architect"&&(s=s-i.level*500);const n=this.skillManager.calculateFinalCooldown(s),o=this.skillCooldowns.get(a.id)||0;t-o>=n&&(this.activateSkill(i,t),this.skillCooldowns.set(a.id,t))}}activateSkill(t,e){const i=t.definition;switch(this.isAttacking=!0,this.attackEndTime=e+B.ATTACK_DURATION,this.setCharacterState("attack",!0),i.flashColor&&this.character.setTint(i.flashColor),i.id){case"active_soul_render":this.activateSoulRender(t);break;case"active_coder":this.activateCoder(t);break;case"active_vfx":this.activateVfx(t);break;case"active_architect":this.activateArchitect(t);break;default:console.log(`Skill activated: ${i.name}`)}}activateSoulRender(t){const e=this.monsterManager.getMonsters();if(e.length===0)return;let i=e[0],a=1/0;for(const S of e){const g=S.x-this.characterX,u=S.y-this.characterY,p=Math.sqrt(g*g+u*u);p<a&&(a=p,i=S)}const s=Math.atan2(i.y-this.characterY,i.x-this.characterX);this.facingRight=Math.cos(s)>=0,this.updateCharacterSprite();const n=this.gameBounds.height*.3,l=(60+t.level*10)/2*(Math.PI/180),h=2+t.level,c=B.DAMAGE_UNIT*h,r=this.skillManager.calculateFinalDamage(c),d=[];for(const S of e){const g=this.gameBounds.height*S.definition.size*.5,u=S.x-this.characterX,p=S.y-this.characterY,M=Math.sqrt(u*u+p*p);if(M-g>n)continue;let w=Math.atan2(p,u)-s;for(;w>Math.PI;)w-=Math.PI*2;for(;w<-Math.PI;)w+=Math.PI*2;const C=M>0?Math.atan2(g,M):Math.PI;Math.abs(w)<=l+C&&d.push(S.id)}if(this.showLegacySkillEffects&&this.drawSectorEffect(s,n,l,t.definition.color),this.drawSectorEdge(s,n,l,t.definition.color),this.flashSkillAreaSector(this.characterX,this.characterY,n,s,l,t.definition.flashColor||t.definition.color),d.length>0){const S=e.filter(u=>d.includes(u.id)).map(u=>({x:u.x,y:u.y})),g=this.monsterManager.damageMonsters(d,r);g.totalExp>0&&this.addExp(g.totalExp),this.flashWhiteCrossAtPositions(S),this.showLegacySkillEffects&&this.drawCrossStarBurst(S,t.definition.flashColor||t.definition.color),this.shakeScreen(d.length),console.log(`Soul Render hit ${d.length} monsters for ${r} damage, killed ${g.killCount}, exp +${g.totalExp}`)}const y=this.skillManager.getSoulRenderWaveChance(this.currentLevel);y>0&&Math.random()<y&&this.triggerSoulRenderWave(s,n,l,r,t)}drawSectorEffect(t,e,i,a){const s=this.add.graphics();this.worldContainer.add(s);const n=t-i,o=t+i,l=this.characterX,h=this.characterY,c=15,r=1e3,d=this.time.now,y=()=>{const g=this.time.now-d,u=Math.min(g/r,1);s.clear();const p=.3,M=u<p?0:(u-p)/(1-p);for(let C=c;C>=1;C--){const x=e*C/c,v=.8*(1-(C-1)/c)*(1-M);v>.01&&(s.fillStyle(a,v),s.beginPath(),s.moveTo(l,h),s.arc(l,h,x,n,o,!1),s.closePath(),s.fillPath())}const f=8;for(let C=f;C>=1;C--){const x=e*.6*C/f,b=.95*(1-(C-1)/f)*(1-M);b>.01&&(s.fillStyle(16777215,b),s.beginPath(),s.moveTo(l,h),s.arc(l,h,x,n,o,!1),s.closePath(),s.fillPath())}const w=1*(1-M);w>.01&&(s.lineStyle(6,a,w),s.beginPath(),s.moveTo(l,h),s.arc(l,h,e,n,o,!1),s.closePath(),s.strokePath(),s.lineStyle(3,16777215,w*.8),s.beginPath(),s.moveTo(l,h),s.arc(l,h,e*.97,n,o,!1),s.closePath(),s.strokePath(),s.lineStyle(4,16777215,w*.9),s.beginPath(),s.moveTo(l,h),s.lineTo(l+Math.cos(t)*e,h+Math.sin(t)*e),s.strokePath()),u>=1&&s.destroy()},S=this.time.addEvent({delay:16,callback:y,callbackScope:this,repeat:Math.ceil(r/16)});this.time.delayedCall(r+50,()=>{s.active&&s.destroy(),S.remove()})}drawSectorEdge(t,e,i,a){const s=this.add.graphics();this.worldContainer.add(s);const n=t-i,o=t+i,l=this.characterX,h=this.characterY,c=500,r=300,d=this.time.now,y=15,S=(p,M,f,w,C=1)=>{for(let x=0;x<y;x++){const b=x/y,v=(x+1)/y,P=(b+v)/2,T=Math.min(1,P/.15),E=Math.min(1,(1-P)/.15),I=Math.min(T,E),A=w*I*I;if(A>.01){const G=e*b*C,R=e*v*C,H=l+Math.cos(p)*G,F=h+Math.sin(p)*G,D=l+Math.cos(p)*R,X=h+Math.sin(p)*R;s.lineStyle(f,M,A),s.beginPath(),s.moveTo(H,F),s.lineTo(D,X),s.strokePath()}}},g=()=>{const p=this.time.now-d,M=Math.min(p/c,1);s.clear();let f=0;p>r&&(f=(p-r)/(c-r));const w=.6*(1-f);w>.01&&(S(n,a,3,w),S(o,a,3,w),S(n,16777215,1.5,w*.5,.98),S(o,16777215,1.5,w*.5,.98)),M>=1&&s.destroy()};g();const u=this.time.addEvent({delay:16,callback:g,callbackScope:this,repeat:Math.ceil(c/16)});this.time.delayedCall(c+50,()=>{s.active&&s.destroy(),u.remove()})}drawCircleEdge(t,e,i,a){const s=this.add.graphics();this.worldContainer.add(s);const n=i??this.characterX,o=a??this.characterY,l=500,h=300,c=this.time.now,r=()=>{const y=this.time.now-c,S=Math.min(y/l,1);s.clear();let g=0;y>h&&(g=(y-h)/(l-h));const u=.6*(1-g);u>.01&&(s.lineStyle(3,e,u),s.strokeCircle(n,o,t),s.lineStyle(1.5,16777215,u*.5),s.strokeCircle(n,o,t*.98)),S>=1&&s.destroy()};r();const d=this.time.addEvent({delay:16,callback:r,callbackScope:this,repeat:Math.ceil(l/16)});this.time.delayedCall(l+50,()=>{s.active&&s.destroy(),d.remove()})}drawBeamEdge(t,e,i,a,s,n){const o=this.add.graphics();this.worldContainer.add(o);const l=s??this.characterX,h=n??this.characterY,c=Math.cos(t),r=Math.sin(t),d=800,y=380,S=this.time.now,g=20,u=()=>{const M=this.time.now-S,f=Math.min(M/d,1);o.clear();let w=0;M>y&&(w=(M-y)/(d-y));const C=.6*(1-w*.5);if(C>.01)for(let x=0;x<g;x++){const b=x/g,v=(x+1)/g,P=(b+v)/2,T=Math.min(1,P/.15),E=Math.min(1,(1-P)/.15),I=Math.min(T,E),A=C*I*I;if(A>.01){const G=l+c*e*b,R=h+r*e*b,H=l+c*e*v,F=h+r*e*v;o.lineStyle(2,16777215,A),o.beginPath(),o.moveTo(G,R),o.lineTo(H,F),o.strokePath()}}f>=1&&o.destroy()};u();const p=this.time.addEvent({delay:16,callback:u,callbackScope:this,repeat:Math.ceil(d/16)});this.time.delayedCall(d+50,()=>{o.active&&o.destroy(),p.remove()})}activateCoder(t){const e=this.monsterManager.getMonsters();if(e.length===0)return;const i=this.gameBounds.height*.1,a=2+t.level*.5,s=i*a,n=1+t.level,o=B.DAMAGE_UNIT*n,l=this.skillManager.calculateFinalDamage(o),h=[];for(const c of e){const r=this.gameBounds.height*c.definition.size*.5,d=c.x-this.characterX,y=c.y-this.characterY;Math.sqrt(d*d+y*y)-r<=s&&h.push(c.id)}if(this.showLegacySkillEffects&&this.drawCircleEffect(s,t.definition.color),this.drawCircleEdge(s,t.definition.color),this.flashSkillAreaCircle(this.characterX,this.characterY,s,t.definition.flashColor||t.definition.color),h.length>0){const c=e.filter(y=>h.includes(y.id)).map(y=>({x:y.x,y:y.y})),r=this.monsterManager.damageMonsters(h,l);r.totalExp>0&&this.addExp(r.totalExp),this.flashWhiteCrossAtPositions(c),this.showLegacySkillEffects&&this.drawCrossStarBurst(c,t.definition.flashColor||t.definition.color),this.shakeScreen(h.length),console.log(`Coder hit ${h.length} monsters for ${l} damage, killed ${r.killCount}, exp +${r.totalExp}`);const d=this.skillManager.getCoderBurstChance(this.currentLevel);d>0&&r.killedPositions.length>0&&this.triggerCoderBurst(r.killedPositions,s,l,t,d)}}triggerSoulRenderWave(t,e,i,a,s){const n=this.gameBounds.height*.1,o=n*5,l=e*i*2,h=s.definition.flashColor||s.definition.color,c=this.characterX,r=this.characterY,d=new Set;this.flashSkillAreaSectorMoving(c,r,e,t,i,h,o);const y=500,S=this.time.now,g=n*.5,u=()=>{const p=this.time.now-S,M=Math.min(p/y,1),f=e+o*M,w=l/(2*f),C=this.monsterManager.getMonsters(),x=[];for(const b of C){if(d.has(b.id))continue;const v=this.gameBounds.height*b.definition.size*.5,P=b.x-c,T=b.y-r,E=Math.sqrt(P*P+T*T);if(Math.abs(E-f)>g+v)continue;let A=Math.atan2(T,P)-t;for(;A>Math.PI;)A-=Math.PI*2;for(;A<-Math.PI;)A+=Math.PI*2;const G=E>0?Math.atan2(v,E):Math.PI;Math.abs(A)<=w+G&&(x.push(b.id),d.add(b.id))}if(x.length>0){const b=C.filter(P=>x.includes(P.id)).map(P=>({x:P.x,y:P.y})),v=this.monsterManager.damageMonsters(x,a);v.totalExp>0&&this.addExp(v.totalExp),this.flashWhiteCrossAtPositions(b)}M<1&&this.time.delayedCall(16,u)};u()}flashSkillAreaSectorMoving(t,e,i,a,s,n,o){const l=this.worldToScreen(t,e),h=l.x,c=l.y,r=B.SKILL_GRID_GAP,d=this.skillGridCellSize+r,y=500,S=this.time.now,g=Math.cos(a),u=Math.sin(a),p=i+o+i,M=[],f=Math.max(0,Math.floor((h-p)/d)),w=Math.min(this.skillGridCols-1,Math.ceil((h+p)/d)),C=Math.max(0,Math.floor((c-p)/d)),x=Math.min(this.skillGridRows-1,Math.ceil((c+p)/d));for(let P=C;P<=x;P++)for(let T=f;T<=w;T++){const E=T*d+this.skillGridCellSize/2,I=P*d+this.skillGridCellSize/2;M.push({col:T,row:P,screenX:E,screenY:I})}if(M.length===0)return;const b=[];for(const{col:P,row:T}of M){const E=P*d+this.skillGridCellSize/2,I=T*d+this.skillGridCellSize/2,A=this.add.rectangle(E,I,this.skillGridCellSize,this.skillGridCellSize,n,0);A.setVisible(!1),this.skillGridContainer.add(A),b.push(A)}const v=()=>{const P=this.time.now-S,T=Math.min(P/y,1),E=o*T,I=h+g*E,A=c+u*E,G=.5,R=T>G?(T-G)/(1-G):0;let H=0;for(const{screenX:F,screenY:D}of M){const X=b[H++];if(!X)continue;const O=F-I,L=D-A,Y=Math.sqrt(O*O+L*L),z=i*.5;if(Y>=z&&Y<=i){let V=Math.atan2(L,O)-a;for(;V>Math.PI;)V-=Math.PI*2;for(;V<-Math.PI;)V+=Math.PI*2;if(Math.abs(V)<=s){const U=(Y-z)/(i-z),W=Math.abs(V)/s,N=Math.max(U,W),K=Math.max(0,Math.min(1,(N-.3)/.7)),q=K*K*(3-2*K),tt=(.15+q*.6)*(1-R);if(tt>.01){const j=.5+q*.5,et=n>>16&255,ot=n>>8&255,st=n&255,ft=Math.floor(et*j),gt=Math.floor(ot*j),ht=Math.floor(st*j),ct=ft<<16|gt<<8|ht;X.setFillStyle(ct,tt),X.setVisible(!0)}else X.setVisible(!1)}else X.setVisible(!1)}else X.setVisible(!1)}if(T>=1)for(const F of b)F.destroy();else this.time.delayedCall(16,v)};v()}triggerCoderBurst(t,e,i,a,s){const n=this.monsterManager.getMonsters();if(n.length===0)return;const o=e*.5;for(const l of t){if(Math.random()>=s)continue;const h=[];for(const c of n){const r=this.gameBounds.height*c.definition.size*.5,d=c.x-l.x,y=c.y-l.y;Math.sqrt(d*d+y*y)-r<=o&&h.push(c.id)}if(this.drawCircleEdge(o,a.definition.color,l.x,l.y),this.flashSkillAreaCircle(l.x,l.y,o,a.definition.flashColor||a.definition.color),h.length>0){const c=n.filter(d=>h.includes(d.id)).map(d=>({x:d.x,y:d.y})),r=this.monsterManager.damageMonsters(h,i);r.totalExp>0&&this.addExp(r.totalExp),this.flashWhiteCrossAtPositions(c),console.log(`Coder Burst hit ${h.length} monsters for ${i} damage`)}}}drawCircleEffect(t,e){const i=this.add.graphics();this.worldContainer.add(i);const a=this.characterX,s=this.characterY,n=15,o=1e3,l=this.time.now,h=()=>{const r=this.time.now-l,d=Math.min(r/o,1);i.clear();const y=.3,S=d<y?0:(d-y)/(1-y);for(let p=n;p>=1;p--){const M=t*p/n,f=t*(p-1)/n,C=.7*(1-(p-1)/n)*(1-S);C>.01&&(i.fillStyle(e,C),i.beginPath(),i.arc(a,s,M,0,Math.PI*2,!1),f>0&&i.arc(a,s,f,0,Math.PI*2,!0),i.closePath(),i.fillPath())}const g=8;for(let p=g;p>=1;p--){const M=t*.5*p/g,f=t*.5*(p-1)/g,w=.95*(1-(p-1)/g)*(1-S);w>.01&&(i.fillStyle(16777215,w),i.beginPath(),i.arc(a,s,M,0,Math.PI*2,!1),f>0&&i.arc(a,s,f,0,Math.PI*2,!0),i.closePath(),i.fillPath())}const u=1*(1-S);u>.01&&(i.lineStyle(6,e,u),i.strokeCircle(a,s,t),i.lineStyle(3,16777215,u*.8),i.strokeCircle(a,s,t*.96),i.lineStyle(2,16777215,u*.5),i.strokeCircle(a,s,t*.7),i.strokeCircle(a,s,t*.4)),d>=1&&i.destroy()},c=this.time.addEvent({delay:16,callback:h,callbackScope:this,repeat:Math.ceil(o/16)});this.time.delayedCall(o+50,()=>{i.active&&i.destroy(),c.remove()})}activateVfx(t){const e=this.monsterManager.getMonsters();if(e.length===0)return;const i=t.level+1,a=this.gameBounds.height*1,s=this.gameBounds.height*.05,n=1+t.level,o=B.DAMAGE_UNIT*n,l=this.skillManager.calculateFinalDamage(o),h=new Set,c=e.map((y,S)=>S),r=[];for(let y=0;y<i;y++){let S;if(c.length>0){const p=Math.floor(Math.random()*c.length),M=c[p];c.splice(p,1);const f=e[M];S=Math.atan2(f.y-this.characterY,f.x-this.characterX)}else S=Math.random()*Math.PI*2;r.push(S);for(const p of e){const M=this.gameBounds.height*p.definition.size*.5,f=p.x-this.characterX,w=p.y-this.characterY;if(Math.sqrt(f*f+w*w)-M>a)continue;const x=Math.cos(S),b=Math.sin(S);if(f*x+w*b<-M)continue;Math.abs(f*b-w*x)<=s/2+M&&h.add(p.id)}this.showLegacySkillEffects&&this.drawBeamEffect(S,a,s,t.definition.color),this.drawBeamEdge(S,a,s,t.definition.color);const g=this.characterX+Math.cos(S)*a,u=this.characterY+Math.sin(S)*a;this.flashSkillAreaLine(this.characterX,this.characterY,g,u,s,t.definition.flashColor||t.definition.color)}r.length>0&&(this.facingRight=Math.cos(r[0])>=0,this.updateCharacterSprite());const d=Array.from(h);if(d.length>0){const S=e.filter(p=>d.includes(p.id)).map(p=>({x:p.x,y:p.y})),g=this.monsterManager.damageMonsters(d,l);g.totalExp>0&&this.addExp(g.totalExp),this.flashWhiteCrossAtPositions(S),this.showLegacySkillEffects&&this.drawCrossStarBurst(S,t.definition.flashColor||t.definition.color),this.shakeScreen(d.length),console.log(`VFX (${i} beams) hit ${d.length} monsters for ${l} damage, killed ${g.killCount}, exp +${g.totalExp}`);const u=this.skillManager.getVfxChainChance(this.currentLevel);u>0&&g.killedPositions.length>0&&this.triggerVfxChain(g.killedPositions,l,u,t)}}triggerVfxChain(t,e,i,a){const s=this.monsterManager.getMonsters();if(s.length===0)return;const n=this.gameBounds.height*1,o=this.gameBounds.height*.05;for(const l of t){if(Math.random()>=i)continue;const h=s.filter(g=>{const u=g.x-l.x,p=g.y-l.y;return Math.sqrt(u*u+p*p)>10});if(h.length===0)continue;const c=h[Math.floor(Math.random()*h.length)],r=Math.atan2(c.y-l.y,c.x-l.x),d=[];for(const g of s){const u=this.gameBounds.height*g.definition.size*.5,p=g.x-l.x,M=g.y-l.y;if(Math.sqrt(p*p+M*M)-u>n)continue;const w=Math.cos(r),C=Math.sin(r);if(p*w+M*C<-u)continue;Math.abs(p*C-M*w)<=o/2+u&&d.push(g.id)}this.drawBeamEdge(r,n,o,a.definition.color,l.x,l.y);const y=l.x+Math.cos(r)*n,S=l.y+Math.sin(r)*n;if(this.flashSkillAreaLine(l.x,l.y,y,S,o,a.definition.flashColor||a.definition.color),d.length>0){const g=s.filter(p=>d.includes(p.id)).map(p=>({x:p.x,y:p.y})),u=this.monsterManager.damageMonsters(d,e);u.totalExp>0&&this.addExp(u.totalExp),this.flashWhiteCrossAtPositions(g),console.log(`VFX Chain hit ${d.length} monsters for ${e} damage`)}}}drawBeamEffect(t,e,i,a){const s=this.add.graphics();this.worldContainer.add(s);const n=this.characterX,o=this.characterY,l=n+Math.cos(t)*e,h=o+Math.sin(t)*e,c=i*1.5,r=Math.sin(t)*c/2,d=-Math.cos(t)*c/2,y=Math.sin(t)*c*.4/2,S=-Math.cos(t)*c*.4/2,g=15,u=1e3,p=this.time.now,M=()=>{const w=this.time.now-p,C=Math.min(w/u,1);s.clear();const x=.3,b=C<x?0:(C-x)/(1-x);for(let T=0;T<g;T++){const E=T/g,I=(T+1)/g,A=n+(l-n)*E,G=o+(h-o)*E,R=n+(l-n)*I,H=o+(h-o)*I,D=.85*(1-E*.6)*(1-b);D>.01&&(s.fillStyle(a,D),s.beginPath(),s.moveTo(A-r,G-d),s.lineTo(R-r,H-d),s.lineTo(R+r,H+d),s.lineTo(A+r,G+d),s.closePath(),s.fillPath())}for(let T=0;T<g;T++){const E=T/g,I=(T+1)/g,A=n+(l-n)*E,G=o+(h-o)*E,R=n+(l-n)*I,H=o+(h-o)*I,F=.98*(1-E*.5)*(1-b);F>.01&&(s.fillStyle(16777215,F),s.beginPath(),s.moveTo(A-y,G-S),s.lineTo(R-y,H-S),s.lineTo(R+y,H+S),s.lineTo(A+y,G+S),s.closePath(),s.fillPath())}const v=1*(1-b);v>.01&&(s.lineStyle(6,16777215,v),s.beginPath(),s.moveTo(n,o),s.lineTo(l,h),s.strokePath());const P=1*(1-b);P>.01&&(s.lineStyle(4,a,P),s.beginPath(),s.moveTo(n-r,o-d),s.lineTo(l-r,h-d),s.lineTo(l+r,h+d),s.lineTo(n+r,o+d),s.closePath(),s.strokePath(),s.lineStyle(2,16777215,P*.6),s.beginPath(),s.moveTo(n-r*1.1,o-d*1.1),s.lineTo(l-r*1.1,h-d*1.1),s.lineTo(l+r*1.1,h+d*1.1),s.lineTo(n+r*1.1,o+d*1.1),s.closePath(),s.strokePath()),C>=1&&s.destroy()},f=this.time.addEvent({delay:16,callback:M,callbackScope:this,repeat:Math.ceil(u/16)});this.time.delayedCall(u+50,()=>{s.active&&s.destroy(),f.remove()})}drawCrossStarBurst(t,e){const a=this.gameBounds.height*.1*1,s=600;for(const n of t){const o=this.add.graphics();this.worldContainer.add(o);const l=this.time.now,h=()=>{const r=this.time.now-l,d=Math.min(r/s,1);o.clear();const y=d<.2?d/.2:1,S=d<.4?0:(d-.4)/.6,g=a*y,u=1-S;if(u>.01&&g>0){const p=g*.2,M=g,f=g*.4;o.fillStyle(16777215,u),o.fillCircle(n.x,n.y,f);for(let x=0;x<4;x++){const b=x*Math.PI/2,v=Math.cos(b),P=Math.sin(b),T=-P,E=v,I=6;for(let A=0;A<I;A++){const G=A/I,R=(A+1)/I,H=p*(1-G*.8),F=p*(1-R*.8),D=n.x+v*M*G,X=n.y+P*M*G,O=n.x+v*M*R,L=n.y+P*M*R,Y=u*(1-G*.7);o.fillStyle(e,Y*.8),o.beginPath(),o.moveTo(D+T*H,X+E*H),o.lineTo(O+T*F,L+E*F),o.lineTo(O-T*F,L-E*F),o.lineTo(D-T*H,X-E*H),o.closePath(),o.fillPath();const z=H*.5,$=F*.5;o.fillStyle(16777215,Y*.9),o.beginPath(),o.moveTo(D+T*z,X+E*z),o.lineTo(O+T*$,L+E*$),o.lineTo(O-T*$,L-E*$),o.lineTo(D-T*z,X-E*z),o.closePath(),o.fillPath()}}const w=M*.5,C=p*.6;for(let x=0;x<4;x++){const b=x*Math.PI/2+Math.PI/4,v=Math.cos(b),P=Math.sin(b),T=-P,E=v,I=4;for(let A=0;A<I;A++){const G=A/I,R=(A+1)/I,H=C*(1-G*.9),F=C*(1-R*.9),D=n.x+v*w*G,X=n.y+P*w*G,O=n.x+v*w*R,L=n.y+P*w*R,Y=u*(1-G*.8)*.7;o.fillStyle(e,Y),o.beginPath(),o.moveTo(D+T*H,X+E*H),o.lineTo(O+T*F,L+E*F),o.lineTo(O-T*F,L-E*F),o.lineTo(D-T*H,X-E*H),o.closePath(),o.fillPath()}}}d>=1&&o.destroy()};h();const c=this.time.addEvent({delay:16,callback:h,callbackScope:this,repeat:Math.ceil(s/16)});this.time.delayedCall(s+50,()=>{o.active&&o.destroy(),c.remove()})}}activateArchitect(t){const e=this.skillManager.getArchitectExplosionChance(this.currentLevel);e>0&&this.currentShield>0&&Math.random()<e&&this.triggerShieldExplosion(t);const i=Math.floor(this.maxHp*.3);this.currentShield=i,this.maxShield=i;const a=1+t.level*1.5;this.shieldReflectDamage=B.DAMAGE_UNIT*a,this.drawShieldBarFill(),this.showLegacySkillEffects&&this.drawShieldActivateEffect();const s=this.gameBounds.height*.15;this.flashSkillAreaCircle(this.characterX,this.characterY,s,t.definition.flashColor||t.definition.color),console.log(`Architect activated: Shield ${i}, Reflect damage ${this.shieldReflectDamage} (${a} units)`)}triggerShieldExplosion(t){const i=this.gameBounds.height*.1*3,a=t.definition.color,s=t.definition.flashColor||a,n=this.shieldReflectDamage;if(this.maxShield>0){const h=this.maxShield;this.currentHp=Math.min(this.currentHp+h,this.maxHp),console.log(`Shield explosion! Healed ${h} HP, current HP: ${this.currentHp}/${this.maxHp}`),this.drawHpBarFill(),this.updateHpText(),this.updateLowHpVignette(),this.showHpHealEffect(h)}this.drawCircleEdge(i,a),this.flashSkillAreaCircle(this.characterX,this.characterY,i,s);const o=this.monsterManager.getMonsters(),l=[];for(const h of o){const c=this.gameBounds.height*h.definition.size*.5,r=h.x-this.characterX,d=h.y-this.characterY;Math.sqrt(r*r+d*d)-c<=i&&l.push(h.id)}if(l.length>0){const h=o.filter(r=>l.includes(r.id)).map(r=>({x:r.x,y:r.y})),c=this.monsterManager.damageMonsters(l,n);c.totalExp>0&&this.addExp(c.totalExp),this.flashWhiteCrossAtPositions(h),this.shakeScreen(l.length),console.log(`Shield Explosion hit ${l.length} monsters for ${n} damage`)}}drawShieldActivateEffect(){const t=this.add.graphics();this.worldContainer.add(t);const e=this.characterX,i=this.characterY-this.characterSize/2,a=this.characterSize*1.2,s=16763904,n=800,o=this.time.now,l=()=>{const c=this.time.now-o,r=Math.min(c/n,1);t.clear();const d=r<.2?r/.2:1,y=r<.2?0:(r-.2)/.8,S=a*(.3+.7*d),g=1-y;if(g>.01){for(let f=8;f>=1;f--){const w=S*f/8,C=g*(1-(f-1)/8)*.6;C>.01&&(t.fillStyle(s,C),t.fillCircle(e,i,w))}const p=4;for(let f=p;f>=1;f--){const w=S*.4*f/p,C=g*(1-(f-1)/p)*.9;C>.01&&(t.fillStyle(16777215,C),t.fillCircle(e,i,w))}t.lineStyle(5,s,g*.9),t.strokeCircle(e,i,S),t.lineStyle(2,16777215,g*.7),t.strokeCircle(e,i,S*.95);const M=S*.7;t.lineStyle(3,16777215,g*.5),t.beginPath();for(let f=0;f<6;f++){const w=f*Math.PI/3,C=e+Math.cos(w)*M,x=i+Math.sin(w)*M;f===0?t.moveTo(C,x):t.lineTo(C,x)}t.closePath(),t.strokePath()}r>=1&&t.destroy()};l();const h=this.time.addEvent({delay:16,callback:l,callbackScope:this,repeat:Math.ceil(n/16)});this.time.delayedCall(n+50,()=>{t.active&&t.destroy(),h.remove()})}handleExpTestInput(){if(!(!this.keyPlus||!this.keyMinus||!this.keyShift)){if(this.keyShift.isDown&&_.Input.Keyboard.JustDown(this.keyBackspace)){this.showLegacySkillEffects=!this.showLegacySkillEffects,console.log(`Legacy skill effects: ${this.showLegacySkillEffects?"ON":"OFF"}`);return}if(this.keyShift.isDown&&_.Input.Keyboard.JustDown(this.keyZero)){this.maxOutAllSkills();return}if(this.keyCtrl.isDown&&this.keyShift.isDown){const t=[{key:this.keyF5,skillId:"active_soul_render"},{key:this.keyF6,skillId:"active_coder"},{key:this.keyF7,skillId:"active_vfx"},{key:this.keyF8,skillId:"active_architect"},{key:this.keyF9,skillId:"passive_titanium_liver"},{key:this.keyF10,skillId:"passive_sync_rate"},{key:this.keyF11,skillId:"passive_retina_module"},{key:this.keyF12,skillId:"passive_ai_enhancement"}];for(const{key:e,skillId:i}of t)if(e&&_.Input.Keyboard.JustDown(e)){this.maxOutSingleSkill(i);return}}if(this.keyShift.isDown&&_.Input.Keyboard.JustDown(this.keyPlus)){this.levelUp();return}this.keyPlus.isDown&&!this.keyShift.isDown&&this.addExp(10),this.keyMinus.isDown&&this.addExp(-10)}}maxOutSingleSkill(t){const e=dt.find(o=>o.id===t);if(!e)return;const i=this.skillManager.getSkillLevel(t),a=e.type==="passive";if(i>=e.maxLevel){console.log(`Test: ${e.name} is already MAX`);return}if(a&&i<0&&this.skillManager.isPassiveSlotsFull()){console.log(`Test: Passive slots full, cannot add ${e.name}`);return}const s=i<0?-1:i,n=e.maxLevel-s;this.currentLevel+=n,this.monsterManager.setPlayerLevel(this.currentLevel);for(let o=0;o<n;o++)this.skillManager.learnOrUpgradeSkill(t);this.recalculateMaxHp(),this.recalculateMoveSpeed(),this.currentHp=this.maxHp,this.displayedHp=this.maxHp,this.currentExp=0,this.maxExp=Math.floor(B.BASE_EXP*Math.pow(B.EXP_GROWTH_RATE,this.currentLevel)),this.drawHpBarFill(),this.updateHpText(),this.drawExpBarFill(),this.levelText.setText(`Lv.${this.currentLevel}`),this.updateSkillBarDisplay(),console.log(`Test: ${e.name} maxed! Player level: ${this.currentLevel}`)}maxOutAllSkills(){this.currentLevel=24;const e=this.skillManager.getActiveSkillDefinitions();for(const i of e)for(let a=0;a<=i.maxLevel;a++)this.skillManager.learnOrUpgradeSkill(i.id);this.monsterManager.setPlayerLevel(this.currentLevel),this.recalculateMaxHp(),this.recalculateMoveSpeed(),this.currentHp=this.maxHp,this.displayedHp=this.maxHp,this.currentExp=0,this.maxExp=Math.floor(B.BASE_EXP*Math.pow(B.EXP_GROWTH_RATE,this.currentLevel)),this.drawHpBarFill(),this.updateHpText(),this.drawExpBarFill(),this.levelText.setText(`Lv.${this.currentLevel}`),this.updateSkillBarDisplay(),console.log("Test: Jumped to level 24 with all active skills maxed!")}addExp(t){t>0&&(t=this.skillManager.calculateFinalExp(t)),this.currentExp+=t,this.currentExp<0&&(this.currentExp=0),this.currentExp>=this.maxExp&&this.levelUp(),this.drawExpBarFill()}levelUp(){this.currentLevel++,this.currentExp=0,this.maxExp=Math.floor(B.BASE_EXP*Math.pow(B.EXP_GROWTH_RATE,this.currentLevel)),this.recalculateMaxHp(),this.currentHp=this.maxHp,this.displayedHp=this.maxHp,this.monsterManager.setPlayerLevel(this.currentLevel),this.levelText.setText(`Lv.${this.currentLevel}`),this.drawHpBarFill(),this.updateHpText(),this.updateLowHpVignette(),this.showSkillPanel(),this.drawExpBarFill(),console.log(`Level up! Lv.${this.currentLevel}, MaxHP: ${this.maxHp}, NextExp: ${this.maxExp}`)}recalculateMaxHp(){const t=B.BASE_HP+B.HP_PER_LEVEL*this.currentLevel,e=this.maxHp;if(this.maxHp=this.skillManager.calculateFinalMaxHp(t),this.maxHp>e&&e>0){const i=this.currentHp/e;this.currentHp=Math.floor(this.maxHp*i)}this.currentHp=Math.min(this.currentHp,this.maxHp)}recalculateMoveSpeed(){this.moveSpeed=this.skillManager.calculateFinalMoveSpeed(this.baseMoveSpeed)}handleSkillPanelInput(){this.cursors&&(_.Input.Keyboard.JustDown(this.cursors.A)&&(this.selectedSkillIndex===0?this.confirmSkillSelection():this.setSelectedSkill(0)),_.Input.Keyboard.JustDown(this.cursors.S)&&(this.selectedSkillIndex===1?this.confirmSkillSelection():this.setSelectedSkill(1)),_.Input.Keyboard.JustDown(this.cursors.D)&&(this.selectedSkillIndex===2?this.confirmSkillSelection():this.setSelectedSkill(2)))}setSelectedSkill(t){this.updateSkillCardStyle(this.selectedSkillIndex,!1),this.selectedSkillIndex=t,this.updateSkillCardStyle(this.selectedSkillIndex,!0)}updateSkillCardStyle(t,e){const i=this.skillCardBgs[t],a=this.skillOptions[t];!i||!a||(e?(i.setFillStyle(3355443),i.setStrokeStyle(3,16777215),this.tweens.add({targets:a,scaleX:1.05,scaleY:1.05,duration:100})):(i.setFillStyle(2236962),i.setStrokeStyle(2,6710886),this.tweens.add({targets:a,scaleX:1,scaleY:1,duration:100})))}confirmSkillSelection(){if(this.currentSkillChoices.length===0||this.selectedSkillIndex>=this.currentSkillChoices.length)return;const t=this.currentSkillChoices[this.selectedSkillIndex];this.selectSkill(this.selectedSkillIndex,t.id)}handleKeyboardInput(t){if(!this.cursors)return;let e=0,i=0;if(this.cursors.W.isDown&&(i=-1),this.cursors.S.isDown&&(i=1),this.cursors.A.isDown&&(e=-1),this.cursors.D.isDown&&(e=1),e!==0||i!==0){if(this.isKeyboardMoving=!0,this.isMoving=!1,e!==0&&(this.facingRight=e>0),e!==0&&i!==0){const s=1/Math.sqrt(2);e*=s,i*=s}const a=this.moveSpeed*t/1e3;this.characterX+=e*a,this.characterY+=i*a,this.characterX=_.Math.Clamp(this.characterX,this.characterSize,this.mapWidth-this.characterSize),this.characterY=_.Math.Clamp(this.characterY,this.characterSize,this.mapHeight-this.characterSize),this.setCharacterState("run"),this.updateCharacterSprite(),this.updateCamera()}else this.isKeyboardMoving=!1,this.isMoving||(this.setCharacterState("idle"),this.updateCharacterSprite())}onPointerDown(t){this.isPaused||this.isPointerInGameArea(t)&&(this.isPointerDown=!0,this.updateTargetFromPointer(t),this.isMoving=!0)}onPointerMove(t){!this.isPointerDown||this.isPaused||this.isPointerInGameArea(t)&&this.updateTargetFromPointer(t)}onPointerUp(){this.isPointerDown=!1}isPointerInGameArea(t){return t.x>=this.gameBounds.x&&t.x<=this.gameBounds.x+this.gameBounds.width&&t.y>=this.gameBounds.y&&t.y<=this.gameBounds.y+this.gameBounds.height}updateTargetFromPointer(t){const e=t.x-this.gameBounds.x,i=t.y-this.gameBounds.y,a=e+this.cameraOffsetX,s=i+this.cameraOffsetY;this.targetX=_.Math.Clamp(a,this.characterSize,this.mapWidth-this.characterSize),this.targetY=_.Math.Clamp(s,this.characterSize,this.mapHeight-this.characterSize)}moveCharacter(t){const e=this.targetX-this.characterX,i=this.targetY-this.characterY,a=Math.sqrt(e*e+i*i);if(this.updateCharacterFacing(this.targetX),a<5)this.characterX=this.targetX,this.characterY=this.targetY,this.isMoving=!1,this.setCharacterState("idle");else{const s=this.moveSpeed*t/1e3;if(s>=a)this.characterX=this.targetX,this.characterY=this.targetY,this.isMoving=!1,this.setCharacterState("idle");else{const n=s/a;this.characterX+=e*n,this.characterY+=i*n,this.setCharacterState("run")}}this.updateCharacterSprite(),this.updateCamera()}updateCamera(t=!1){const e=this.cameraOffsetX+this.gameBounds.width/2,i=this.cameraOffsetY+this.gameBounds.height/2,a=this.characterX-e,s=this.characterY-i,n=this.gameBounds.width*B.CAMERA_DEAD_ZONE,o=this.gameBounds.height*B.CAMERA_DEAD_ZONE;t?(this.cameraOffsetX=this.characterX-this.gameBounds.width/2,this.cameraOffsetY=this.characterY-this.gameBounds.height/2):(Math.abs(a)>n/2&&(a>0?this.cameraOffsetX+=a-n/2:this.cameraOffsetX+=a+n/2),Math.abs(s)>o/2&&(s>0?this.cameraOffsetY+=s-o/2:this.cameraOffsetY+=s+o/2)),this.cameraOffsetX=_.Math.Clamp(this.cameraOffsetX,0,this.mapWidth-this.gameBounds.width),this.cameraOffsetY=_.Math.Clamp(this.cameraOffsetY,0,this.mapHeight-this.gameBounds.height),this.worldContainer.setPosition(this.gameBounds.x-this.cameraOffsetX,this.gameBounds.y-this.cameraOffsetY),this.characterContainer.setPosition(this.gameBounds.x-this.cameraOffsetX,this.gameBounds.y-this.cameraOffsetY)}updateRevealMask(t){this.revealMask&&(this.revealMask.clear(),this.revealMask.fillStyle(16777215),this.revealMask.fillCircle(t.x,t.y,t.radius))}onRevealComplete(){this.gameAreaContainer.clearMask(!0),this.uiContainer.clearMask(!0),this.revealMask.destroy(),this.registry.events.off("reveal-update",this.updateRevealMask,this),this.registry.events.off("reveal-complete",this.onRevealComplete,this);const t=document.getElementById("controls");t&&t.classList.add("visible"),this.showSkillPanel(),this.monsterManager.startSpawning(),this.playRandomGameBgm()}playRandomGameBgm(){const t=["bgm_game_01","bgm_game_02"];let e;if(this.currentBgmKey&&t.length>1){const i=t.filter(a=>a!==this.currentBgmKey);e=i[Math.floor(Math.random()*i.length)]}else e=t[Math.floor(Math.random()*t.length)];this.currentBgmKey=e,this.gameBgm&&(this.gameBgm.stop(),this.gameBgm.destroy()),this.cache.audio.exists(e)&&(this.gameBgm=this.sound.add(e,{volume:.5,loop:!1}),this.gameBgm.on("complete",()=>{this.playRandomGameBgm()}),this.gameBgm.play())}createFullscreenBackground(t,e){this.background=this.add.image(t/2,e/2,"background");const i=t/this.background.width,a=e/this.background.height,s=Math.max(i,a);this.background.setScale(s)}drawGameBorder(){this.boundsBorder=this.add.rectangle(this.gameBounds.x+this.gameBounds.width/2,this.gameBounds.y+this.gameBounds.height/2,this.gameBounds.width,this.gameBounds.height,0),this.boundsBorder.setStrokeStyle(2,4473924)}createHpBar(){this.hpBarContainer=this.add.container(0,0),this.hpBarContainer.setDepth(1001);const t=this.skillGridCellSize,e=this.gameBounds.y+t*2,i=Math.max(B.MIN_FONT_SIZE_MEDIUM,Math.floor(this.gameBounds.height*.03));this.hpText=this.add.text(this.gameBounds.x+this.gameBounds.width/2,e+t/2,`${this.currentHp} / ${this.maxHp}`,{fontFamily:"monospace",fontSize:`${i}px`,color:"#ffffff",fontStyle:"bold",stroke:"#000000",strokeThickness:4}),this.hpText.setOrigin(.5,.5),this.hpText.setDepth(1002),this.hpBarContainer.add(this.hpText),this.drawHpBarFill(),this.uiContainer.add(this.hpBarContainer)}drawHpBarFill(){const t=[0,1],e=this.skillGridCols,i=this.currentHp/this.maxHp,a=Math.floor(e*i),s=this.displayedHp/this.maxHp,n=Math.floor(e*s);for(const o of t)for(let l=0;l<this.skillGridCols;l++){const h=o*this.skillGridCols+l,c=this.skillGridCells[h];c&&(c.setFillStyle(0,.9),c.setVisible(!0),c.setDepth(1e3))}if(n>a)for(const o of t)for(let l=a;l<n;l++){const h=o*this.skillGridCols+l,c=this.skillGridCells[h];if(!c)continue;const r=o===0?.85:.7;c.setFillStyle(16777215,r)}if(!(a<=0)){for(const o of t)for(let l=0;l<a;l++){const h=o*this.skillGridCols+l,c=this.skillGridCells[h];if(!c)continue;const r=l/e,d=this.hpBarFlowOffset,y=(r+d)%1,S=(Math.sin(y*Math.PI*2-Math.PI/2)+1)/2,g=Math.floor(136-34*S),u=0,p=Math.floor(34+102*S),M=g<<16|u<<8|p,f=o===0?.95:.8;c.setFillStyle(M,f)}if(this.currentShield>0&&this.maxShield>0){const o=this.currentShield/this.maxShield,l=Math.floor(e*o);for(let h=0;h<l;h++){const c=0*this.skillGridCols+h,r=this.skillGridCells[c];if(!r)continue;const d=h/e,y=this.shieldBarFlowOffset,S=(d+y)%1,g=(Math.sin(S*Math.PI*2-Math.PI/2)+1)/2,u=255,p=Math.floor(204+51*g),M=Math.floor(0+204*g),f=u<<16|p<<8|M;r.setFillStyle(f,.95)}}}}updateHpBarFlow(t){this.hpBarFlowOffset+=.2*t/1e3,this.hpBarFlowOffset>=1&&(this.hpBarFlowOffset-=1),this.updateDamageDisplay(t),this.drawHpBarFill()}updateDamageDisplay(t){if(this.displayedHp>this.currentHp)if(this.hpDamageDelay>0)this.hpDamageDelay-=t;else{const i=(this.displayedHp-this.currentHp)*B.HP_DAMAGE_LERP_SPEED*(t/1e3);this.displayedHp-=Math.max(1,i),this.displayedHp<this.currentHp&&(this.displayedHp=this.currentHp)}else this.displayedHp<this.currentHp&&(this.displayedHp=this.currentHp)}updateHpText(){this.hpText&&(this.currentShield>0?this.hpText.setText(`${this.currentHp}(+${this.currentShield}) / ${this.maxHp}`):this.hpText.setText(`${this.currentHp} / ${this.maxHp}`))}createShieldBar(){const t=this.skillGridCellSize,e=this.gameBounds.y+t*2,i=Math.max(B.MIN_FONT_SIZE_SMALL,Math.floor(this.gameBounds.height*.025));this.shieldText=this.add.text(this.gameBounds.x+this.gameBounds.width-10,e+t/2,"",{fontFamily:"monospace",fontSize:`${i}px`,color:"#ffdd44",fontStyle:"bold",stroke:"#000000",strokeThickness:3}),this.shieldText.setOrigin(1,.5),this.shieldText.setDepth(1002),this.shieldText.setVisible(!1),this.uiContainer.add(this.shieldText)}drawShieldBarFill(){this.shieldText.setVisible(!1),this.updateHpText()}updateShieldBarFlow(t){if(this.currentShield<=0)return;const e=.6;this.shieldBarFlowOffset+=e*t/1e3,this.shieldBarFlowOffset>=1&&(this.shieldBarFlowOffset-=1),this.drawShieldBarFill()}updateShieldAura(t){if(this.shieldAuraGraphics.clear(),this.currentShield<=0)return;const e=this.characterX,i=this.characterY,a=this.characterSize*.8,s=this.characterSize*.35,n=i-this.characterSize*.15;for(let l=5;l>=0;l--){const h=1+l*.08,c=.12-l*.018,r=3+l*2;this.shieldAuraGraphics.lineStyle(r,16777215,c),this.shieldAuraGraphics.strokeEllipse(e,n,a*h,s*h)}this.shieldSparkleTimer+=t;const o=80;this.shieldSparkleTimer>=o&&(this.shieldSparkleTimer-=o,this.createShieldSparkle(e,n,a,s))}createShieldSparkle(t,e,i,a){const s=Math.random()*Math.PI*2,n=t+Math.cos(s)*(i/2),o=e+Math.sin(s)*(a/2),l=this.add.graphics();this.characterContainer.add(l);const h=this.gameBounds.height/10,c=h*.08,r=h*.2,d=h*.5,y=600+Math.random()*200,S=this.time.now,g=()=>{const p=this.time.now-S,M=Math.min(p/y,1);l.clear();const f=o-d*M,w=Math.pow(M,.5),C=c+(r-c)*w,x=1-M;x>.01&&(l.fillStyle(16768324,x*.9),l.fillRect(n-C/2,f-C/2,C,C),l.lineStyle(1,16777215,x*.6),l.strokeRect(n-C/2,f-C/2,C,C)),M>=1&&l.destroy()};g();const u=this.time.addEvent({delay:16,callback:g,callbackScope:this,repeat:Math.ceil(y/16)});this.time.delayedCall(y+50,()=>{l.active&&l.destroy(),u.remove()})}updateHpRegen(t){const e=this.skillManager.getTitaniumLiverRegenInterval();if(!(e<=0)){if(this.currentHp>=this.maxHp){this.hpRegenTimer=0;return}if(this.hpRegenTimer+=t,this.hpRegenTimer>=e){this.hpRegenTimer-=e;const i=Math.max(1,Math.floor(this.maxHp*.01));this.currentHp=Math.min(this.currentHp+i,this.maxHp),this.drawHpBarFill(),this.updateHpText(),this.updateLowHpVignette(),this.showHpHealEffect(i),console.log(`HP Regen: +${i} HP (${this.currentHp}/${this.maxHp})`)}}}showHpHealEffect(t){const e=this.characterX,i=this.characterY-this.characterSize*.3,a=Math.min(8,Math.max(3,Math.floor(t/10)+3));for(let s=0;s<a;s++)this.time.delayedCall(s*40,()=>{this.createHpHealParticle(e,i)})}createHpHealParticle(t,e){const i=Math.random()*Math.PI*2,a=this.characterSize*.4,s=this.characterSize*.25,n=t+Math.cos(i)*a*(.3+Math.random()*.7),o=e+Math.sin(i)*s*(.3+Math.random()*.7),l=this.add.graphics();this.characterContainer.add(l);const h=this.gameBounds.height/10,c=h*(.1+Math.random()*.08),r=h*(.5+Math.random()*.3),d=700+Math.random()*300,y=this.time.now,S=[6702335,8939263,7820782,10057727],g=S[Math.floor(Math.random()*S.length)],u=()=>{const M=this.time.now-y,f=Math.min(M/d,1);l.clear();const w=o-r*f;let C,x;if(f<.2?(C=.6+f*2,x=1-f*5):(C=1-(f-.2)/.8,x=0),C>.01){const b=g>>16&255,v=g>>8&255,P=g&255,T=Math.round(b+(255-b)*x),E=Math.round(v+(255-v)*x),I=Math.round(P+(255-P)*x),A=T<<16|E<<8|I;l.fillStyle(A,C*.9),l.fillRect(n-c/2,w-c/2,c,c),l.lineStyle(1,16777215,C*.7),l.strokeRect(n-c/2,w-c/2,c,c)}f>=1&&l.destroy()};u();const p=this.time.addEvent({delay:16,callback:u,callbackScope:this,repeat:Math.ceil(d/16)});this.time.delayedCall(d+50,()=>{l.active&&l.destroy(),p.remove()})}takeDamage(t,e=[]){let a=this.skillManager.calculateFinalDamageTaken(t),s=0;if(this.currentShield>0){const n=this.currentShield>0;if(this.currentShield>=a?(s=a,this.currentShield-=a,a=0):(s=this.currentShield,a-=this.currentShield,this.currentShield=0),n&&this.currentShield===0&&this.maxShield>0){const o=this.maxShield;this.currentHp=Math.min(this.currentHp+o,this.maxHp),console.log(`Shield broken! Healed ${o} HP, current HP: ${this.currentHp}/${this.maxHp}`),this.drawHpBarFill(),this.updateHpText(),this.updateLowHpVignette(),this.showHpHealEffect(o)}if(this.drawShieldBarFill(),s>0&&(this.showLegacySkillEffects&&this.flashShieldEffect(),this.flashShieldHitEffect()),this.shieldReflectDamage>0&&e.length>0){const o=e.map(h=>h.id),l=this.monsterManager.damageMonsters(o,this.shieldReflectDamage);l.totalExp>0&&this.addExp(l.totalExp),console.log(`Shield reflected ${this.shieldReflectDamage} damage to ${e.length} monsters, killed ${l.killCount}`)}}a>0?(this.currentHp-=a,this.currentHp<0&&(this.currentHp=0),this.hpDamageDelay=B.HP_DAMAGE_DELAY,this.drawHpBarFill(),this.updateHpText(),this.isHurt=!0,this.hurtEndTime=this.time.now+B.HURT_DURATION,this.isMoving=!1,this.isKeyboardMoving=!1,this.setCharacterState("hurt"),this.updateCharacterSprite(),this.flashCharacter(),this.updateLowHpVignette(),console.log(`Player took ${a} damage (${s} absorbed by shield), HP: ${this.currentHp}/${this.maxHp}`)):console.log(`Shield absorbed all ${s} damage, Shield: ${this.currentShield}`),this.currentHp<=0&&console.log("Player died!")}flashShieldEffect(){const t=this.add.graphics();this.worldContainer.add(t);const e=this.characterX,i=this.characterY-this.characterSize/2,a=this.characterSize*1,s=16768324,n=600;let o=this.time.now;const l=()=>{const c=this.time.now-o,r=Math.min(c/n,1);t.clear();const d=.3,S=1-(r<d?0:(r-d)/(1-d));if(S>.01){for(let p=6;p>=1;p--){const M=a*p/6,f=S*(1-(p-1)/6)*.5;f>.01&&(t.fillStyle(s,f),t.fillCircle(e,i,M))}const u=a*.4;t.fillStyle(16777215,S*.8),t.fillCircle(e,i,u),t.lineStyle(5,s,S*.9),t.strokeCircle(e,i,a),t.lineStyle(2,16777215,S*.7),t.strokeCircle(e,i,a*.95)}r>=1&&t.destroy()},h=this.time.addEvent({delay:16,callback:l,callbackScope:this,repeat:Math.ceil(n/16)});this.time.delayedCall(n+50,()=>{t.active&&t.destroy(),h.remove()})}flashShieldHitEffect(){const t=this.worldToScreen(this.characterX,this.characterY),e=t.x,i=t.y,a=B.SKILL_GRID_GAP,s=this.skillGridCellSize+a,n=16763904,o=this.gameBounds.height*.2,l=400,h=200,c=this.time.now,r=[],d=Math.max(0,Math.floor((e-o)/s)),y=Math.min(this.skillGridCols-1,Math.ceil((e+o)/s)),S=Math.max(0,Math.floor((i-o)/s)),g=Math.min(this.skillGridRows-1,Math.ceil((i+o)/s));for(let f=S;f<=g;f++)for(let w=d;w<=y;w++){const C=w*s+this.skillGridCellSize/2,x=f*s+this.skillGridCellSize/2,b=C-e,v=x-i,P=Math.sqrt(b*b+v*v);P<=o&&r.push({col:w,row:f,dist:P})}if(r.length===0)return;const u=[];for(const{col:f,row:w}of r){const C=f*s+this.skillGridCellSize/2,x=w*s+this.skillGridCellSize/2,b=this.add.rectangle(C,x,this.skillGridCellSize,this.skillGridCellSize,n,0);b.setVisible(!1),this.skillGridContainer.add(b),u.push(b)}const p=()=>{const f=this.time.now-c,w=Math.min(f/l,1),C=Math.min(f/h,1),x=o*C,b=o*.3,v=Math.max(0,x-b);let P=0;f>h&&(P=(f-h)/(l-h));let T=0;for(const{dist:E}of r){const I=u[T++];if(I)if(E>=v&&E<=x){const A=(v+x)/2,G=Math.abs(E-A),R=b/2,H=G/R,D=.9*(1-H*.5)*(1-P);if(D>.01){if(f<h&&H<.3){const X=n>>16&255,O=n>>8&255,L=n&255,Y=Math.min(255,X+Math.floor((255-X)*.5)),z=Math.min(255,O+Math.floor((255-O)*.5)),$=Math.min(255,L+Math.floor((255-L)*.5)),V=Y<<16|z<<8|$;I.setFillStyle(V,D)}else I.setFillStyle(n,D);I.setVisible(!0)}else I.setVisible(!1)}else I.setVisible(!1)}if(w>=1)for(const E of u)E.destroy()};p();const M=this.time.addEvent({delay:16,callback:p,callbackScope:this,repeat:Math.ceil(l/16)});this.time.delayedCall(l+50,()=>{M.remove();for(const f of u)f.active&&f.destroy()})}flashCharacter(){this.character.setTint(16777215),this.time.delayedCall(50,()=>{this.character.setTint(16724787)}),this.time.delayedCall(100,()=>{this.character.setTint(16777215)}),this.time.delayedCall(150,()=>{this.character.clearTint()})}shakeScreen(t){t<10||this.cameras.main.shake(100,.005)}createLowHpVignette(){console.log(`Vignette initialized (grid: ${this.skillGridCols}x${this.skillGridRows})`)}updateLowHpVignette(){const t=this.currentHp/this.maxHp;this.isLowHp=t<=.3,!this.isLowHp&&this.currentShield<=0&&this.clearVignetteCells()}clearVignetteCells(){for(const t of this.vignetteEdgeCells){const e=this.skillGridCells[t];e&&(e.setFillStyle(16777215,0),e.setVisible(!1))}this.vignetteEdgeCells.clear()}updateLowHpVignetteBreathing(t){if(!this.isLowHp&&this.currentShield<=0)return;this.lowHpBreathTimer+=t;const e=1500;this.lowHpBreathTimer>=e&&(this.lowHpBreathTimer-=e);const i=this.lowHpBreathTimer/e,a=Math.sin(i*Math.PI*2)*.5+.5;this.drawGridVignette(a)}drawGridVignette(t){const e=.2+t*.2;let i;this.currentShield>0?i=16768324:i=16720418;const a=this.skillGridCols/2,s=this.skillGridRows/2,n=this.skillGridCols/2*2,o=this.skillGridRows/2*2,l=2,h=this.skillGridRows-2;for(let c=l;c<h;c++)for(let r=0;r<this.skillGridCols;r++){const d=c*this.skillGridCols+r,y=this.skillGridCells[d];if(!y)continue;const S=(r-a)/n,g=(c-s)/o,u=Math.sqrt(S*S+g*g);if(u>.5){const p=Math.min(1,(u-.5)/.25),M=e*p;M>.01&&(y.setFillStyle(i,M),y.setVisible(!0),this.vignetteEdgeCells.add(d))}}}createExpBar(){this.expBarContainer=this.add.container(0,0),this.expBarContainer.setDepth(1002);const t=Math.max(B.MIN_FONT_SIZE_LARGE,Math.floor(this.gameBounds.height*.03)),e=this.skillGridCellSize,i=this.gameBounds.y+this.gameBounds.height-e*2;this.levelText=this.add.text(this.gameBounds.x+10,i-5,`Lv.${this.currentLevel}`,{fontFamily:"monospace",fontSize:`${t}px`,color:"#ffffff",fontStyle:"bold",stroke:"#000000",strokeThickness:3}),this.levelText.setOrigin(0,1),this.expBarContainer.add(this.levelText),this.uiContainer.add(this.expBarContainer)}drawExpBarFill(){const t=[this.skillGridRows-2,this.skillGridRows-1];for(const s of t)for(let n=0;n<this.skillGridCols;n++){const o=s*this.skillGridCols+n,l=this.skillGridCells[o];l&&(l.setFillStyle(0,.9),l.setVisible(!0),l.setDepth(1e3))}const e=this.currentExp/this.maxExp,i=this.skillGridCols,a=Math.floor(i*e);if(!(a<=0))for(const s of t)for(let n=0;n<a;n++){const o=s*this.skillGridCols+n,l=this.skillGridCells[o];if(!l)continue;const h=n/i,c=this.expBarFlowOffset,r=(h+c)%1,d=(Math.sin(r*Math.PI*2-Math.PI/2)+1)/2,y=Math.floor(68+68*d),S=Math.floor(136-68*d),u=y<<16|S<<8|255,p=s===this.skillGridRows-2?.95:.8;l.setFillStyle(u,p)}}updateExpBarFlow(t){this.expBarFlowOffset+=.2*t/1e3,this.expBarFlowOffset>=1&&(this.expBarFlowOffset-=1),this.drawExpBarFill()}drawFloorGrid(){this.floorGrid.clear();const t=this.gameBounds.height/10,e=Math.ceil(this.mapWidth/t),i=Math.ceil(this.mapHeight/t);for(let o=0;o<i;o++)for(let l=0;l<e;l++){const h=l*t,c=o*t;(o+l)%2===0?this.floorGrid.fillStyle(3355443,1):this.floorGrid.fillStyle(4473924,1),this.floorGrid.fillRect(h,c,t,t),this.floorGrid.lineStyle(1,5592405,.5),this.floorGrid.strokeRect(h,c,t,t)}this.floorGrid.lineStyle(4,16729156,1),this.floorGrid.strokeRect(0,0,this.mapWidth,this.mapHeight),this.floorGrid.lineStyle(2,16776960,1);const a=this.mapWidth/2,s=this.mapHeight/2,n=t;this.floorGrid.strokeRect(a-n/2,s-n/2,n,n);for(let o=0;o<i;o+=5)for(let l=0;l<e;l+=5){const h=l*t+t/2,c=o*t+t/2;this.floorGrid.fillStyle(6710886,1),this.floorGrid.fillCircle(h,c,4)}}createSkillBar(){const t=this.skillGridCellSize,e=B.SKILL_GRID_GAP,i=8,a=i*(t+e)-e,s=1,n=2,o=B.ACTIVE_SKILLS,l=B.PASSIVE_SKILLS,h=o*i+(o-1)*s,c=l*i+(l-1)*s,d=(h+n+c)*(t+e)-e,y=this.gameBounds.x+(this.gameBounds.width-d)/2,S=2*(t+e),g=t+e,u=this.gameBounds.y+this.gameBounds.height-S-a-g;let p=y;for(let M=0;M<o;M++){const f=p+a/2,w=u+a/2,C=this.add.container(f,w),x=this.add.rectangle(0,0,a,a);x.setStrokeStyle(0,16777215,0),x.setFillStyle(0,0),C.add(x);const b=this.add.rectangle(0,0,a-4,a-4,3355443,0);C.add(b);const v=Math.max(B.MIN_FONT_SIZE_SMALL,Math.floor(a*.2)),P=this.add.text(0,a*.3,"",{fontFamily:"monospace",fontSize:`${v}px`,color:"#ffffff",fontStyle:"bold",stroke:"#000000",strokeThickness:3});P.setOrigin(.5,.5),C.add(P),this.skillIcons.push(x),this.skillIconContainers.push(C),this.skillLevelTexts.push(P),C.setDepth(1002),this.uiContainer.add(C),this.drawSkillIconGrid(p,u,i,M),p+=a+s*(t+e)}p+=(n-s)*(t+e);for(let M=0;M<l;M++){const f=p+a/2,w=u+a/2,C=this.add.container(f,w),x=this.add.rectangle(0,0,a,a);x.setStrokeStyle(0,16777215,0),x.setFillStyle(0,0),C.add(x);const b=this.add.rectangle(0,0,a-4,a-4,3355443,0);C.add(b);const v=Math.max(B.MIN_FONT_SIZE_SMALL,Math.floor(a*.2)),P=this.add.text(0,a*.3,"",{fontFamily:"monospace",fontSize:`${v}px`,color:"#ffffff",fontStyle:"bold",stroke:"#000000",strokeThickness:3});P.setOrigin(.5,.5),C.add(P),this.skillIcons.push(x),this.skillIconContainers.push(C),this.skillLevelTexts.push(P),C.setDepth(1002),this.uiContainer.add(C),this.drawSkillIconGrid(p,u,i,o+M),p+=a+s*(t+e)}this.createSkillInfoPanel(),this.setupSkillIconInteractions()}drawSkillIconGrid(t,e,i,a){const s=this.add.graphics();s.setDepth(1001),this.uiContainer.add(s),this.skillIconGridData[a]={startX:t,startY:e,gridSize:i},this.redrawSkillIconGrid(a,0),this.skillIconGridGraphics[a]=s}redrawSkillIconGrid(t,e){const i=this.skillIconGridGraphics[t],a=this.skillIconGridData[t];if(!i||!a)return;i.clear();const s=this.skillGridCellSize,n=B.SKILL_GRID_GAP,{startX:o,startY:l,gridSize:h}=a,c=B.ACTIVE_SKILLS,r=t<c,d=r?this.skillManager.getPlayerActiveSkills():this.skillManager.getPlayerPassiveSkills(),y=r?t:t-c;if(!d[y]){i.fillStyle(0,.5);for(let f=0;f<h;f++)for(let w=0;w<h;w++){const C=o+w*(s+n),x=l+f*(s+n);i.fillRect(C,x,s,s)}return}const g=[],u=Math.floor(h/2);for(let f=u;f<h;f++)g.push({row:0,col:f});for(let f=1;f<h;f++)g.push({row:f,col:h-1});for(let f=h-2;f>=0;f--)g.push({row:h-1,col:f});for(let f=h-2;f>=1;f--)g.push({row:f,col:0});g.push({row:0,col:0});for(let f=1;f<u;f++)g.push({row:0,col:f});const p=g.length,M=Math.floor(p*e);for(let f=0;f<p;f++){const{row:w,col:C}=g[f],x=o+C*(s+n),b=l+w*(s+n);if(f<M){const v=this.getSkillColorForIndex(t);i.fillStyle(v,.4)}else i.fillStyle(0,.5);i.fillRect(x,b,s,s)}}getSkillColorForIndex(t){const e=B.ACTIVE_SKILLS,i=t<e,a=i?this.skillManager.getPlayerActiveSkills():this.skillManager.getPlayerPassiveSkills(),s=i?t:t-e,n=a[s];return n?n.definition.color:6710886}updateSkillCooldownDisplay(){const t=this.time.now,e=this.skillManager.getPlayerActiveSkills();for(let s=0;s<e.length;s++){const n=e[s];if(!n){this.redrawSkillIconGrid(s,0);continue}const o=n.definition;let l=o.cooldown||1e3;o.id==="active_architect"&&(l=l-n.level*500);const h=this.skillManager.calculateFinalCooldown(l),c=this.skillCooldowns.get(o.id)||0,r=t-c;if(r>=h)this.redrawSkillIconGrid(s,1);else{const d=r/h;this.redrawSkillIconGrid(s,d)}}const i=this.skillManager.getPlayerPassiveSkills(),a=B.ACTIVE_SKILLS;for(let s=0;s<i.length;s++){const n=i[s];if(!n){this.redrawSkillIconGrid(a+s,0);continue}const o=n.definition;let l=1;switch(o.id){case"passive_titanium_liver":{const h=this.skillManager.getTitaniumLiverRegenInterval();h>0&&this.currentHp<this.maxHp&&(l=this.hpRegenTimer/h);break}}this.redrawSkillIconGrid(a+s,l)}}createSkillInfoPanel(){const t=this.gameBounds,e=200,i=80,a=10,s=t.x+a,n=t.y+t.height-i-a-60;this.skillInfoPanel=this.add.container(s,n),this.skillInfoPanel.setDepth(1003),this.skillInfoBg=this.add.rectangle(0,0,e,i,0,.7),this.skillInfoBg.setOrigin(0,0),this.skillInfoBg.setStrokeStyle(1,6710886),this.skillInfoPanel.add(this.skillInfoBg),this.skillInfoText=this.add.text(a,a,"",{fontFamily:"monospace",fontSize:"12px",color:"#ffffff",wordWrap:{width:e-a*2}}),this.skillInfoPanel.add(this.skillInfoText),this.skillInfoPanel.setVisible(!1),this.uiContainer.add(this.skillInfoPanel)}setupSkillIconInteractions(){const t=B.ACTIVE_SKILLS;for(let e=0;e<this.skillIconContainers.length;e++){const i=this.skillIconContainers[e],a=e<t,s=a?e:e-t;i.setSize(i.getBounds().width,i.getBounds().height),i.setInteractive({useHandCursor:!0}),i.on("pointerdown",()=>{this.showSkillInfo(a,s)})}}showSkillInfo(t,e){const a=(t?this.skillManager.getPlayerActiveSkills():this.skillManager.getPlayerPassiveSkills())[e];if(!a){this.skillInfoPanel.setVisible(!1);return}const s=[];s.push(`【${a.definition.name}】${nt.formatLevel(a.level,a.definition.maxLevel)}`),t?this.appendActiveSkillInfo(s,a):this.appendPassiveSkillInfo(s,a),this.skillInfoText.setText(s.join(`
`));const n=this.skillInfoText.getBounds(),o=10;this.skillInfoBg.setSize(Math.max(180,n.width+o*2),n.height+o*2),this.skillInfoPanel.setVisible(!0),this.skillInfoHideTimer&&this.skillInfoHideTimer.destroy(),this.skillInfoHideTimer=this.time.delayedCall(3e3,()=>{this.skillInfoPanel.setVisible(!1)})}appendActiveSkillInfo(t,e){const i=e.level,a=this.skillManager.getAiEnhancementDamageBonus(),s=this.skillManager.getSyncRateCooldownReduction();switch(e.definition.id){case"active_soul_render":{const n=60+i*10,o=2+i,l=B.DAMAGE_UNIT*o,h=Math.floor(l*(1+a)),r=((e.definition.cooldown||1e3)*(1-s)/1e3).toFixed(1);t.push(`扇形角度: ${n}°`),t.push(`傷害: ${h}`),t.push(`冷卻: ${r}s`);break}case"active_coder":{const n=2+i*.5,o=1+i,l=B.DAMAGE_UNIT*o,h=Math.floor(l*(1+a)),r=((e.definition.cooldown||1500)*(1-s)/1e3).toFixed(1);t.push(`範圍: ${n} 單位`),t.push(`傷害: ${h}`),t.push(`冷卻: ${r}s`);break}case"active_vfx":{const n=i+1,o=1+i,l=B.DAMAGE_UNIT*o,h=Math.floor(l*(1+a)),r=((e.definition.cooldown||2500)*(1-s)/1e3).toFixed(1);t.push(`光束數: ${n} 道`),t.push(`傷害: ${h}`),t.push(`冷卻: ${r}s`);break}case"active_architect":{const o=Math.floor(this.maxHp*.3),l=1+i*1.5,h=B.DAMAGE_UNIT*l,r=((e.definition.cooldown||1e4)*(1-s)/1e3).toFixed(1);t.push(`護盾: ${o} (霸體)`),t.push(`反傷: ${h}`),t.push(`回血: ${o}`),t.push(`冷卻: ${r}s`);break}}this.appendMaxExtraAbility(t,e)}appendMaxExtraAbility(t,e){const i=this.skillManager.getMaxExtraAbilityText(e.definition.id,this.currentLevel);i&&(t.push(""),t.push(i))}appendPassiveSkillInfo(t,e){switch(e.definition.id){case"passive_titanium_liver":{const i=this.skillManager.getTitaniumLiverHpBonus(),a=this.skillManager.getTitaniumLiverRegenInterval()/1e3,s=this.skillManager.getTitaniumLiverExtraRegen(this.currentLevel),n=1+Math.round(s*100);t.push(`HP 加成: +${Math.round(i*100)}%`),t.push(`最大 HP: ${this.maxHp}`),t.push(`回復: 每 ${a} 秒 +${n}% HP`);break}case"passive_sync_rate":{const i=this.skillManager.getSyncRateSpeedBonus(),a=this.skillManager.getSyncRateCooldownReduction();t.push(`移速加成: +${Math.round(i*100)}%`),t.push(`冷卻減少: -${Math.round(a*100)}%`);break}case"passive_retina_module":{const i=this.skillManager.getRetinaModuleExpBonus();t.push(`經驗加成: +${Math.round(i*100)}%`);break}case"passive_ai_enhancement":{const i=this.skillManager.getAiEnhancementDamageBonus(),a=this.skillManager.getAiEnhancementDefenseBonus();t.push(`攻擊加成: +${Math.round(i*100)}%`),t.push(`防禦加成: +${Math.round(a*100)}%`);break}}this.appendMaxExtraAbility(t,e)}updateSkillBarDisplay(){const t=this.skillManager.getPlayerActiveSkills(),e=this.skillManager.getPlayerPassiveSkills(),i=[...t,...e];for(let a=0;a<this.skillIconContainers.length;a++){const s=this.skillIconContainers[a],n=this.skillLevelTexts[a],o=i[a],l=s.list[1];o?(l.setFillStyle(o.definition.color,.5),n.setText(nt.formatLevel(o.level,o.definition.maxLevel))):(l.setFillStyle(3355443,0),n.setText(""))}}createCharacterAnimations(){this.anims.create({key:"char_idle",frames:[{key:"char_idle_1"},{key:"char_idle_2"}],frameRate:2,repeat:-1}),this.anims.create({key:"char_run",frames:[{key:"char_run_1"},{key:"char_run_2"}],frameRate:8,repeat:-1}),this.anims.create({key:"char_attack",frames:[{key:"char_attack_1"},{key:"char_attack_2"}],frameRate:8,repeat:0}),this.anims.create({key:"char_hurt",frames:[{key:"char_hurt"}],frameRate:2,repeat:0})}updateCharacterSprite(){this.character.setPosition(this.characterX,this.characterY),this.character.setScale((this.facingRight?1:-1)*(this.characterSize/this.character.height),this.characterSize/this.character.height)}setCharacterState(t,e=!1){this.characterState!==t&&(this.isHurt&&!e&&t!=="hurt"||this.isAttacking&&!e&&t!=="hurt"||(this.characterState=t,this.character.play(`char_${t}`)))}updateCharacterFacing(t){t>this.characterX?this.facingRight=!0:t<this.characterX&&(this.facingRight=!1)}createSkillPanel(){this.skillPanelContainer=this.add.container(0,0),this.skillPanelContainer.setVisible(!1),this.uiContainer.add(this.skillPanelContainer);const t=this.add.rectangle(this.gameBounds.x+this.gameBounds.width/2,this.gameBounds.y+this.gameBounds.height/2,this.gameBounds.width,this.gameBounds.height,0,.8);t.setInteractive(),this.skillPanelContainer.add(t);const e=this.gameBounds.y+this.gameBounds.height*.12,i=this.add.text(this.gameBounds.x+this.gameBounds.width/2,e,"選擇技能",{fontFamily:"Microsoft JhengHei, PingFang TC, sans-serif",fontSize:`${Math.max(B.MIN_FONT_SIZE_LARGE,Math.floor(this.gameBounds.height*.07))}px`,color:"#ffffff",fontStyle:"bold"});i.setOrigin(.5,.5),this.skillPanelContainer.add(i);const a=e+this.gameBounds.height*.06,s=this.add.text(this.gameBounds.x+this.gameBounds.width/2,a,"提升你的數位能力",{fontFamily:"Microsoft JhengHei, PingFang TC, sans-serif",fontSize:`${Math.max(B.MIN_FONT_SIZE_SMALL,Math.floor(this.gameBounds.height*.025))}px`,color:"#cccccc"});s.setOrigin(.5,.5),this.skillPanelContainer.add(s),this.createSkillOptions();const n=this.gameBounds.y+this.gameBounds.height*.92,o=this.isMobile?"點兩次確認":"重複按同一鍵確認",l=this.add.text(this.gameBounds.x+this.gameBounds.width/2,n,o,{fontFamily:"Microsoft JhengHei, PingFang TC, sans-serif",fontSize:`${Math.max(B.MIN_FONT_SIZE_SMALL,Math.floor(this.gameBounds.height*.022))}px`,color:"#888888"});l.setOrigin(.5,.5),this.skillPanelContainer.add(l)}createSkillCutIn(){this.skillCutInContainer=this.add.container(0,0),this.skillCutInContainer.setVisible(!1),this.skillCutInContainer.setDepth(1e3),this.uiContainer.add(this.skillCutInContainer)}showSkillCutIn(t,e){this.skillCutInContainer.removeAll(!0);const i=this.gameBounds.height*.12,a=this.gameBounds.y+this.gameBounds.height*.25,s=this.gameBounds.width*.15,n=this.gameBounds.width-s*2,o=this.add.rectangle(this.gameBounds.x+this.gameBounds.width/2,a,n,i,0,.75);this.skillCutInContainer.add(o);const l=this.add.graphics(),h=this.gameBounds.x,c=this.gameBounds.x+s,r=20;for(let v=0;v<r;v++){const P=v/r*.75,T=h+s/r*v,E=s/r+1;l.fillStyle(0,P),l.fillRect(T,a-i/2,E,i)}this.skillCutInContainer.add(l);const d=this.add.graphics(),y=this.gameBounds.x+this.gameBounds.width-s;for(let v=0;v<r;v++){const P=(1-v/r)*.75,T=y+s/r*v,E=s/r+1;d.fillStyle(0,P),d.fillRect(T,a-i/2,E,i)}this.skillCutInContainer.add(d);const S=3,g=this.add.graphics(),u=a-i/2-S/2;for(let v=0;v<r;v++){const P=v/r*.8,T=h+s/r*v,E=s/r+1;g.fillStyle(t.color,P),g.fillRect(T,u,E,S)}g.fillStyle(t.color,.8),g.fillRect(c,u,n,S);for(let v=0;v<r;v++){const P=(1-v/r)*.8,T=y+s/r*v,E=s/r+1;g.fillStyle(t.color,P),g.fillRect(T,u,E,S)}this.skillCutInContainer.add(g);const p=this.add.graphics(),M=a+i/2-S/2;for(let v=0;v<r;v++){const P=v/r*.8,T=h+s/r*v,E=s/r+1;p.fillStyle(t.color,P),p.fillRect(T,M,E,S)}p.fillStyle(t.color,.8),p.fillRect(c,M,n,S);for(let v=0;v<r;v++){const P=(1-v/r)*.8,T=y+s/r*v,E=s/r+1;p.fillStyle(t.color,P),p.fillRect(T,M,E,S)}this.skillCutInContainer.add(p);const f=e>=t.maxLevel?"MAX":`Lv.${e}`,w=`${t.name} 提升到 ${f}`,C=this.add.text(this.gameBounds.x+this.gameBounds.width/2,a-i*.18,w,{fontFamily:"Microsoft JhengHei, PingFang TC, sans-serif",fontSize:`${Math.max(B.MIN_FONT_SIZE_LARGE,Math.floor(i*.35))}px`,color:"#ffffff",fontStyle:"bold"});C.setOrigin(.5,.5),this.skillCutInContainer.add(C);let x=t.description;t.levelUpMessages&&t.levelUpMessages[e]&&(x=t.levelUpMessages[e]);const b=this.add.text(this.gameBounds.x+this.gameBounds.width/2,a+i*.22,x,{fontFamily:"Microsoft JhengHei, PingFang TC, sans-serif",fontSize:`${Math.max(B.MIN_FONT_SIZE_MEDIUM,Math.floor(i*.22))}px`,color:_.Display.Color.IntegerToColor(t.color).rgba});b.setOrigin(.5,.5),this.skillCutInContainer.add(b),this.skillCutInContainer.setX(-this.gameBounds.width),this.skillCutInContainer.setVisible(!0),this.skillCutInContainer.setAlpha(1),this.tweens.add({targets:this.skillCutInContainer,x:0,duration:250,ease:"Power2.easeOut",onComplete:()=>{this.time.delayedCall(1500,()=>{this.tweens.add({targets:this.skillCutInContainer,x:this.gameBounds.width,duration:250,ease:"Power2.easeIn",onComplete:()=>{this.skillCutInContainer.setVisible(!1),this.skillCutInContainer.setX(0)}})})}})}createSkillOptions(){if(this.skillOptions.forEach(h=>h.destroy()),this.skillOptions=[],this.skillCardBgs=[],this.currentSkillChoices=this.skillManager.getRandomSkillOptions(),this.currentSkillChoices.length===0)return;const t=this.gameBounds.width*.25,e=this.gameBounds.height*(this.isMobile?.55:.5),i=this.gameBounds.width*.05,a=this.currentSkillChoices.length,s=t*a+i*(a-1),n=this.gameBounds.x+(this.gameBounds.width-s)/2+t/2,o=this.gameBounds.y+this.gameBounds.height*.55,l=["A","S","D"];for(let h=0;h<this.currentSkillChoices.length;h++){const c=this.currentSkillChoices[h],r=this.skillManager.getSkillLevel(c.id),d=r<0,y=d?"-":r,S=d?0:r+1,g=n+h*(t+i),u=this.add.container(g,o),p=this.add.rectangle(0,0,t,e,2236962);p.setStrokeStyle(2,6710886),u.add(p);const M=this.add.text(0,-e*.42,c.type==="active"?"ACTIVE":"PASSIVE",{fontFamily:"monospace",fontSize:`${Math.max(B.MIN_FONT_SIZE_SMALL,Math.floor(e*.045))}px`,color:c.type==="active"?"#ff6666":"#66ffff",fontStyle:"bold"});M.setOrigin(.5,.5),u.add(M);const f=t*.5,w=-e*.18,C=this.add.rectangle(0,w,f,f,c.color,.3);C.setStrokeStyle(2,c.color),u.add(C);const x=e*.06,b=this.add.text(0,x,c.name,{fontFamily:"Microsoft JhengHei, PingFang TC, sans-serif",fontSize:`${Math.max(B.MIN_FONT_SIZE_MEDIUM,Math.floor(e*.08))}px`,color:"#ffffff",fontStyle:"bold"});if(b.setOrigin(.5,.5),u.add(b),c.subtitle){const A=this.add.text(0,e*.12,c.subtitle,{fontFamily:"Microsoft JhengHei, PingFang TC, sans-serif",fontSize:`${Math.max(B.MIN_FONT_SIZE_SMALL,Math.floor(e*.04))}px`,color:"#999999"});A.setOrigin(.5,.5),u.add(A)}let v;S>=c.maxLevel?v=`Lv.${y} → MAX`:d?v=`NEW → Lv.${S}`:v=`Lv.${y} → Lv.${S}`;const P=this.add.text(0,e*.2,v,{fontFamily:"monospace",fontSize:`${Math.max(B.MIN_FONT_SIZE_SMALL,Math.floor(e*.05))}px`,color:S>=c.maxLevel?"#ffff00":"#88ff88",fontStyle:"bold"});P.setOrigin(.5,.5),u.add(P);const T=this.isMobile?e*.36:e*.32,E=this.add.text(0,T,c.description,{fontFamily:"Microsoft JhengHei, PingFang TC, sans-serif",fontSize:`${Math.max(B.MIN_FONT_SIZE_SMALL,Math.floor(e*.04))}px`,color:"#dddddd",wordWrap:{width:t*.85},align:"center"});if(E.setOrigin(.5,.5),u.add(E),!this.isMobile){const A=this.add.text(0,e*.42,`[ ${l[h]} ]`,{fontFamily:"monospace",fontSize:`${Math.max(B.MIN_FONT_SIZE_MEDIUM,Math.floor(e*.06))}px`,color:"#ffff00",fontStyle:"bold"});A.setOrigin(.5,.5),u.add(A)}p.setInteractive({useHandCursor:!0});const I=h;p.on("pointerover",()=>{this.setSelectedSkill(I)}),p.on("pointerdown",()=>{this.isMobile?this.selectedSkillIndex===I?this.confirmSkillSelection():this.setSelectedSkill(I):(this.setSelectedSkill(I),this.confirmSkillSelection())}),this.skillPanelContainer.add(u),this.skillOptions.push(u),this.skillCardBgs.push(p)}this.selectedSkillIndex=0}showSkillPanel(){if(!this.skillManager.hasUpgradeableSkills()){console.log("All skills are maxed out! Continue leveling for HP growth.");return}this.createSkillOptions(),this.currentSkillChoices.length!==0&&(this.isPaused=!0,this.isMoving=!1,this.skillPanelContainer.setVisible(!0),this.selectedSkillIndex=0,this.skillCardBgs.forEach((t,e)=>{e===0?(t.setFillStyle(3355443),t.setStrokeStyle(3,16777215)):(t.setFillStyle(2236962),t.setStrokeStyle(2,6710886))}),this.skillPanelContainer.setAlpha(0),this.tweens.add({targets:this.skillPanelContainer,alpha:1,duration:200}),this.skillOptions.forEach((t,e)=>{t.setScale(e===0?1.05:1),t.setY(this.gameBounds.y+this.gameBounds.height*.55+50),t.setAlpha(0),this.tweens.add({targets:t,y:this.gameBounds.y+this.gameBounds.height*.55,alpha:1,duration:300,delay:e*100,ease:"Back.easeOut"})}))}hideSkillPanel(){this.tweens.add({targets:this.skillPanelContainer,alpha:0,duration:200,onComplete:()=>{this.skillPanelContainer.setVisible(!1),this.isPaused=!1}})}selectSkill(t,e){const i=this.currentSkillChoices[t];if(!this.skillManager.learnOrUpgradeSkill(e)){console.warn(`Failed to learn/upgrade skill: ${e}`);return}const s=this.skillManager.getPlayerSkill(e),n=(s==null?void 0:s.level)??0;console.log(`Skill upgraded: ${e} -> Lv.${n}`),this.updateSkillBarDisplay(),(s==null?void 0:s.definition.type)==="passive"&&(this.recalculateMaxHp(),this.recalculateMoveSpeed(),this.drawHpBarFill(),this.updateHpText(),console.log(`Passive skill effect applied. MaxHP: ${this.maxHp}, MoveSpeed: ${this.moveSpeed}`));const o=this.skillOptions[t];this.tweens.add({targets:o,scaleX:1.1,scaleY:1.1,duration:100,yoyo:!0,onComplete:()=>{this.hideSkillPanel(),this.showSkillCutIn(i,n)}})}createSkillGrid(){const t=this.cameras.main.width,e=1920,i=20/this.gridScaleMultiplier,a=6/this.gridScaleMultiplier,s=Math.min(1,t/e);this.skillGridCellSize=Math.max(a,Math.floor(i*s));const n=B.SKILL_GRID_GAP;this.skillGridCols=Math.ceil((this.gameBounds.width+n)/(this.skillGridCellSize+n)),this.skillGridRows=Math.ceil((this.gameBounds.height+n)/(this.skillGridCellSize+n)),this.skillGridContainer=this.add.container(this.gameBounds.x,this.gameBounds.y),this.skillGridContainer.setDepth(50);for(let o=0;o<this.skillGridRows;o++)for(let l=0;l<this.skillGridCols;l++){const h=l*(this.skillGridCellSize+n)+this.skillGridCellSize/2,c=o*(this.skillGridCellSize+n)+this.skillGridCellSize/2,r=this.add.rectangle(h,c,this.skillGridCellSize,this.skillGridCellSize,16777215,0);r.setVisible(!1),this.skillGridCells.push(r),this.skillGridContainer.add(r)}this.uiContainer.addAt(this.skillGridContainer,0)}recreateSkillGrid(){this.skillGridCells.forEach(t=>t.destroy()),this.skillGridCells=[],this.skillGridContainer&&this.skillGridContainer.destroy(),this.createSkillGrid(),this.recreateSkillBar(),this.bringUIToTop()}bringUIToTop(){this.characterContainer&&this.uiContainer.bringToTop(this.characterContainer),this.hpBarContainer&&this.uiContainer.bringToTop(this.hpBarContainer),this.shieldText&&this.uiContainer.bringToTop(this.shieldText),this.expBarContainer&&this.uiContainer.bringToTop(this.expBarContainer),this.skillIconContainers.forEach(t=>{this.uiContainer.bringToTop(t)}),this.skillIconGridGraphics.forEach(t=>{this.uiContainer.bringToTop(t)}),this.skillInfoPanel&&this.uiContainer.bringToTop(this.skillInfoPanel),this.skillPanelContainer&&this.uiContainer.bringToTop(this.skillPanelContainer)}recreateSkillBar(){this.skillIcons.forEach(t=>t.destroy()),this.skillIcons=[],this.skillIconContainers.forEach(t=>t.destroy()),this.skillIconContainers=[],this.skillLevelTexts.forEach(t=>t.destroy()),this.skillLevelTexts=[],this.skillIconGridGraphics.forEach(t=>t.destroy()),this.skillIconGridGraphics=[],this.skillIconGridData=[],this.skillInfoPanel&&this.skillInfoPanel.destroy(),this.createSkillBar()}worldToScreen(t,e){return{x:t-this.cameraOffsetX,y:e-this.cameraOffsetY}}showSkillRangeCircle(t,e,i,a,s=.3){const n=this.worldToScreen(t,e),o=n.x,l=n.y,h=B.SKILL_GRID_GAP,c=this.skillGridCellSize+h,r=Math.max(0,Math.floor((o-i)/c)),d=Math.min(this.skillGridCols-1,Math.ceil((o+i)/c)),y=Math.max(0,Math.floor((l-i)/c)),S=Math.min(this.skillGridRows-1,Math.ceil((l+i)/c));for(let g=y;g<=S;g++)for(let u=r;u<=d;u++){const p=u*c+this.skillGridCellSize/2,M=g*c+this.skillGridCellSize/2,f=p-o,w=M-l;if(Math.sqrt(f*f+w*w)<=i){const x=g*this.skillGridCols+u,b=this.skillGridCells[x];b&&(b.setFillStyle(a,s),b.setVisible(!0))}}}showSkillRangeSector(t,e,i,a,s,n,o=.3){const l=this.worldToScreen(t,e),h=l.x,c=l.y,r=B.SKILL_GRID_GAP,d=this.skillGridCellSize+r,y=Math.max(0,Math.floor((h-i)/d)),S=Math.min(this.skillGridCols-1,Math.ceil((h+i)/d)),g=Math.max(0,Math.floor((c-i)/d)),u=Math.min(this.skillGridRows-1,Math.ceil((c+i)/d));for(let p=g;p<=u;p++)for(let M=y;M<=S;M++){const f=M*d+this.skillGridCellSize/2,w=p*d+this.skillGridCellSize/2,C=f-h,x=w-c,b=Math.sqrt(C*C+x*x);if(b<=i&&b>0){const v=Math.atan2(x,C);let P=Math.abs(v-a);if(P>Math.PI&&(P=2*Math.PI-P),P<=s){const T=p*this.skillGridCols+M,E=this.skillGridCells[T];E&&(E.setFillStyle(n,o),E.setVisible(!0))}}}}showSkillRangeLine(t,e,i,a,s,n,o=.3){const l=this.worldToScreen(t,e),h=this.worldToScreen(i,a),c=B.SKILL_GRID_GAP,r=this.skillGridCellSize+c,d=h.x-l.x,y=h.y-l.y,S=Math.sqrt(d*d+y*y);if(S===0)return;const g=d/S,u=y/S,p=-u,M=g,f=s/2,w=[{x:l.x+p*f,y:l.y+M*f},{x:l.x-p*f,y:l.y-M*f},{x:h.x+p*f,y:h.y+M*f},{x:h.x-p*f,y:h.y-M*f}],C=Math.min(...w.map(A=>A.x)),x=Math.max(...w.map(A=>A.x)),b=Math.min(...w.map(A=>A.y)),v=Math.max(...w.map(A=>A.y)),P=Math.max(0,Math.floor(C/r)),T=Math.min(this.skillGridCols-1,Math.ceil(x/r)),E=Math.max(0,Math.floor(b/r)),I=Math.min(this.skillGridRows-1,Math.ceil(v/r));for(let A=E;A<=I;A++)for(let G=P;G<=T;G++){const R=G*r+this.skillGridCellSize/2,H=A*r+this.skillGridCellSize/2,F=Math.max(0,Math.min(1,((R-l.x)*g+(H-l.y)*u)/S)),D=l.x+F*d,X=l.y+F*y;if(Math.sqrt((R-D)**2+(H-X)**2)<=f){const L=A*this.skillGridCols+G,Y=this.skillGridCells[L];Y&&(Y.setFillStyle(n,o),Y.setVisible(!0))}}}clearSkillGrid(){this.skillGridCells.forEach((t,e)=>{if(this.vignetteEdgeCells.has(e)&&(this.isLowHp||this.currentShield>0))return;const i=Math.floor(e/this.skillGridCols);i<2||i>=this.skillGridRows-2||t.setVisible(!1)})}flashGridAt(t,e,i,a=1){const s=this.worldToScreen(t,e),n=B.SKILL_GRID_GAP,o=this.skillGridCellSize+n,l=Math.floor(s.x/o),h=Math.floor(s.y/o),c=600,r=200,d=this.time.now,y=[];for(let u=-a;u<=a;u++)for(let p=-a;p<=a;p++){const M=l+p,f=h+u;if(M<0||M>=this.skillGridCols||f<0||f>=this.skillGridRows)continue;const w=Math.sqrt(u*u+p*p);if(w<=a){const C=f*this.skillGridCols+M,x=this.skillGridCells[C];x&&y.push({cell:x,dist:w})}}if(y.length===0)return;const S=()=>{const u=this.time.now-d,p=Math.min(u/c,1);let M=0;u>r&&(M=(u-r)/(c-r));for(const{cell:f,dist:w}of y){const C=w/Math.max(a,1),b=(1-C*.4)*(1-M);if(b>.01)if(u<r){const P=(1-C)*.5;if(f.setFillStyle(i,b),f.setVisible(!0),w<a*.5){const T=i>>16&255,E=i>>8&255,I=i&255,A=Math.min(255,T+Math.floor((255-T)*P)),G=Math.min(255,E+Math.floor((255-E)*P)),R=Math.min(255,I+Math.floor((255-I)*P)),H=A<<16|G<<8|R;f.setFillStyle(H,b)}}else f.setFillStyle(i,b),f.setVisible(!0);else f.setVisible(!1)}if(p>=1)for(const{cell:f}of y)f.setVisible(!1),f.setAlpha(1)};S();const g=this.time.addEvent({delay:16,callback:S,callbackScope:this,repeat:Math.ceil(c/16)});this.time.delayedCall(c+50,()=>{g.remove();for(const{cell:u}of y)u.setVisible(!1),u.setAlpha(1)})}flashGridAtPositions(t,e,i=1){t.forEach(a=>{this.flashGridAt(a.x,a.y,e,i)})}flashWhiteCrossAt(t,e){const i=this.worldToScreen(t,e),a=B.SKILL_GRID_GAP,s=this.skillGridCellSize+a,n=Math.floor(i.x/s),o=Math.floor(i.y/s),l=n*s+this.skillGridCellSize/2,h=o*s+this.skillGridCellSize/2,c=3,r=300,d=this.time.now,y=Math.random()<.5?1:-1,S=(Math.PI/9+Math.random()*Math.PI/6)*y,g=[];g.push({offsetX:0,offsetY:0,dist:0});const u=[{dc:1,dr:0},{dc:-1,dr:0},{dc:0,dr:1},{dc:0,dr:-1}];for(const{dc:w,dr:C}of u)for(let x=1;x<=c;x++)g.push({offsetX:w*x*s,offsetY:C*x*s,dist:x});if(g.length===0)return;const p=[];for(let w=0;w<g.length;w++){const C=this.add.rectangle(l,h,this.skillGridCellSize,this.skillGridCellSize,16777215,0);C.setVisible(!1),this.skillGridContainer.add(C),p.push(C)}const M=()=>{const w=this.time.now-d,C=Math.min(w/r,1),x=S*C,b=Math.cos(x),v=Math.sin(x),P=c*C;for(let T=0;T<g.length;T++){const{offsetX:E,offsetY:I,dist:A}=g[T],G=p[T];if(!G)continue;const R=l+E*b-I*v,H=h+E*v+I*b;if(G.setPosition(R,H),A>=P){const D=1-A/c*.5;let X=1;P>0&&A<P+1&&(X=A-P);const O=D*Math.max(0,X);O>.01?(G.setFillStyle(16777215,O),G.setVisible(!0)):G.setVisible(!1)}else G.setVisible(!1)}if(C>=1)for(const T of p)T.destroy()};M();const f=this.time.addEvent({delay:16,callback:M,callbackScope:this,repeat:Math.ceil(r/16)});this.time.delayedCall(r+50,()=>{f.remove();for(const w of p)w.active&&w.destroy()})}flashWhiteCrossAtPositions(t){t.forEach(e=>{this.flashWhiteCrossAt(e.x,e.y)})}flashDeathEffect(t,e){const i=this.worldToScreen(t,e),a=B.SKILL_GRID_GAP,s=this.skillGridCellSize+a,n=Math.floor(i.x/s),o=Math.floor(i.y/s),l=3,h=400,c=this.time.now,r=[];for(let M=0;M<l;M++){const f=Math.random()*Math.PI*2,w=2+Math.random()*2;r.push({col:n+Math.round(Math.cos(f)*w),row:o+Math.round(Math.sin(f)*w),radius:3+Math.floor(Math.random()*3)})}const d=new Map;for(const M of r){const f=M.radius;for(let w=-f;w<=f;w++)for(let C=-f;C<=f;C++){const x=Math.sqrt(w*w+C*C);if(x<=f){const b=M.col+C,v=M.row+w;if(b>=0&&b<this.skillGridCols&&v>=0&&v<this.skillGridRows){const P=`${b},${v}`,T=d.get(P);(!T||x<T.dist)&&d.set(P,{col:b,row:v,dist:x})}}}}const y=Array.from(d.values());if(y.length===0)return;const S=Math.max(...y.map(M=>M.dist)),g=[];for(const{col:M,row:f,dist:w}of y){const C=M*s+this.skillGridCellSize/2,x=f*s+this.skillGridCellSize/2,b=this.add.rectangle(C,x,this.skillGridCellSize,this.skillGridCellSize,16777215,0);b.setVisible(!1),this.skillGridContainer.add(b),g.push({rect:b,dist:w})}const u=()=>{const M=this.time.now-c,f=Math.min(M/h,1);for(const{rect:w,dist:C}of g){const x=C/(S+1),b=x+.5;let v=0;if(f>=x&&f<=b&&(f<x+.1?v=(f-x)/.1:v=1-(f-x-.1)/(b-x-.1),v=Math.max(0,Math.min(.8,v))),v>.01){const P=200+Math.floor(Math.random()*55),T=P<<16|P<<8|P;w.setFillStyle(T,v),w.setVisible(!0)}else w.setVisible(!1)}if(f>=1)for(const{rect:w}of g)w.destroy()};u();const p=this.time.addEvent({delay:16,callback:u,callbackScope:this,repeat:Math.ceil(h/16)});this.time.delayedCall(h+50,()=>{p.remove();for(const{rect:M}of g)M.active&&M.destroy()})}flashSkillAreaSector(t,e,i,a,s,n){const o=this.worldToScreen(t,e),l=o.x,h=o.y,c=B.SKILL_GRID_GAP,r=this.skillGridCellSize+c,d=500,y=150,S=150,g=this.time.now,u=[],p=Math.max(0,Math.floor((l-i)/r)),M=Math.min(this.skillGridCols-1,Math.ceil((l+i)/r)),f=Math.max(0,Math.floor((h-i)/r)),w=Math.min(this.skillGridRows-1,Math.ceil((h+i)/r));for(let v=f;v<=w;v++)for(let P=p;P<=M;P++){const T=P*r+this.skillGridCellSize/2,E=v*r+this.skillGridCellSize/2,I=T-l,A=E-h,G=Math.sqrt(I*I+A*A);if(G<=i&&G>0){const R=Math.atan2(A,I);let H=Math.abs(R-a);H>Math.PI&&(H=2*Math.PI-H),H<=s&&u.push({col:P,row:v,dist:G,angleDist:H})}}if(u.length===0)return;const C=[];for(const{col:v,row:P}of u){const T=v*r+this.skillGridCellSize/2,E=P*r+this.skillGridCellSize/2,I=this.add.rectangle(T,E,this.skillGridCellSize,this.skillGridCellSize,n,0);I.setVisible(!1),this.skillGridContainer.add(I),C.push(I)}const x=()=>{const v=this.time.now-g,P=Math.min(v/d,1),T=Math.min(v/y,1),E=i*T;let I=0;v>y+S&&(I=(v-y-S)/(d-y-S));const A=i*I;let G=0;for(const{dist:R,angleDist:H}of u){const F=C[G++];if(F)if(R<=E&&R>=A){const D=R/i,X=H/s,Y=Math.max(D,X),z=Math.max(0,Math.min(1,(Y-.3)/.7)),$=z*z*(3-2*z),V=.15+$*.6;let U=1;if(A>0){const N=i*.15;R<A+N&&(U=(R-A)/N)}const W=V*U;if(W>.01){const N=.5+$*.5,K=n>>16&255,q=n>>8&255,Q=n&255;let tt=K,j=q,et=Q;if(Y>.85&&v<y+S){const st=(Y-.85)/.15;tt=Math.min(255,K+Math.floor((255-K)*st*.3)),j=Math.min(255,q+Math.floor((255-q)*st*.3)),et=Math.min(255,Q+Math.floor((255-Q)*st*.3))}else tt=Math.floor(K*N),j=Math.floor(q*N),et=Math.floor(Q*N);const ot=tt<<16|j<<8|et;F.setFillStyle(ot,W),F.setVisible(!0)}else F.setVisible(!1)}else F.setVisible(!1)}if(P>=1)for(const R of C)R.destroy()};x();const b=this.time.addEvent({delay:16,callback:x,callbackScope:this,repeat:Math.ceil(d/16)});this.time.delayedCall(d+50,()=>{b.remove();for(const v of C)v.active&&v.destroy()})}flashSkillAreaCircle(t,e,i,a){const s=this.worldToScreen(t,e),n=s.x,o=s.y,l=B.SKILL_GRID_GAP,h=this.skillGridCellSize+l,c=500,r=150,d=150,y=this.time.now,S=[],g=Math.max(0,Math.floor((n-i)/h)),u=Math.min(this.skillGridCols-1,Math.ceil((n+i)/h)),p=Math.max(0,Math.floor((o-i)/h)),M=Math.min(this.skillGridRows-1,Math.ceil((o+i)/h));for(let x=p;x<=M;x++)for(let b=g;b<=u;b++){const v=b*h+this.skillGridCellSize/2,P=x*h+this.skillGridCellSize/2,T=v-n,E=P-o,I=Math.sqrt(T*T+E*E);I<=i&&S.push({col:b,row:x,dist:I})}if(S.length===0)return;const f=[];for(const{col:x,row:b}of S){const v=x*h+this.skillGridCellSize/2,P=b*h+this.skillGridCellSize/2,T=this.add.rectangle(v,P,this.skillGridCellSize,this.skillGridCellSize,a,0);T.setVisible(!1),this.skillGridContainer.add(T),f.push(T)}const w=()=>{const x=this.time.now-y,b=Math.min(x/c,1),v=Math.min(x/r,1),P=i*v;let T=0;x>r+d&&(T=(x-r-d)/(c-r-d));const E=i*T;let I=0;for(const{dist:A}of S){const G=f[I++];if(G)if(A<=P&&A>=E){const R=A/i,H=Math.max(0,Math.min(1,(R-.3)/.7)),F=H*H*(3-2*H),D=.15+F*.6;let X=1;if(E>0){const L=i*.15;A<E+L&&(X=(A-E)/L)}const O=D*X;if(O>.01){const L=.5+F*.5,Y=a>>16&255,z=a>>8&255,$=a&255;let V=Y,U=z,W=$;if(R>.85&&x<r+d){const K=(R-.85)/.15;V=Math.min(255,Y+Math.floor((255-Y)*K*.3)),U=Math.min(255,z+Math.floor((255-z)*K*.3)),W=Math.min(255,$+Math.floor((255-$)*K*.3))}else V=Math.floor(Y*L),U=Math.floor(z*L),W=Math.floor($*L);const N=V<<16|U<<8|W;G.setFillStyle(N,O),G.setVisible(!0)}else G.setVisible(!1)}else G.setVisible(!1)}if(b>=1)for(const A of f)A.destroy()};w();const C=this.time.addEvent({delay:16,callback:w,callbackScope:this,repeat:Math.ceil(c/16)});this.time.delayedCall(c+50,()=>{C.remove();for(const x of f)x.active&&x.destroy()})}flashSkillAreaLine(t,e,i,a,s,n){const o=this.worldToScreen(t,e),l=this.worldToScreen(i,a),h=B.SKILL_GRID_GAP,c=this.skillGridCellSize+h,r=l.x-o.x,d=l.y-o.y,y=Math.sqrt(r*r+d*d);if(y===0)return;const S=r/y,g=d/y,u=-g,p=S,M=s/2,f=800,w=80,C=300,x=f-w-C,b=this.time.now,v=[],P=[{x:o.x+u*M,y:o.y+p*M},{x:o.x-u*M,y:o.y-p*M},{x:l.x+u*M,y:l.y+p*M},{x:l.x-u*M,y:l.y-p*M}],T=Math.min(...P.map(L=>L.x)),E=Math.max(...P.map(L=>L.x)),I=Math.min(...P.map(L=>L.y)),A=Math.max(...P.map(L=>L.y)),G=Math.max(0,Math.floor(T/c)),R=Math.min(this.skillGridCols-1,Math.ceil(E/c)),H=Math.max(0,Math.floor(I/c)),F=Math.min(this.skillGridRows-1,Math.ceil(A/c));for(let L=H;L<=F;L++)for(let Y=G;Y<=R;Y++){const z=Y*c+this.skillGridCellSize/2,$=L*c+this.skillGridCellSize/2,V=z-o.x,U=$-o.y,W=V*S+U*g;if(W<0||W>y)continue;const N=o.x+S*W,K=o.y+g*W,q=Math.sqrt((z-N)**2+($-K)**2);q<=M&&v.push({col:Y,row:L,distAlong:W,distToLine:q})}if(v.length===0)return;const D=[];for(const{col:L,row:Y}of v){const z=L*c+this.skillGridCellSize/2,$=Y*c+this.skillGridCellSize/2,V=this.add.rectangle(z,$,this.skillGridCellSize,this.skillGridCellSize,n,0);V.setVisible(!1),this.skillGridContainer.add(V),D.push(V)}const X=()=>{const L=this.time.now-b,Y=Math.min(L/f,1),z=Math.min(L/w,1),$=y*z;let V=0;L>w+C&&(V=(L-w-C)/x);const U=y*V,W=1-V;let N=0;for(const{distAlong:K,distToLine:q}of v){const Q=D[N++];if(!Q)continue;const tt=M*W;if(K<=$&&K>=U&&q<=tt){const j=tt>0?q/tt:1,et=1-j*j;let ot=.2+et*.5;const st=K/y,ft=Math.min(1,st/.15),gt=Math.min(1,(1-st)/.15),ht=Math.min(ft,gt);ot*=ht*ht;let ct=1;if(U>0){const lt=y*.1;K<U+lt&&(ct=(K-U)/lt)}const Pt=ot*ct;if(Pt>.01){const lt=.6+et*.4,pt=n>>16&255,ut=n>>8&255,mt=n&255;let St,Mt,yt;if(j<.2&&L<w+C){const kt=1-j/.2;St=Math.min(255,pt+Math.floor((255-pt)*kt*.3)),Mt=Math.min(255,ut+Math.floor((255-ut)*kt*.3)),yt=Math.min(255,mt+Math.floor((255-mt)*kt*.3))}else St=Math.floor(pt*lt),Mt=Math.floor(ut*lt),yt=Math.floor(mt*lt);const Tt=St<<16|Mt<<8|yt;Q.setFillStyle(Tt,Pt),Q.setVisible(!0)}else Q.setVisible(!1)}else Q.setVisible(!1)}if(Y>=1)for(const K of D)K.destroy()};X();const O=this.time.addEvent({delay:16,callback:X,callbackScope:this,repeat:Math.ceil(f/16)});this.time.delayedCall(f+50,()=>{O.remove();for(const L of D)L.active&&L.destroy()})}};k(B,"MAP_SCALE",10),k(B,"ACTIVE_SKILLS",4),k(B,"PASSIVE_SKILLS",3),k(B,"CAMERA_DEAD_ZONE",.3),k(B,"HP_DAMAGE_DELAY",1e3),k(B,"HP_DAMAGE_LERP_SPEED",3),k(B,"MIN_FONT_SIZE_LARGE",14),k(B,"MIN_FONT_SIZE_MEDIUM",12),k(B,"MIN_FONT_SIZE_SMALL",10),k(B,"BASE_HP",200),k(B,"HP_PER_LEVEL",50),k(B,"BASE_EXP",100),k(B,"EXP_GROWTH_RATE",1.2),k(B,"DAMAGE_UNIT",10),k(B,"HURT_DURATION",200),k(B,"ATTACK_DURATION",150),k(B,"SKILL_GRID_GAP",1);let Ct=B;const Rt=7,Lt={0:{width:5,pixels:[" ### ","#   #","#  ##","# # #","##  #","#   #"," ### "]},1:{width:3,pixels:[" # ","## "," # "," # "," # "," # ","###"]},2:{width:5,pixels:[" ### ","#   #","    #","  ## "," #   ","#    ","#####"]},3:{width:5,pixels:[" ### ","#   #","    #","  ## ","    #","#   #"," ### "]},4:{width:5,pixels:["#   #","#   #","#   #","#####","    #","    #","    #"]},5:{width:5,pixels:["#####","#    ","#    ","#### ","    #","#   #"," ### "]},6:{width:5,pixels:[" ### ","#    ","#    ","#### ","#   #","#   #"," ### "]},7:{width:5,pixels:["#####","    #","   # ","  #  ","  #  ","  #  ","  #  "]},8:{width:5,pixels:[" ### ","#   #","#   #"," ### ","#   #","#   #"," ### "]},9:{width:5,pixels:[" ### ","#   #","#   #"," ####","    #","    #"," ### "]},A:{width:5,pixels:[" ### ","#   #","#   #","#####","#   #","#   #","#   #"]},D:{width:5,pixels:["#### ","#   #","#   #","#   #","#   #","#   #","#### "]},E:{width:4,pixels:["####","#   ","#   ","### ","#   ","#   ","####"]},G:{width:5,pixels:[" ### ","#    ","#    ","# ###","#   #","#   #"," ### "]},I:{width:3,pixels:["###"," # "," # "," # "," # "," # ","###"]},L:{width:4,pixels:["#   ","#   ","#   ","#   ","#   ","#   ","####"]},N:{width:5,pixels:["#   #","##  #","# # #","#  ##","#   #","#   #","#   #"]},O:{width:5,pixels:[" ### ","#   #","#   #","#   #","#   #","#   #"," ### "]},P:{width:4,pixels:["### ","#  #","#  #","### ","#   ","#   ","#   "]},R:{width:4,pixels:["### ","#  #","#  #","### ","# # ","#  #","#  #"]},S:{width:4,pixels:[" ###","#   ","#   "," ## ","   #","   #","### "]},T:{width:5,pixels:["#####","  #  ","  #  ","  #  ","  #  ","  #  ","  #  "]},"%":{width:5,pixels:["##  #","## # ","  #  "," #   "," # ##","#  ##","   ##"]}," ":{width:3,pixels:["   ","   ","   ","   ","   ","   ","   "]}},Ht={charHeight:Rt,chars:Lt};class Ft{constructor(){k(this,"font");this.font=Ht}textToPixels(m,t,e){const i=[],a=m.letterSpacing??1,s=m.color.replace("#",""),n=parseInt(s.substring(0,2),16),o=parseInt(s.substring(2,4),16),l=parseInt(s.substring(4,6),16),h=n<<16|o<<8|l;let c=0;const r=m.text.toUpperCase().split("");for(let p=0;p<r.length;p++){const M=this.font.chars[r[p]];M&&(c+=M.width,p<r.length-1&&(c+=a))}const d=Math.floor(t*m.position.x),y=Math.floor(e*m.position.y),S=d-Math.floor(c/2),g=y-Math.floor(this.font.charHeight/2);let u=S;for(const p of r){const M=this.font.chars[p];if(M){for(let f=0;f<M.pixels.length;f++){const w=M.pixels[f];for(let C=0;C<w.length;C++)if(w[C]==="#"){const x=u+C,b=g+f;x>=0&&x<t&&b>=0&&b<e&&i.push({gridX:x,gridY:b,color:h})}}u+=M.width+a}}return i}processConfig(m,t,e){const i=new Map;for(const a of m.texts){const s=this.textToPixels(a,t,e);i.set(a.id,s)}return i}}const _t=[{id:"title",text:"PRESS TO START",letterSpacing:2,position:{x:.5,y:.5},color:"#ffffff"}],Dt={texts:_t},at=class at extends _.Scene{constructor(){super("GridScene");k(this,"cells",[]);k(this,"cols",0);k(this,"rows",0);k(this,"cellWidth",10);k(this,"cellHeight",10);k(this,"gap",1);k(this,"isAnimating",!1);k(this,"isReady",!1);k(this,"textRenderer");k(this,"textPixels",new Map);k(this,"cursorGlowRadius",4);k(this,"glowPhase",0);k(this,"textBreathPhase",0);k(this,"isLoading",!0);k(this,"loadingCells",new Set);k(this,"backgroundImage");k(this,"titleBgm");this.textRenderer=new Ft}preload(){this.load.image("background","background.png"),this.load.image("char_idle_1","sprites/character/IDEL01.png"),this.load.image("char_idle_2","sprites/character/IDEL02.png"),this.load.image("char_run_1","sprites/character/RUN01.png"),this.load.image("char_run_2","sprites/character/RUN02.png"),this.load.image("char_attack_1","sprites/character/ATTACK01.png"),this.load.image("char_attack_2","sprites/character/ATTACK02.png"),this.load.image("char_hurt","sprites/character/HURT01.png"),this.load.audio("bgm_title","audio/BGM00.mp3"),this.load.audio("bgm_game_01","audio/BGM01.mp3"),this.load.audio("bgm_game_02","audio/BGM02.mp3"),this.load.on("progress",t=>{this.updateLoadingProgress(Math.floor(t*100))})}create(){this.cameras.main.setBackgroundColor("rgba(0,0,0,0)"),this.createBackground(),this.calculateGridSize(),this.createGrid(),this.showLoadingText(0),this.startEntryAnimation(),this.preloadGameAssets(),this.input.on("pointerdown",t=>{if(!this.isReady||this.isAnimating)return;const e=Math.floor(t.x/(this.cellWidth+this.gap)),i=Math.floor(t.y/(this.cellHeight+this.gap));this.startExitAnimation(e,i)}),this.input.on("pointermove",t=>{!this.isReady||this.isAnimating||this.updateCursorGlow(t.x,t.y)})}update(t,e){if(!this.isReady||this.isAnimating)return;this.glowPhase+=e*.002,this.textBreathPhase+=e*.004;const i=this.input.activePointer;i&&this.updateCursorGlow(i.x,i.y),this.updateTextBreath()}updateTextBreath(){const t=.5+.5*Math.sin(this.textBreathPhase),e=Math.floor(204+51*t),i=e<<16|e<<8|e,a=.5+.5*Math.sin(this.textBreathPhase*3),s=t>.6?a*.8:0,n=new Set;this.cells.forEach(o=>{o.isText&&n.add(`${o.x},${o.y}`)}),this.cells.forEach(o=>{if(o.isText)o.graphics.setFillStyle(i),o.graphics.setAlpha(.95);else{const l=`${o.x-1},${o.y-1}`;n.has(l)&&s>0&&(o.graphics.setFillStyle(8939263),o.graphics.setAlpha(s))}})}updateCursorGlow(t,e){const i=Math.floor(t/(this.cellWidth+this.gap)),a=Math.floor(e/(this.cellHeight+this.gap)),s=.3+.7*(.5+.5*Math.sin(this.glowPhase));this.cells.forEach(n=>{const o=n.x-i,l=n.y-a,h=Math.sqrt(o*o+l*l);if(h<=this.cursorGlowRadius){const r=(1-h/this.cursorGlowRadius)*s,d=n.originalColor>>16&255,y=n.originalColor>>8&255,S=n.originalColor&255,g=Math.min(255,Math.floor(d+(255-d)*r)),u=Math.min(255,Math.floor(y+(255-y)*r)),p=Math.min(255,Math.floor(S+(255-S)*r)),M=g<<16|u<<8|p;n.graphics.setFillStyle(M)}else n.graphics.setFillStyle(n.originalColor)})}createBackground(){const t=this.cameras.main.width,e=this.cameras.main.height;this.backgroundImage=this.add.image(t/2,e/2,"background");const i=t/this.backgroundImage.width,a=e/this.backgroundImage.height,s=Math.max(i,a);this.backgroundImage.setScale(s),this.backgroundImage.setDepth(-1)}showLoadingText(t){this.loadingCells.forEach(a=>{this.cells[a]&&(this.cells[a].originalColor=2236962,this.cells[a].isText=!1,this.cells[a].graphics.setFillStyle(2236962),this.cells[a].graphics.setAlpha(.2))}),this.loadingCells.clear();const e=`LOADING ${t}%`;this.textRenderer.textToPixels({id:"loading",text:e,letterSpacing:2,position:{x:.5,y:.5},color:"#ffffff"},this.cols,this.rows).forEach(a=>{const s=a.gridY*this.cols+a.gridX;this.cells[s]&&(this.cells[s].originalColor=a.color,this.cells[s].isText=!0,this.cells[s].graphics.setFillStyle(a.color),this.cells[s].graphics.setAlpha(.95),this.loadingCells.add(s))})}updateLoadingProgress(t){this.isLoading&&this.showLoadingText(t)}preloadGameAssets(){let t=0;const e=this.time.addEvent({delay:50,callback:()=>{t+=Math.random()*15,t>=100&&(t=100,e.destroy(),this.onLoadingComplete()),this.showLoadingText(Math.floor(t))},loop:!0})}onLoadingComplete(){this.isLoading=!1,this.time.delayedCall(500,()=>{this.cells.forEach(t=>{t.originalColor=2236962,t.isText=!1,t.graphics.setFillStyle(2236962),t.graphics.setAlpha(.2)}),this.loadingCells.clear(),this.time.delayedCall(300,()=>{this.processTextConfig(),this.textPixels.forEach(t=>{t.forEach(e=>{const i=e.gridY*this.cols+e.gridX;this.cells[i]&&(this.cells[i].graphics.setFillStyle(e.color),this.cells[i].graphics.setAlpha(.95))})}),this.isAnimating||(this.isReady=!0),this.cache.audio.exists("bgm_title")&&(this.titleBgm=this.sound.add("bgm_title",{volume:.5,loop:!0}),this.titleBgm.play())})})}calculateGridSize(){const t=this.cameras.main.width,e=this.cameras.main.height,i=Math.min(1,t/at.BASE_WIDTH),a=Math.max(at.MIN_CELL_SIZE,Math.floor(at.BASE_CELL_SIZE*i));this.gap=1,this.cellWidth=a,this.cellHeight=a,this.cols=Math.ceil((t+this.gap)/(a+this.gap)),this.rows=Math.ceil((e+this.gap)/(a+this.gap));const s=.05,n=t*(1-s*2),o=e*(1-s*2),l=16/9,h=n/o;let c,r;h>l?(r=o,c=o*l):(c=n,r=n/l);const d=(t-c)/2,y=(e-r)/2;this.registry.set("gameBounds",{x:d,y,width:c,height:r}),console.log(`Grid: ${this.cols}x${this.rows}, cellSize: ${a}, gameBounds: ${c.toFixed(0)}x${r.toFixed(0)}`)}createGrid(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.cols;e++){const i=e*(this.cellWidth+this.gap)+this.cellWidth/2,a=t*(this.cellHeight+this.gap)+this.cellHeight/2,s=this.add.rectangle(i,a,this.cellWidth,this.cellHeight,2236962);s.setAlpha(0),this.cells.push({x:e,y:t,graphics:s,delay:0,originalColor:2236962,isText:!1})}}processTextConfig(){this.textPixels=this.textRenderer.processConfig(Dt,this.cols,this.rows),this.textPixels.forEach(t=>{t.forEach(e=>{const i=e.gridY*this.cols+e.gridX;this.cells[i]&&(this.cells[i].originalColor=e.color,this.cells[i].isText=!0)})})}startEntryAnimation(){this.isAnimating=!0;const t=new Set;for(let g=0;g<this.cells.length;g++)t.add(g);const e=20,i=50,a=10,n=Math.floor(200/a),o=3e3;let l=0,h=!1;const c=(g,u)=>u*this.cols+g,r=g=>({x:g%this.cols,y:Math.floor(g/this.cols)}),d=g=>{const u=this.cells[g];u.graphics.setAlpha(1),u.graphics.setFillStyle(16777215),this.tweens.add({targets:u.graphics,fillColor:{from:16777215,to:u.originalColor},alpha:{from:1,to:.2},duration:80,ease:"Linear"})},y=g=>{const{x:u,y:p}=r(g),M=n,f=[];for(let x=0;x<=M;x++)f[x]=[];for(let x=-M;x<=M;x++)for(let b=-M;b<=M;b++){const v=u+b,P=p+x;if(v>=0&&v<this.cols&&P>=0&&P<this.rows){const T=Math.sqrt(b*b+x*x),E=Math.floor(T);if(E<=M){const I=c(v,P);f[E].push(I)}}}let w=0;const C=()=>{w>M||(f[w].forEach(x=>{t.has(x)&&(t.delete(x),d(x))}),w++,w<=M&&this.time.delayedCall(a,C))};C()},S=()=>{if(h)return;if(l>=o||t.size===0){this.finishEntry(t),h=!0;return}const g=Array.from(t),u=Math.min(e,g.length);for(let p=0;p<u&&g.length!==0;p++){const M=Math.floor(Math.random()*g.length),f=g[M];g.splice(M,1),t.has(f)&&y(f)}l+=i,t.size>0&&l<o?this.time.delayedCall(i,S):h||(this.finishEntry(t),h=!0)};S()}finishEntry(t){t.forEach(e=>{const i=this.cells[e];i.graphics.setAlpha(.2),i.graphics.setFillStyle(i.originalColor)}),this.time.delayedCall(100,()=>{this.isAnimating=!1,this.isLoading||(this.isReady=!0)})}startExitAnimation(t,e){this.isAnimating=!0,this.titleBgm&&this.titleBgm.isPlaying&&this.titleBgm.stop();const i=this.cameras.main.width,a=this.cameras.main.height;this.scene.launch("MainScene"),this.scene.bringToTop("GridScene");const s=t*(this.cellWidth+this.gap)+this.cellWidth/2,n=e*(this.cellHeight+this.gap)+this.cellHeight/2;this.registry.events.emit("reveal-update",{x:s,y:n,radius:0}),this.cells.forEach(r=>{r.graphics.setFillStyle(0),r.graphics.setAlpha(1)}),this.backgroundImage.setVisible(!1);const o=5;let l=0;this.cells.forEach(r=>{const d=r.x-t,y=r.y-e,S=Math.sqrt(d*d+y*y);r.delay=Math.floor(S*o),r.delay>l&&(l=r.delay)});const h=Math.sqrt(Math.max(s,i-s)**2+Math.max(n,a-n)**2)+50,c=l+150;this.tweens.addCounter({from:0,to:h,duration:c,ease:"Linear",onUpdate:r=>{const d=r.getValue()??0;this.registry.events.emit("reveal-update",{x:s,y:n,radius:d})}}),this.cells.forEach(r=>{this.time.delayedCall(r.delay,()=>{r.graphics.setFillStyle(16777215),r.graphics.setAlpha(1),this.tweens.addCounter({from:0,to:100,duration:200,ease:"Linear",onUpdate:d=>{const y=d.getValue()??0;let S,g;y<15?(S=16777215,g=1):y<30?(S=16776960,g=1):y<50?(S=16746496,g=1):y<70?(S=16720384,g=1-(y-50)/50):(S=6684672,g=1-(y-50)/50),r.graphics.setFillStyle(S),r.graphics.setAlpha(Math.max(0,g))},onComplete:()=>{r.graphics.setVisible(!1)}})})}),this.time.delayedCall(l+200,()=>{this.registry.events.emit("reveal-complete"),this.scene.stop("GridScene")})}};k(at,"BASE_CELL_SIZE",10),k(at,"MIN_CELL_SIZE",4),k(at,"BASE_WIDTH",1920);let wt=at;const Et=document.getElementById("version-info");Et&&(Et.textContent="v0.4.0a");let Z=null;function Xt(){return window.innerWidth>window.innerHeight}function vt(){return window.visualViewport?window.visualViewport.height:window.innerHeight}function Yt(){if(Z)return;const J={type:_.AUTO,width:window.innerWidth,height:vt(),parent:"app",backgroundColor:"#111111",pixelArt:!0,scale:{mode:_.Scale.RESIZE,autoCenter:_.Scale.CENTER_BOTH},physics:{default:"arcade",arcade:{gravity:{x:0,y:0},debug:!1}},scene:[wt,Bt,Ct]};Z=new _.Game(J),Z.events.once("ready",()=>{Z&&Z.sound&&(Z.sound.volume=.5)})}function bt(){(window.innerWidth>900||Xt())&&Yt()}bt();window.addEventListener("resize",bt);window.addEventListener("orientationchange",()=>{setTimeout(bt,100)});window.visualViewport&&window.visualViewport.addEventListener("resize",()=>{Z&&Z.scale.resize(window.innerWidth,vt())});document.addEventListener("fullscreenchange",()=>{Z&&setTimeout(()=>{Z.scale.resize(window.innerWidth,vt())},100)});window.addEventListener("volumechange",J=>{Z&&Z.sound&&(Z.sound.volume=J.detail.volume)});
